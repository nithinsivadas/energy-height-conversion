<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.54
     from g77.texi on 30 July 1999 -->

<TITLE>Using and Porting GNU Fortran - The GNU Fortran Language</TITLE>
<link href="g77_13.html" rel=Next>
<link href="g77_11.html" rel=Previous>
<link href="g77_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="g77_1.html">first</A>, <A HREF="g77_11.html">previous</A>, <A HREF="g77_13.html">next</A>, <A HREF="g77_28.html">last</A> section, <A HREF="g77_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC26" HREF="g77_toc.html#TOC26">The GNU Fortran Language</A></H1>

<P>
<A NAME="IDX639"></A>
<A NAME="IDX640"></A>
<A NAME="IDX641"></A>
GNU Fortran supports a variety of extensions to, and dialects
of, the Fortran language.
Its primary base is the ANSI FORTRAN 77 standard, currently available on
the network at
<A HREF="http://www.fortran.com/fortran/F77_std/rjcnf0001.html"><TT>http://www.fortran.com/fortran/F77_std/rjcnf0001.html</TT></A>
or as monolithic text at
<A HREF="http://www.fortran.com/fortran/F77_std/f77_std.html"><TT>http://www.fortran.com/fortran/F77_std/f77_std.html</TT></A>.
It offers some extensions that are popular among users
of UNIX <CODE>f77</CODE> and <CODE>f2c</CODE> compilers, some that
are popular among users of other compilers (such as Digital
products), some that are popular among users of the
newer Fortran 90 standard, and some that are introduced
by GNU Fortran.

</P>
<P>
<A NAME="IDX642"></A>
(If you need a text on Fortran,
a few freely available electronic references have pointers from
<A HREF="http://www.fortran.com/fortran/Books/"><TT>http://www.fortran.com/fortran/Books/</TT></A>.  There is a `cooperative
net project', <CITE>User Notes on Fortran Programming</CITE> at
<A HREF="ftp://vms.huji.ac.il/fortran/"><TT>ftp://vms.huji.ac.il/fortran/</TT></A> and mirrors elsewhere; some of this
material might not apply specifically to <CODE>g77</CODE>.)

</P>
<P>
Part of what defines a particular implementation of a Fortran
system, such as <CODE>g77</CODE>, is the particular characteristics
of how it supports types, constants, and so on.
Much of this is left up to the implementation by the various
Fortran standards and accepted practice in the industry.

</P>
<P>
The GNU Fortran <EM>language</EM> is described below.
Much of the material is organized along the same lines
as the ANSI FORTRAN 77 standard itself.

</P>
<P>
See section <A HREF="g77_13.html#SEC344">Other Dialects</A>, for information on features <CODE>g77</CODE> supports
that are not part of the GNU Fortran language.

</P>
<P>
<EM>Note</EM>: This portion of the documentation definitely needs a lot
of work!

</P>

<UL>
Relationship to the ANSI FORTRAN 77 standard:
<LI><A HREF="g77_12.html#SEC27">Direction of Language Development</A>: Where GNU Fortran is headed.
<LI><A HREF="g77_12.html#SEC28">Standard Support</A>: Degree of support for the standard.

Extensions to the ANSI FORTRAN 77 standard:
<LI><A HREF="g77_12.html#SEC33">Conformance</A>
<LI><A HREF="g77_12.html#SEC34">Notation Used</A>
<LI><A HREF="g77_12.html#SEC35">Terms and Concepts</A>
<LI><A HREF="g77_12.html#SEC39">Characters Lines Sequence</A>
<LI><A HREF="g77_12.html#SEC48">Data Types and Constants</A>
<LI><A HREF="g77_12.html#SEC56">Expressions</A>
<LI><A HREF="g77_12.html#SEC58">Specification Statements</A>
<LI><A HREF="g77_12.html#SEC61">Control Statements</A>
<LI><A HREF="g77_12.html#SEC66">Functions and Subroutines</A>
<LI><A HREF="g77_12.html#SEC340">Scope and Classes of Names</A>
<LI><A HREF="g77_12.html#SEC342">I/O</A>
<LI><A HREF="g77_12.html#SEC343">Fortran 90 Features</A>
</UL>



<H2><A NAME="SEC27" HREF="g77_toc.html#TOC27">Direction of Language Development</A></H2>
<P>
<A NAME="IDX643"></A>
<A NAME="IDX644"></A>
<A NAME="IDX645"></A>

</P>
<P>
The purpose of the following description of the GNU Fortran
language is to promote wide portability of GNU Fortran programs.

</P>
<P>
GNU Fortran is an evolving language, due to the
fact that <CODE>g77</CODE> itself is in beta test.
Some current features of the language might later
be redefined as dialects of Fortran supported by <CODE>g77</CODE>
when better ways to express these features are added to <CODE>g77</CODE>,
for example.
Such features would still be supported by
<CODE>g77</CODE>, but would be available only when
one or more command-line options were used.

</P>
<P>
The GNU Fortran <EM>language</EM> is distinct from the
GNU Fortran <EM>compilation system</EM> (<CODE>g77</CODE>).

</P>
<P>
For example, <CODE>g77</CODE> supports various dialects of
Fortran--in a sense, these are languages other than
GNU Fortran--though its primary
purpose is to support the GNU Fortran language, which also is
described in its documentation and by its implementation.

</P>
<P>
On the other hand, non-GNU compilers might offer
support for the GNU Fortran language, and are encouraged
to do so.

</P>
<P>
Currently, the GNU Fortran language is a fairly fuzzy object.
It represents something of a cross between what <CODE>g77</CODE> accepts
when compiling using the prevailing defaults and what this
document describes as being part of the language.

</P>
<P>
Future versions of <CODE>g77</CODE> are expected to clarify the
definition of the language in the documentation.
Often, this will mean adding new features to the language, in the form
of both new documentation and new support in <CODE>g77</CODE>.
However, it might occasionally mean removing a feature
from the language itself to "dialect" status.
In such a case, the documentation would be adjusted
to reflect the change, and <CODE>g77</CODE> itself would likely be changed
to require one or more command-line options to continue supporting
the feature.

</P>
<P>
The development of the GNU Fortran language is intended to strike
a balance between:

</P>

<UL>
<LI>

Serving as a mostly-upwards-compatible language from the
de facto UNIX Fortran dialect as supported by <CODE>f77</CODE>.

<LI>

Offering new, well-designed language features.
Attributes of such features include
not making existing code any harder to read
(for those who might be unaware that the new
features are not in use) and
not making state-of-the-art
compilers take longer to issue diagnostics,
among others.

<LI>

Supporting existing, well-written code without gratuitously
rejecting non-standard constructs, regardless of the origin
of the code (its dialect).

<LI>

Offering default behavior and command-line options to reduce
and, where reasonable, eliminate the need for programmers to make
any modifications to code that already works in existing
production environments.

<LI>

Diagnosing constructs that have different meanings in different
systems, languages, and dialects, while offering clear,
less ambiguous ways to express each of the different meanings
so programmers can change their code appropriately.
</UL>

<P>
One of the biggest practical challenges for the developers of the
GNU Fortran language is meeting the sometimes contradictory demands
of the above items.

</P>
<P>
For example, a feature might be widely used in one popular environment,
but the exact same code that utilizes that feature might not work
as expected--perhaps it might mean something entirely different--in
another popular environment.

</P>
<P>
Traditionally, Fortran compilers--even portable ones--have solved this
problem by simply offering the appropriate feature to users of
the respective systems.
This approach treats users of various Fortran systems and dialects
as remote "islands", or camps, of programmers, and assume that these
camps rarely come into contact with each other (or,
especially, with each other's code).

</P>
<P>
Project GNU takes a radically different approach to software and language
design, in that it assumes that users of GNU software do not necessarily
care what kind of underlying system they are using, regardless
of whether they are using software (at the user-interface
level) or writing it (for example, writing Fortran or C code).

</P>
<P>
As such, GNU users rarely need consider just what kind of underlying
hardware (or, in many cases, operating system) they are using at any
particular time.
They can use and write software designed for a general-purpose,
widely portable, heterogenous environment--the GNU environment.

</P>
<P>
In line with this philosophy, GNU Fortran must evolve into a product
that is widely ported and portable not only in the sense that it can
be successfully built, installed, and run by users, but in the larger
sense that its users can use it in the same way, and expect largely the
same behaviors from it, regardless of the kind of system they are using
at any particular time.

</P>
<P>
This approach constrains the solutions <CODE>g77</CODE> can use to resolve
conflicts between various camps of Fortran users.
If these two camps disagree about what a particular construct should
mean, <CODE>g77</CODE> cannot simply be changed to treat that particular construct as
having one meaning without comment (such as a warning), lest the users
expecting it to have the other meaning are unpleasantly surprised that
their code misbehaves when executed.

</P>
<P>
The use of the ASCII backslash character in character constants is
an excellent (and still somewhat unresolved) example of this kind of
controversy.
See section <A HREF="g77_20.html#SEC662">Backslash in Constants</A>.
Other examples are likely to arise in the future, as <CODE>g77</CODE> developers
strive to improve its ability to accept an ever-wider variety of existing
Fortran code without requiring significant modifications to said code.

</P>
<P>
Development of GNU Fortran is further constrained by the desire
to avoid requiring programmers to change their code.
This is important because it allows programmers, administrators,
and others to more faithfully evaluate and validate <CODE>g77</CODE>
(as an overall product and as new versions are distributed)
without having to support multiple versions of their programs
so that they continue to work the same way on their existing
systems (non-GNU perhaps, but possibly also earlier versions
of <CODE>g77</CODE>).

</P>


<H2><A NAME="SEC28" HREF="g77_toc.html#TOC28">ANSI FORTRAN 77 Standard Support</A></H2>
<P>
<A NAME="IDX646"></A>
<A NAME="IDX647"></A>
<A NAME="IDX648"></A>
<A NAME="IDX649"></A>
<A NAME="IDX650"></A>

</P>
<P>
GNU Fortran supports ANSI FORTRAN 77 with the following caveats.
In summary, the only ANSI FORTRAN 77 features <CODE>g77</CODE> doesn't
support are those that are probably rarely used in actual code,
some of which are explicitly disallowed by the Fortran 90 standard.

</P>

<UL>
<LI><A HREF="g77_12.html#SEC29">No Passing External Assumed-length</A>: CHAR*(*) CFUNC restriction.
<LI><A HREF="g77_12.html#SEC30">No Passing Dummy Assumed-length</A>: CHAR*(*) CFUNC restriction.
<LI><A HREF="g77_12.html#SEC31">No Pathological Implied-DO</A>: No <SAMP>`((..., I=...), I=...)'</SAMP>.
<LI><A HREF="g77_12.html#SEC32">No Useless Implied-DO</A>: No <SAMP>`(A, I=1, 1)'</SAMP>.
</UL>



<H3><A NAME="SEC29" HREF="g77_toc.html#TOC29">No Passing External Assumed-length</A></H3>

<P>
<CODE>g77</CODE> disallows passing of an external procedure
as an actual argument if the procedure's
type is declared <CODE>CHARACTER*(*)</CODE>.  For example:

</P>

<PRE>
CHARACTER*(*) CFUNC
EXTERNAL CFUNC
CALL FOO(CFUNC)
END
</PRE>

<P>
It isn't clear whether the standard considers this conforming.

</P>


<H3><A NAME="SEC30" HREF="g77_toc.html#TOC30">No Passing Dummy Assumed-length</A></H3>

<P>
<CODE>g77</CODE> disallows passing of a dummy procedure
as an actual argument if the procedure's
type is declared <CODE>CHARACTER*(*)</CODE>.

</P>

<PRE>
SUBROUTINE BAR(CFUNC)
CHARACTER*(*) CFUNC
EXTERNAL CFUNC
CALL FOO(CFUNC)
END
</PRE>

<P>
It isn't clear whether the standard considers this conforming.

</P>


<H3><A NAME="SEC31" HREF="g77_toc.html#TOC31">No Pathological Implied-DO</A></H3>

<P>
The <CODE>DO</CODE> variable for an implied-<CODE>DO</CODE> construct in a
<CODE>DATA</CODE> statement may not be used as the <CODE>DO</CODE> variable
for an outer implied-<CODE>DO</CODE> construct.  For example, this
fragment is disallowed by <CODE>g77</CODE>:

</P>

<PRE>
DATA ((A(I, I), I= 1, 10), I= 1, 10) /.../
</PRE>

<P>
This also is disallowed by Fortran 90, as it offers no additional
capabilities and would have a variety of possible meanings.

</P>
<P>
Note that it is <EM>very</EM> unlikely that any production Fortran code
tries to use this unsupported construct.

</P>


<H3><A NAME="SEC32" HREF="g77_toc.html#TOC32">No Useless Implied-DO</A></H3>

<P>
An array element initializer in an implied-<CODE>DO</CODE> construct in a
<CODE>DATA</CODE> statement must contain at least one reference to the <CODE>DO</CODE>
variables of each outer implied-<CODE>DO</CODE> construct.  For example,
this fragment is disallowed by <CODE>g77</CODE>:

</P>

<PRE>
DATA (A, I= 1, 1) /1./
</PRE>

<P>
This also is disallowed by Fortran 90, as FORTRAN 77's more permissive
requirements offer no additional capabilities.
However, <CODE>g77</CODE> doesn't necessarily diagnose all cases
where this requirement is not met.

</P>
<P>
Note that it is <EM>very</EM> unlikely that any production Fortran code
tries to use this unsupported construct.

</P>


<H2><A NAME="SEC33" HREF="g77_toc.html#TOC33">Conformance</A></H2>

<P>
(The following information augments or overrides the information in
Section 1.4 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 1 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>
<P>
The definition of the GNU Fortran language is akin to that of
the ANSI FORTRAN 77 language in that it does not generally require
conforming implementations to diagnose cases where programs do
not conform to the language.

</P>
<P>
However, <CODE>g77</CODE> as a compiler is being developed in a way that
is intended to enable it to diagnose such cases in an easy-to-understand
manner.

</P>
<P>
A program that conforms to the GNU Fortran language should, when
compiled, linked, and executed using a properly installed <CODE>g77</CODE>
system, perform as described by the GNU Fortran language definition.
Reasons for different behavior include, among others:

</P>

<UL>
<LI>

Use of resources (memory--heap, stack, and so on; disk space; CPU
time; etc.) exceeds those of the system.

<LI>

Range and/or precision of calculations required by the program
exceeds that of the system.

<LI>

Excessive reliance on behaviors that are system-dependent
(non-portable Fortran code).

<LI>

Bugs in the program.

<LI>

Bug in <CODE>g77</CODE>.

<LI>

Bugs in the system.
</UL>

<P>
Despite these "loopholes", the availability of a clear specification
of the language of programs submitted to <CODE>g77</CODE>, as this document
is intended to provide, is considered an important aspect of providing
a robust, clean, predictable Fortran implementation.

</P>
<P>
The definition of the GNU Fortran language, while having no special
legal status, can therefore be viewed as a sort of contract, or agreement.
This agreement says, in essence, "if you write a program in this language,
and run it in an environment (such as a <CODE>g77</CODE> system) that supports
this language, the program should behave in a largely predictable way".

</P>


<H2><A NAME="SEC34" HREF="g77_toc.html#TOC34">Notation Used in This Chapter</A></H2>

<P>
(The following information augments or overrides the information in
Section 1.5 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 1 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>
<P>
In this chapter, "must" denotes a requirement, "may" denotes permission,
and "must not" and "may not" denote prohibition.
Terms such as "might", "should", and "can" generally add little or
nothing in the way of weight to the GNU Fortran language itself,
but are used to explain or illustrate the language.

</P>
<P>
For example:

</P>

<PRE>
"The <CODE>FROBNITZ</CODE> statement must precede all executable
statements in a program unit, and may not specify any dummy
arguments.  It may specify local or common variables and arrays.
Its use should be limited to portions of the program designed to
be non-portable and system-specific, because it might cause the
containing program unit to behave quite differently on different
systems."
</PRE>

<P>
Insofar as the GNU Fortran language is specified,
the requirements and permissions denoted by the above sample statement
are limited to the placement of the statement and the kinds of
things it may specify.
The rest of the statement--the content regarding non-portable portions
of the program and the differing behavior of program units containing
the <CODE>FROBNITZ</CODE> statement--does not pertain the GNU Fortran
language itself.
That content offers advice and warnings about the <CODE>FROBNITZ</CODE>
statement.

</P>
<P>
<EM>Remember:</EM> The GNU Fortran language definition specifies
both what constitutes a valid GNU Fortran program and how,
given such a program, a valid GNU Fortran implementation is
to interpret that program.

</P>
<P>
It is <EM>not</EM> incumbent upon a valid GNU Fortran implementation
to behave in any particular way, any consistent way, or any
predictable way when it is asked to interpret input that is
<EM>not</EM> a valid GNU Fortran program.

</P>
<P>
Such input is said to have <STRONG>undefined</STRONG> behavior when
interpreted by a valid GNU Fortran implementation, though
an implementation may choose to specify behaviors for some
cases of inputs that are not valid GNU Fortran programs.

</P>
<P>
Other notation used herein is that of the GNU texinfo format,
which is used to generate printed hardcopy, on-line hypertext
(Info), and on-line HTML versions, all from a single source
document.
This notation is used as follows:

</P>

<UL>
<LI>

Keywords defined by the GNU Fortran language are shown
in uppercase, as in: <CODE>COMMON</CODE>, <CODE>INTEGER</CODE>, and
<CODE>BLOCK DATA</CODE>.

Note that, in practice, many Fortran programs are written
in lowercase--uppercase is used in this manual as a
means to readily distinguish keywords and sample Fortran-related
text from the prose in this document.

<LI>

Portions of actual sample program, input, or output text
look like this: <SAMP>`Actual program text'</SAMP>.

Generally, uppercase is used for all Fortran-specific and
Fortran-related text, though this does not always include
literal text within Fortran code.

For example: <SAMP>`PRINT *, 'My name is Bob''</SAMP>.

<LI>

A metasyntactic variable--that is, a name used in this document
to serve as a placeholder for whatever text is used by the
user or programmer--appears as shown in the following example:

"The <CODE>INTEGER <VAR>ivar</VAR></CODE> statement specifies that
<VAR>ivar</VAR> is a variable or array of type <CODE>INTEGER</CODE>."

In the above example, any valid text may be substituted for
the metasyntactic variable <VAR>ivar</VAR> to make the statement
apply to a specific instance, as long as the same text is
substituted for <EM>both</EM> occurrences of <VAR>ivar</VAR>.

<LI>

Ellipses ("...") are used to indicate further text that
is either unimportant or expanded upon further, elsewhere.

<LI>

Names of data types are in the style of Fortran 90, in most
cases.

See section <A HREF="g77_12.html#SEC52">Kind Notation</A>, for information on the relationship
between Fortran 90 nomenclature (such as <CODE>INTEGER(KIND=1)</CODE>)
and the more traditional, less portably concise nomenclature
(such as <CODE>INTEGER*4</CODE>).
</UL>



<H2><A NAME="SEC35" HREF="g77_toc.html#TOC35">Fortran Terms and Concepts</A></H2>

<P>
(The following information augments or overrides the information in
Chapter 2 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 2 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>

<UL>
<LI><A HREF="g77_12.html#SEC36">Syntactic Items</A>
<LI><A HREF="g77_12.html#SEC37">Statements Comments Lines</A>
<LI><A HREF="g77_12.html#SEC38">Scope of Names and Labels</A>
</UL>



<H3><A NAME="SEC36" HREF="g77_toc.html#TOC36">Syntactic Items</A></H3>

<P>
(Corresponds to Section 2.2 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
<A NAME="IDX651"></A>
In GNU Fortran, a symbolic name is at least one character long,
and has no arbitrary upper limit on length.
However, names of entities requiring external linkage (such as
external functions, external subroutines, and <CODE>COMMON</CODE> areas)
might be restricted to some arbitrary length by the system.
Such a restriction is no more constrained than that of one
through six characters.

</P>
<P>
Underscores (<SAMP>`_'</SAMP>) are accepted in symbol names after the first
character (which must be a letter).

</P>


<H3><A NAME="SEC37" HREF="g77_toc.html#TOC37">Statements, Comments, and Lines</A></H3>

<P>
(Corresponds to Section 2.3 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
<A NAME="IDX652"></A>
<A NAME="IDX653"></A>
<A NAME="IDX654"></A>
<A NAME="IDX655"></A>
<A NAME="IDX656"></A>
<A NAME="IDX657"></A>
<A NAME="IDX658"></A>
Use of an exclamation point (<SAMP>`!'</SAMP>) to begin a
trailing comment (a comment that extends to the end of the same
source line) is permitted under the following conditions:

</P>

<UL>
<LI>

The exclamation point does not appear in column 6.
Otherwise, it is treated as an indicator of a continuation
line.

<LI>

The exclamation point appears outside a character or Hollerith
constant.
Otherwise, the exclamation point is considered part of the
constant.

<LI>

The exclamation point appears to the left of any other possible
trailing comment.
That is, a trailing comment may contain exclamation points
in their commentary text.
</UL>

<P>
<A NAME="IDX659"></A>
<A NAME="IDX660"></A>
<A NAME="IDX661"></A>
Use of a semicolon (<SAMP>`;'</SAMP>) as a statement separator
is permitted under the following conditions:

</P>

<UL>
<LI>

The semicolon appears outside a character or Hollerith
constant.
Otherwise, the semicolon is considered part of the
constant.

<LI>

The semicolon appears to the left of a trailing comment.
Otherwise, the semicolon is considered part of that
comment.

<LI>

Neither a logical <CODE>IF</CODE> statement nor a non-construct
<CODE>WHERE</CODE> statement (a Fortran 90 feature) may be
followed (in the same, possibly continued, line) by
a semicolon used as a statement separator.

This restriction avoids the confusion
that can result when reading a line such as:


<PRE>
IF (VALIDP) CALL FOO; CALL BAR
</PRE>

Some readers might think the <SAMP>`CALL BAR'</SAMP> is executed
only if <SAMP>`VALIDP'</SAMP> is <CODE>.TRUE.</CODE>, while others might
assume its execution is unconditional.

(At present, <CODE>g77</CODE> does not diagnose code that
violates this restriction.)
</UL>



<H3><A NAME="SEC38" HREF="g77_toc.html#TOC38">Scope of Symbolic Names and Statement Labels</A></H3>
<P>
<A NAME="IDX662"></A>

</P>
<P>
(Corresponds to Section 2.9 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
Included in the list of entities that have a scope of a
program unit are construct names (a Fortran 90 feature).
See section <A HREF="g77_12.html#SEC64">Construct Names</A>, for more information.

</P>


<H2><A NAME="SEC39" HREF="g77_toc.html#TOC39">Characters, Lines, and Execution Sequence</A></H2>

<P>
(The following information augments or overrides the information in
Chapter 3 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 3 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>

<UL>
<LI><A HREF="g77_12.html#SEC40">Character Set</A>
<LI><A HREF="g77_12.html#SEC41">Lines</A>
<LI><A HREF="g77_12.html#SEC42">Continuation Line</A>
<LI><A HREF="g77_12.html#SEC43">Statements</A>
<LI><A HREF="g77_12.html#SEC44">Statement Labels</A>
<LI><A HREF="g77_12.html#SEC45">Order</A>
<LI><A HREF="g77_12.html#SEC46">INCLUDE</A>
<LI><A HREF="g77_12.html#SEC47">Cpp-style directives</A>
</UL>



<H3><A NAME="SEC40" HREF="g77_toc.html#TOC40">GNU Fortran Character Set</A></H3>
<P>
<A NAME="IDX663"></A>

</P>
<P>
(Corresponds to Section 3.1 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
Letters include uppercase letters (the twenty-six characters
of the English alphabet) and lowercase letters (their lowercase
equivalent).
Generally, lowercase letters may be used in place of uppercase
letters, though in character and Hollerith constants, they
are distinct.

</P>
<P>
Special characters include:

</P>

<UL>
<LI>

<A NAME="IDX664"></A>
<A NAME="IDX665"></A>
Semicolon (<SAMP>`;'</SAMP>)

<LI>

<A NAME="IDX666"></A>
<A NAME="IDX667"></A>
Exclamation point (<SAMP>`!'</SAMP>)

<LI>

<A NAME="IDX668"></A>
<A NAME="IDX669"></A>
Double quote (<SAMP>`"'</SAMP>)

<LI>

<A NAME="IDX670"></A>
<A NAME="IDX671"></A>
Backslash (<SAMP>`\'</SAMP>)

<LI>

<A NAME="IDX672"></A>
<A NAME="IDX673"></A>
Question mark (<SAMP>`?'</SAMP>)

<LI>

<A NAME="IDX674"></A>
<A NAME="IDX675"></A>
<A NAME="IDX676"></A>
Hash mark (<SAMP>`#'</SAMP>)

<LI>

<A NAME="IDX677"></A>
<A NAME="IDX678"></A>
Ampersand (<SAMP>`&#38;'</SAMP>)

<LI>

<A NAME="IDX679"></A>
<A NAME="IDX680"></A>
Percent sign (<SAMP>`%'</SAMP>)

<LI>

<A NAME="IDX681"></A>
<A NAME="IDX682"></A>
Underscore (<SAMP>`_'</SAMP>)

<LI>

<A NAME="IDX683"></A>
<A NAME="IDX684"></A>
<A NAME="IDX685"></A>
<A NAME="IDX686"></A>
<A NAME="IDX687"></A>
Open angle (<SAMP>`&#60;'</SAMP>)

<LI>

<A NAME="IDX688"></A>
<A NAME="IDX689"></A>
<A NAME="IDX690"></A>
<A NAME="IDX691"></A>
<A NAME="IDX692"></A>
Close angle (<SAMP>`&#62;'</SAMP>)

<LI>

The FORTRAN 77 special characters (<KBD>SPC</KBD>, <SAMP>`='</SAMP>,
<SAMP>`+'</SAMP>, <SAMP>`-'</SAMP>, <SAMP>`*'</SAMP>, <SAMP>`/'</SAMP>, <SAMP>`('</SAMP>,
<SAMP>`)'</SAMP>, <SAMP>`,'</SAMP>, <SAMP>`.'</SAMP>, <SAMP>`$'</SAMP>, <SAMP>`''</SAMP>,
and <SAMP>`:'</SAMP>)
</UL>

<P>
<A NAME="IDX693"></A>
<A NAME="IDX694"></A>
<A NAME="IDX695"></A>
Note that this document refers to <KBD>SPC</KBD> as <STRONG>space</STRONG>,
while X3.9-1978 FORTRAN 77 refers to it as <STRONG>blank</STRONG>.

</P>


<H3><A NAME="SEC41" HREF="g77_toc.html#TOC41">Lines</A></H3>
<P>
<A NAME="IDX696"></A>
<A NAME="IDX697"></A>
<A NAME="IDX698"></A>
<A NAME="IDX699"></A>
<A NAME="IDX700"></A>
<A NAME="IDX701"></A>
<A NAME="IDX702"></A>
<A NAME="IDX703"></A>

</P>
<P>
(Corresponds to Section 3.2 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
The way a Fortran compiler views source files depends entirely on the
implementation choices made for the compiler, since those choices
are explicitly left to the implementation by the published Fortran
standards.

</P>
<P>
The GNU Fortran language mandates a view applicable to UNIX-like
text files--files that are made up of an arbitrary number of lines,
each with an arbitrary number of characters (sometimes called stream-based
files).

</P>
<P>
This view does not apply to types of files that are specified as
having a particular number of characters on every single line (sometimes
referred to as record-based files).

</P>
<P>
Because a "line in a program unit is a sequence of 72 characters",
to quote X3.9-1978, the GNU Fortran language specifies that a
stream-based text file is translated to GNU Fortran lines as follows:

</P>

<UL>
<LI>

A newline in the file is the character that represents the end of
a line of text to the underlying system.
For example, on ASCII-based systems, a newline is the <KBD>NL</KBD>
character, which has ASCII value 10 (decimal).

<LI>

Each newline in the file serves to end the line of text that precedes
it (and that does not contain a newline).

<LI>

The end-of-file marker (<CODE>EOF</CODE>) also serves to end the line
of text that precedes it (and that does not contain a newline).

<LI>

<A NAME="IDX704"></A>
<A NAME="IDX705"></A>
<A NAME="IDX706"></A>
Any line of text that is shorter than 72 characters is padded to that length
with spaces (called "blanks" in the standard).

<LI>

Any line of text that is longer than 72 characters is truncated to that
length, but the truncated remainder must consist entirely of spaces.

<LI>

Characters other than newline and the GNU Fortran character set
are invalid.
</UL>

<P>
For the purposes of the remainder of this description of the GNU
Fortran language, the translation described above has already
taken place, unless otherwise specified.

</P>
<P>
The result of the above translation is that the source file appears,
in terms of the remainder of this description of the GNU Fortran language,
as if it had an arbitrary
number of 72-character lines, each character being among the GNU Fortran
character set.

</P>
<P>
For example, if the source file itself has two newlines in a row,
the second newline becomes, after the above translation, a single
line containing 72 spaces.

</P>


<H3><A NAME="SEC42" HREF="g77_toc.html#TOC42">Continuation Line</A></H3>
<P>
<A NAME="IDX707"></A>
<A NAME="IDX708"></A>
<A NAME="IDX709"></A>
<A NAME="IDX710"></A>

</P>
<P>
(Corresponds to Section 3.2.3 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
A continuation line is any line that both

</P>

<UL>
<LI>

Contains a continuation character, and

<LI>

Contains only spaces in columns 1 through 5
</UL>

<P>
A continuation character is any character of the GNU Fortran character set
other than space (<KBD>SPC</KBD>) or zero (<SAMP>`0'</SAMP>)
in column 6, or a digit (<SAMP>`0'</SAMP> through <SAMP>`9'</SAMP>) in column
7 through 72 of a line that has only spaces to the left of that
digit.

</P>
<P>
The continuation character is ignored as far as the content of
the statement is concerned.

</P>
<P>
The GNU Fortran language places no limit on the number of
continuation lines in a statement.
In practice, the limit depends on a variety of factors, such as
available memory, statement content, and so on, but no
GNU Fortran system may impose an arbitrary limit.

</P>


<H3><A NAME="SEC43" HREF="g77_toc.html#TOC43">Statements</A></H3>

<P>
(Corresponds to Section 3.3 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
Statements may be written using an arbitrary number of continuation
lines.

</P>
<P>
Statements may be separated using the semicolon (<SAMP>`;'</SAMP>), except
that the logical <CODE>IF</CODE> and non-construct <CODE>WHERE</CODE> statements
may not be separated from subsequent statements using only a semicolon
as statement separator.

</P>
<P>
The <CODE>END PROGRAM</CODE>, <CODE>END SUBROUTINE</CODE>, <CODE>END FUNCTION</CODE>,
and <CODE>END BLOCK DATA</CODE> statements are alternatives to the <CODE>END</CODE>
statement.
These alternatives may be written as normal statements--they are not
subject to the restrictions of the <CODE>END</CODE> statement.

</P>
<P>
However, no statement other than <CODE>END</CODE> may have an initial line
that appears to be an <CODE>END</CODE> statement--even <CODE>END PROGRAM</CODE>,
for example, must not be written as:

</P>

<PRE>
      END
     &#38;PROGRAM
</PRE>



<H3><A NAME="SEC44" HREF="g77_toc.html#TOC44">Statement Labels</A></H3>

<P>
(Corresponds to Section 3.4 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
A statement separated from its predecessor via a semicolon may be
labeled as follows:

</P>

<UL>
<LI>

The semicolon is followed by the label for the statement,
which in turn follows the label.

<LI>

The label must be no more than five digits in length.

<LI>

The first digit of the label for the statement is not
the first non-space character on a line.
Otherwise, that character is treated as a continuation
character.
</UL>

<P>
A statement may have only one label defined for it.

</P>


<H3><A NAME="SEC45" HREF="g77_toc.html#TOC45">Order of Statements and Lines</A></H3>

<P>
(Corresponds to Section 3.5 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
Generally, <CODE>DATA</CODE> statements may precede executable statements.
However, specification statements pertaining to any entities
initialized by a <CODE>DATA</CODE> statement must precede that <CODE>DATA</CODE>
statement.
For example,
after <SAMP>`DATA I/1/'</SAMP>, <SAMP>`INTEGER I'</SAMP> is not permitted, but
<SAMP>`INTEGER J'</SAMP> is permitted.

</P>
<P>
The last line of a program unit may be an <CODE>END</CODE> statement,
or may be:

</P>

<UL>
<LI>

An <CODE>END PROGRAM</CODE> statement, if the program unit is a main program.

<LI>

An <CODE>END SUBROUTINE</CODE> statement, if the program unit is a subroutine.

<LI>

An <CODE>END FUNCTION</CODE> statement, if the program unit is a function.

<LI>

An <CODE>END BLOCK DATA</CODE> statement, if the program unit is a block data.
</UL>



<H3><A NAME="SEC46" HREF="g77_toc.html#TOC46">Including Source Text</A></H3>
<P>
<A NAME="IDX711"></A>

</P>
<P>
Additional source text may be included in the processing of
the source file via the <CODE>INCLUDE</CODE> directive:

</P>

<PRE>
INCLUDE <VAR>filename</VAR>
</PRE>

<P>
The source text to be included is identified by <VAR>filename</VAR>,
which is a literal GNU Fortran character constant.
The meaning and interpretation of <VAR>filename</VAR> depends on the
implementation, but typically is a filename.

</P>
<P>
(<CODE>g77</CODE> treats it as a filename that it searches for
in the current directory and/or directories specified
via the <SAMP>`-I'</SAMP> command-line option.)

</P>
<P>
The effect of the <CODE>INCLUDE</CODE> directive is as if the
included text directly replaced the directive in the source
file prior to interpretation of the program.
Included text may itself use <CODE>INCLUDE</CODE>.
The depth of nested <CODE>INCLUDE</CODE> references depends on
the implementation, but typically is a positive integer.

</P>
<P>
This virtual replacement treats the statements and <CODE>INCLUDE</CODE>
directives in the included text as syntactically distinct from
those in the including text.

</P>
<P>
Therefore, the first non-comment line of the included text
must not be a continuation line.
The included text must therefore have, after the non-comment
lines, either an initial line (statement), an <CODE>INCLUDE</CODE>
directive, or nothing (the end of the included text).

</P>
<P>
Similarly, the including text may end the <CODE>INCLUDE</CODE>
directive with a semicolon or the end of the line, but it
cannot follow an <CODE>INCLUDE</CODE> directive at the end of its
line with a continuation line.
Thus, the last statement in an included text may not be
continued.

</P>
<P>
Any statements between two <CODE>INCLUDE</CODE> directives on the
same line are treated as if they appeared in between the
respective included texts.
For example:

</P>

<PRE>
INCLUDE 'A'; PRINT *, 'B'; INCLUDE 'C'; END PROGRAM
</PRE>

<P>
If the text included by <SAMP>`INCLUDE 'A''</SAMP> constitutes
a <SAMP>`PRINT *, 'A''</SAMP> statement and the text included by
<SAMP>`INCLUDE 'C''</SAMP> constitutes a <SAMP>`PRINT *, 'C''</SAMP> statement,
then the output of the above sample program would be

</P>

<PRE>
A
B
C
</PRE>

<P>
(with suitable allowances for how an implementation defines
its handling of output).

</P>
<P>
Included text must not include itself directly or indirectly,
regardless of whether the <VAR>filename</VAR> used to reference
the text is the same.

</P>
<P>
Note that <CODE>INCLUDE</CODE> is <EM>not</EM> a statement.
As such, it is neither a non-executable or executable
statement.
However, if the text it includes constitutes one or more
executable statements, then the placement of <CODE>INCLUDE</CODE>
is subject to effectively the same restrictions as those
on executable statements.

</P>
<P>
An <CODE>INCLUDE</CODE> directive may be continued across multiple
lines as if it were a statement.
This permits long names to be used for <VAR>filename</VAR>.

</P>


<H3><A NAME="SEC47" HREF="g77_toc.html#TOC47">Cpp-style directives</A></H3>
<P>
<A NAME="IDX712"></A>
<A NAME="IDX713"></A>

</P>
<P>
<CODE>cpp</CODE> output-style <CODE>#</CODE> directives
(see section `C Preprocessor Output' in <CITE>The C Preprocessor</CITE>)
are recognized by the compiler even
when the preprocessor isn't run on the input (as it is when compiling
<SAMP>`.F'</SAMP> files).  (Note the distinction between these <CODE>cpp</CODE>
<CODE>#</CODE> <EM>output</EM> directives and <CODE>#line</CODE> <EM>input</EM>
directives.)

</P>


<H2><A NAME="SEC48" HREF="g77_toc.html#TOC48">Data Types and Constants</A></H2>

<P>
(The following information augments or overrides the information in
Chapter 4 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 4 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>
<P>
To more concisely express the appropriate types for
entities, this document uses the more concise
Fortran 90 nomenclature such as <CODE>INTEGER(KIND=1)</CODE>
instead of the more traditional, but less portably concise,
byte-size-based nomenclature such as <CODE>INTEGER*4</CODE>,
wherever reasonable.

</P>
<P>
When referring to generic types--in contexts where the
specific precision and range of a type are not important--this
document uses the generic type names <CODE>INTEGER</CODE>, <CODE>LOGICAL</CODE>,
<CODE>REAL</CODE>, <CODE>COMPLEX</CODE>, and <CODE>CHARACTER</CODE>.

</P>
<P>
In some cases, the context requires specification of a
particular type.
This document uses the <SAMP>`KIND='</SAMP> notation to accomplish
this throughout, sometimes supplying the more traditional
notation for clarification, though the traditional notation
might not work the same way on all GNU Fortran implementations.

</P>
<P>
Use of <SAMP>`KIND='</SAMP> makes this document more concise because
<CODE>g77</CODE> is able to define values for <SAMP>`KIND='</SAMP> that
have the same meanings on all systems, due to the way the
Fortran 90 standard specifies these values are to be used.

</P>
<P>
(In particular, that standard permits an implementation to
arbitrarily assign nonnegative values.
There are four distinct sets of assignments: one to the <CODE>CHARACTER</CODE>
type; one to the <CODE>INTEGER</CODE> type; one to the <CODE>LOGICAL</CODE> type;
and the fourth to both the <CODE>REAL</CODE> and <CODE>COMPLEX</CODE> types.
Implementations are free to assign these values in any order,
leave gaps in the ordering of assignments, and assign more than
one value to a representation.)

</P>
<P>
This makes <SAMP>`KIND='</SAMP> values superior to the values used
in non-standard statements such as <SAMP>`INTEGER*4'</SAMP>, because
the meanings of the values in those statements vary from machine
to machine, compiler to compiler, even operating system to
operating system.

</P>
<P>
However, use of <SAMP>`KIND='</SAMP> is <EM>not</EM> generally recommended
when writing portable code (unless, for example, the code is
going to be compiled only via <CODE>g77</CODE>, which is a widely
ported compiler).
GNU Fortran does not yet have adequate language constructs to
permit use of <SAMP>`KIND='</SAMP> in a fashion that would make the
code portable to Fortran 90 implementations; and, this construct
is known to <EM>not</EM> be accepted by many popular FORTRAN 77
implementations, so it cannot be used in code that is to be ported
to those.

</P>
<P>
The distinction here is that this document is able to use
specific values for <SAMP>`KIND='</SAMP> to concisely document the
types of various operations and operands.

</P>
<P>
A Fortran program should use the FORTRAN 77 designations for the
appropriate GNU Fortran types--such as <CODE>INTEGER</CODE> for
<CODE>INTEGER(KIND=1)</CODE>, <CODE>REAL</CODE> for <CODE>REAL(KIND=1)</CODE>,
and <CODE>DOUBLE COMPLEX</CODE> for <CODE>COMPLEX(KIND=2)</CODE>---and,
where no such designations exist, make use of appropriate
techniques (preprocessor macros, parameters, and so on)
to specify the types in a fashion that may be easily adjusted
to suit each particular implementation to which the program
is ported.
(These types generally won't need to be adjusted for ports of
<CODE>g77</CODE>.)

</P>
<P>
Further details regarding GNU Fortran data types and constants
are provided below.

</P>

<UL>
<LI><A HREF="g77_12.html#SEC49">Types</A>
<LI><A HREF="g77_12.html#SEC53">Constants</A>
<LI><A HREF="g77_12.html#SEC54">Integer Type</A>
<LI><A HREF="g77_12.html#SEC55">Character Type</A>
</UL>



<H3><A NAME="SEC49" HREF="g77_toc.html#TOC49">Data Types</A></H3>

<P>
(Corresponds to Section 4.1 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
GNU Fortran supports these types:

</P>

<OL>
<LI>

Integer (generic type <CODE>INTEGER</CODE>)

<LI>

Real (generic type <CODE>REAL</CODE>)

<LI>

Double precision

<LI>

Complex (generic type <CODE>COMPLEX</CODE>)

<LI>

Logical (generic type <CODE>LOGICAL</CODE>)

<LI>

Character (generic type <CODE>CHARACTER</CODE>)

<LI>

Double Complex
</OL>

<P>
(The types numbered 1 through 6 above are standard FORTRAN 77 types.)

</P>
<P>
The generic types shown above are referred to in this document
using only their generic type names.
Such references usually indicate that any specific type (kind)
of that generic type is valid.

</P>
<P>
For example, a context described in this document as accepting
the <CODE>COMPLEX</CODE> type also is likely to accept the
<CODE>DOUBLE COMPLEX</CODE> type.

</P>
<P>
The GNU Fortran language supports three ways to specify
a specific kind of a generic type.

</P>

<UL>
<LI><A HREF="g77_12.html#SEC50">Double Notation</A>: As in <CODE>DOUBLE COMPLEX</CODE>.
<LI><A HREF="g77_12.html#SEC51">Star Notation</A>: As in <CODE>INTEGER*4</CODE>.
<LI><A HREF="g77_12.html#SEC52">Kind Notation</A>: As in <CODE>INTEGER(KIND=1)</CODE>.
</UL>



<H4><A NAME="SEC50" HREF="g77_toc.html#TOC50">Double Notation</A></H4>

<P>
The GNU Fortran language supports two uses of the keyword
<CODE>DOUBLE</CODE> to specify a specific kind of type:

</P>

<UL>
<LI>

<CODE>DOUBLE PRECISION</CODE>, equivalent to <CODE>REAL(KIND=2)</CODE>

<LI>

<CODE>DOUBLE COMPLEX</CODE>, equivalent to <CODE>COMPLEX(KIND=2)</CODE>
</UL>

<P>
Use one of the above forms where a type name is valid.

</P>
<P>
While use of this notation is popular, it doesn't scale
well in a language or dialect rich in intrinsic types,
as is the case for the GNU Fortran language (especially
planned future versions of it).

</P>
<P>
After all, one rarely sees type names such as <SAMP>`DOUBLE INTEGER'</SAMP>,
<SAMP>`QUADRUPLE REAL'</SAMP>, or <SAMP>`QUARTER INTEGER'</SAMP>.
Instead, <CODE>INTEGER*8</CODE>, <CODE>REAL*16</CODE>, and <CODE>INTEGER*1</CODE>
often are substituted for these, respectively, even though they
do not always have the same meanings on all systems.
(And, the fact that <SAMP>`DOUBLE REAL'</SAMP> does not exist as such
is an inconsistency.)

</P>
<P>
Therefore, this document uses "double notation" only on occasion
for the benefit of those readers who are accustomed to it.

</P>


<H4><A NAME="SEC51" HREF="g77_toc.html#TOC51">Star Notation</A></H4>
<P>
<A NAME="IDX714"></A>

</P>
<P>
The following notation specifies the storage size for a type:

</P>

<PRE>
<VAR>generic-type</VAR>*<VAR>n</VAR>
</PRE>

<P>
<VAR>generic-type</VAR> must be a generic type--one of
<CODE>INTEGER</CODE>, <CODE>REAL</CODE>, <CODE>COMPLEX</CODE>, <CODE>LOGICAL</CODE>,
or <CODE>CHARACTER</CODE>.
<VAR>n</VAR> must be one or more digits comprising a decimal
integer number greater than zero.

</P>
<P>
Use the above form where a type name is valid.

</P>
<P>
The <SAMP>`*<VAR>n</VAR>'</SAMP> notation specifies that the amount of storage
occupied by variables and array elements of that type is <VAR>n</VAR>
times the storage occupied by a <CODE>CHARACTER*1</CODE> variable.

</P>
<P>
This notation might indicate a different degree of precision and/or
range for such variables and array elements, and the functions that
return values of types using this notation.
It does not limit the precision or range of values of that type
in any particular way--use explicit code to do that.

</P>
<P>
Further, the GNU Fortran language requires no particular values
for <VAR>n</VAR> to be supported by an implementation via the <SAMP>`*<VAR>n</VAR>'</SAMP>
notation.
<CODE>g77</CODE> supports <CODE>INTEGER*1</CODE> (as <CODE>INTEGER(KIND=3)</CODE>)
on all systems, for example,
but not all implementations are required to do so, and <CODE>g77</CODE>
is known to not support <CODE>REAL*1</CODE> on most (or all) systems.

</P>
<P>
As a result, except for <VAR>generic-type</VAR> of <CODE>CHARACTER</CODE>,
uses of this notation should be limited to isolated
portions of a program that are intended to handle system-specific
tasks and are expected to be non-portable.

</P>
<P>
(Standard FORTRAN 77 supports the <SAMP>`*<VAR>n</VAR>'</SAMP> notation for
only <CODE>CHARACTER</CODE>, where it signifies not only the amount
of storage occupied, but the number of characters in entities
of that type.
However, almost all Fortran compilers have supported this
notation for generic types, though with a variety of meanings
for <VAR>n</VAR>.)

</P>
<P>
Specifications of types using the <SAMP>`*<VAR>n</VAR>'</SAMP> notation
always are interpreted as specifications of the appropriate
types described in this document using the <SAMP>`KIND=<VAR>n</VAR>'</SAMP>
notation, described below.

</P>
<P>
While use of this notation is popular, it doesn't serve well
in the context of a widely portable dialect of Fortran, such as
the GNU Fortran language.

</P>
<P>
For example, even on one particular machine, two or more popular
Fortran compilers might well disagree on the size of a type
declared <CODE>INTEGER*2</CODE> or <CODE>REAL*16</CODE>.
Certainly there
is known to be disagreement over such things among Fortran
compilers on <EM>different</EM> systems.

</P>
<P>
Further, this notation offers no elegant way to specify sizes
that are not even multiples of the "byte size" typically
designated by <CODE>INTEGER*1</CODE>.
Use of "absurd" values (such as <CODE>INTEGER*1000</CODE>) would
certainly be possible, but would perhaps be stretching the original
intent of this notation beyond the breaking point in terms
of widespread readability of documentation and code making use
of it.

</P>
<P>
Therefore, this document uses "star notation" only on occasion
for the benefit of those readers who are accustomed to it.

</P>


<H4><A NAME="SEC52" HREF="g77_toc.html#TOC52">Kind Notation</A></H4>
<P>
<A NAME="IDX715"></A>

</P>
<P>
The following notation specifies the kind-type selector of a type:

</P>

<PRE>
<VAR>generic-type</VAR>(KIND=<VAR>n</VAR>)
</PRE>

<P>
Use the above form where a type name is valid.

</P>
<P>
<VAR>generic-type</VAR> must be a generic type--one of
<CODE>INTEGER</CODE>, <CODE>REAL</CODE>, <CODE>COMPLEX</CODE>, <CODE>LOGICAL</CODE>,
or <CODE>CHARACTER</CODE>.
<VAR>n</VAR> must be an integer initialization expression that
is a positive, nonzero value.

</P>
<P>
Programmers are discouraged from writing these values directly
into their code.
Future versions of the GNU Fortran language will offer
facilities that will make the writing of code portable
to <CODE>g77</CODE> <EM>and</EM> Fortran 90 implementations simpler.

</P>
<P>
However, writing code that ports to existing FORTRAN 77
implementations depends on avoiding the <SAMP>`KIND='</SAMP> construct.

</P>
<P>
The <SAMP>`KIND='</SAMP> construct is thus useful in the context
of GNU Fortran for two reasons:

</P>

<UL>
<LI>

It provides a means to specify a type in a fashion that
is portable across all GNU Fortran implementations (though
not other FORTRAN 77 and Fortran 90 implementations).

<LI>

It provides a sort of Rosetta stone for this document to use
to concisely describe the types of various operations and
operands.
</UL>

<P>
The values of <VAR>n</VAR> in the GNU Fortran language are
assigned using a scheme that:

</P>

<UL>
<LI>

Attempts to maximize the ability of readers
of this document to quickly familiarize themselves
with assignments for popular types

<LI>

Provides a unique value for each specific desired
meaning

<LI>

Provides a means to automatically assign new values so
they have a "natural" relationship to existing values,
if appropriate, or, if no such relationship exists, will
not interfere with future values assigned on the basis
of such relationships

<LI>

Avoids using values that are similar to values used
in the existing, popular <SAMP>`*<VAR>n</VAR>'</SAMP> notation,
to prevent readers from expecting that these implied
correspondences work on all GNU Fortran implementations
</UL>

<P>
The assignment system accomplishes this by assigning
to each "fundamental meaning" of a specific type a
unique prime number.
Combinations of fundamental meanings--for example, a type
that is two times the size of some other type--are assigned
values of <VAR>n</VAR> that are the products of the values for
those fundamental meanings.

</P>
<P>
A prime value of <VAR>n</VAR> is never given more than one fundamental
meaning, to avoid situations where some code or system
cannot reasonably provide those meanings in the form of a
single type.

</P>
<P>
The values of <VAR>n</VAR> assigned so far are:

</P>
<DL COMPACT>

<DT><CODE>KIND=0</CODE>
<DD>
This value is reserved for future use.

The planned future use is for this value to designate,
explicitly, context-sensitive kind-type selection.
For example, the expression <SAMP>`1D0 * 0.1_0'</SAMP> would
be equivalent to <SAMP>`1D0 * 0.1D0'</SAMP>.

<DT><CODE>KIND=1</CODE>
<DD>
This corresponds to the default types for
<CODE>REAL</CODE>, <CODE>INTEGER</CODE>, <CODE>LOGICAL</CODE>, <CODE>COMPLEX</CODE>,
and <CODE>CHARACTER</CODE>, as appropriate.

These are the "default" types described in the Fortran 90 standard,
though that standard does not assign any particular <SAMP>`KIND='</SAMP>
value to these types.

(Typically, these are <CODE>REAL*4</CODE>, <CODE>INTEGER*4</CODE>,
<CODE>LOGICAL*4</CODE>, and <CODE>COMPLEX*8</CODE>.)

<DT><CODE>KIND=2</CODE>
<DD>
This corresponds to types that occupy twice as much
storage as the default types.
<CODE>REAL(KIND=2)</CODE> is <CODE>DOUBLE PRECISION</CODE> (typically <CODE>REAL*8</CODE>),
<CODE>COMPLEX(KIND=2)</CODE> is <CODE>DOUBLE COMPLEX</CODE> (typically <CODE>COMPLEX*16</CODE>),

These are the "double precision" types described in the Fortran 90
standard,
though that standard does not assign any particular <SAMP>`KIND='</SAMP>
value to these types.

<VAR>n</VAR> of 4 thus corresponds to types that occupy four times
as much storage as the default types, <VAR>n</VAR> of 8 to types that
occupy eight times as much storage, and so on.

The <CODE>INTEGER(KIND=2)</CODE> and <CODE>LOGICAL(KIND=2)</CODE> types
are not necessarily supported by every GNU Fortran implementation.

<DT><CODE>KIND=3</CODE>
<DD>
This corresponds to types that occupy as much
storage as the default <CODE>CHARACTER</CODE> type,
which is the same effective type as <CODE>CHARACTER(KIND=1)</CODE>
(making that type effectively the same as <CODE>CHARACTER(KIND=3)</CODE>).

(Typically, these are <CODE>INTEGER*1</CODE> and <CODE>LOGICAL*1</CODE>.)

<VAR>n</VAR> of 6 thus corresponds to types that occupy twice as
much storage as the <VAR>n</VAR>=3 types, <VAR>n</VAR> of 12 to types
that occupy four times as much storage, and so on.

These are not necessarily supported by every GNU Fortran
implementation.

<DT><CODE>KIND=5</CODE>
<DD>
This corresponds to types that occupy half the
storage as the default (<VAR>n</VAR>=1) types.

(Typically, these are <CODE>INTEGER*2</CODE> and <CODE>LOGICAL*2</CODE>.)

<VAR>n</VAR> of 25 thus corresponds to types that occupy one-quarter
as much storage as the default types.

These are not necessarily supported by every GNU Fortran
implementation.

<DT><CODE>KIND=7</CODE>
<DD>
<A NAME="IDX716"></A>
This is valid only as <CODE>INTEGER(KIND=7)</CODE> and
denotes the <CODE>INTEGER</CODE> type that has the smallest
storage size that holds a pointer on the system.

A pointer representable by this type is capable of uniquely
addressing a <CODE>CHARACTER*1</CODE> variable, array, array element,
or substring.

(Typically this is equivalent to <CODE>INTEGER*4</CODE> or,
on 64-bit systems, <CODE>INTEGER*8</CODE>.
In a compatible C implementation, it typically would
be the same size and semantics of the C type <CODE>void *</CODE>.)
</DL>

<P>
Note that these are <EM>proposed</EM> correspondences and might change
in future versions of <CODE>g77</CODE>---avoid writing code depending
on them while <CODE>g77</CODE>, and therefore the GNU Fortran language
it defines, is in beta testing.

</P>
<P>
Values not specified in the above list are reserved to
future versions of the GNU Fortran language.

</P>
<P>
Implementation-dependent meanings will be assigned new,
unique prime numbers so as to not interfere with other
implementation-dependent meanings, and offer the possibility
of increasing the portability of code depending on such
types by offering support for them in other GNU Fortran
implementations.

</P>
<P>
Other meanings that might be given unique values are:

</P>

<UL>
<LI>

Types that make use of only half their storage size for
representing precision and range.

For example, some compilers offer options that cause
<CODE>INTEGER</CODE> types to occupy the amount of storage
that would be needed for <CODE>INTEGER(KIND=2)</CODE> types, but the
range remains that of <CODE>INTEGER(KIND=1)</CODE>.

<LI>

The IEEE single floating-point type.

<LI>

Types with a specific bit pattern (endianness), such as the
little-endian form of <CODE>INTEGER(KIND=1)</CODE>.
These could permit, conceptually, use of portable code and
implementations on data files written by existing systems.
</UL>

<P>
Future <EM>prime</EM> numbers should be given meanings in as incremental
a fashion as possible, to allow for flexibility and
expressiveness in combining types.

</P>
<P>
For example, instead of defining a prime number for little-endian
IEEE doubles, one prime number might be assigned the meaning
"little-endian", another the meaning "IEEE double", and the
value of <VAR>n</VAR> for a little-endian IEEE double would thus
naturally be the product of those two respective assigned values.
(It could even be reasonable to have IEEE values result from the
products of prime values denoting exponent and fraction sizes
and meanings, hidden bit usage, availability and representations
of special values such as subnormals, infinities, and Not-A-Numbers
(NaNs), and so on.)

</P>
<P>
This assignment mechanism, while not inherently required for
future versions of the GNU Fortran language, is worth using
because it could ease management of the "space" of supported
types much easier in the long run.

</P>
<P>
The above approach suggests a mechanism for specifying inheritance
of intrinsic (built-in) types for an entire, widely portable
product line.
It is certainly reasonable that, unlike programmers of other languages
offering inheritance mechanisms that employ verbose names for classes
and subclasses, along with graphical browsers to elucidate the
relationships, Fortran programmers would employ
a mechanism that works by multiplying prime numbers together
and finding the prime factors of such products.

</P>
<P>
Most of the advantages for the above scheme have been explained
above.
One disadvantage is that it could lead to the defining,
by the GNU Fortran language, of some fairly large prime numbers.
This could lead to the GNU Fortran language being declared
"munitions" by the United States Department of Defense.

</P>


<H3><A NAME="SEC53" HREF="g77_toc.html#TOC53">Constants</A></H3>
<P>
<A NAME="IDX717"></A>
<A NAME="IDX718"></A>

</P>
<P>
(Corresponds to Section 4.2 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
A <STRONG>typeless constant</STRONG> has one of the following forms:

</P>

<PRE>
'<VAR>binary-digits</VAR>'B
'<VAR>octal-digits</VAR>'O
'<VAR>hexadecimal-digits</VAR>'Z
'<VAR>hexadecimal-digits</VAR>'X
</PRE>

<P>
<VAR>binary-digits</VAR>, <VAR>octal-digits</VAR>, and <VAR>hexadecimal-digits</VAR>
are nonempty strings of characters in the set <SAMP>`01'</SAMP>, <SAMP>`01234567'</SAMP>,
and <SAMP>`0123456789ABCDEFabcdef'</SAMP>, respectively.
(The value for <SAMP>`A'</SAMP> (and <SAMP>`a'</SAMP>) is 10, for <SAMP>`B'</SAMP> and <SAMP>`b'</SAMP>
is 11, and so on.)

</P>
<P>
A prefix-radix constant, such as <SAMP>`Z'ABCD''</SAMP>, can optionally be
treated as typeless.  See section <A HREF="g77_9.html#SEC16">Options Controlling Fortran Dialect</A>, for information on the
<SAMP>`-ftypeless-boz'</SAMP> option.

</P>
<P>
Typeless constants have values that depend on the context in which
they are used.

</P>
<P>
All other constants, called <STRONG>typed constants</STRONG>, are interpreted--converted
to internal form--according to their inherent type.
Thus, context is <EM>never</EM> a determining factor for the type, and hence
the interpretation, of a typed constant.
(All constants in the ANSI FORTRAN 77 language are typed constants.)

</P>
<P>
For example, <SAMP>`1'</SAMP> is always type <CODE>INTEGER(KIND=1)</CODE> in GNU
Fortran (called default INTEGER in Fortran 90),
<SAMP>`9.435784839284958'</SAMP> is always type <CODE>REAL(KIND=1)</CODE> (even if the
additional precision specified is lost, and even when used in a
<CODE>REAL(KIND=2)</CODE> context), <SAMP>`1E0'</SAMP> is always type <CODE>REAL(KIND=2)</CODE>,
and <SAMP>`1D0'</SAMP> is always type <CODE>REAL(KIND=2)</CODE>.

</P>


<H3><A NAME="SEC54" HREF="g77_toc.html#TOC54">Integer Type</A></H3>

<P>
(Corresponds to Section 4.3 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
An integer constant also may have one of the following forms:

</P>

<PRE>
B'<VAR>binary-digits</VAR>'
O'<VAR>octal-digits</VAR>'
Z'<VAR>hexadecimal-digits</VAR>'
X'<VAR>hexadecimal-digits</VAR>'
</PRE>

<P>
<VAR>binary-digits</VAR>, <VAR>octal-digits</VAR>, and <VAR>hexadecimal-digits</VAR>
are nonempty strings of characters in the set <SAMP>`01'</SAMP>, <SAMP>`01234567'</SAMP>,
and <SAMP>`0123456789ABCDEFabcdef'</SAMP>, respectively.
(The value for <SAMP>`A'</SAMP> (and <SAMP>`a'</SAMP>) is 10, for <SAMP>`B'</SAMP> and <SAMP>`b'</SAMP>
is 11, and so on.)

</P>


<H3><A NAME="SEC55" HREF="g77_toc.html#TOC55">Character Type</A></H3>

<P>
(Corresponds to Section 4.8 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
<A NAME="IDX719"></A>
A character constant may be delimited by a pair of double quotes
(<SAMP>`"'</SAMP>) instead of apostrophes.
In this case, an apostrophe within the constant represents
a single apostrophe, while a double quote is represented in
the source text of the constant by two consecutive double
quotes with no intervening spaces.

</P>
<P>
<A NAME="IDX720"></A>
<A NAME="IDX721"></A>
<A NAME="IDX722"></A>
<A NAME="IDX723"></A>
<A NAME="IDX724"></A>
A character constant may be empty (have a length of zero).

</P>
<P>
A character constant may include a substring specification,
The value of such a constant is the value of the substring--for
example, the value of <SAMP>`'hello'(3:5)'</SAMP> is the same
as the value of <SAMP>`'llo''</SAMP>.

</P>


<H2><A NAME="SEC56" HREF="g77_toc.html#TOC56">Expressions</A></H2>

<P>
(The following information augments or overrides the information in
Chapter 6 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 6 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>

<UL>
<LI><A HREF="g77_12.html#SEC57">%LOC()</A>
</UL>



<H3><A NAME="SEC57" HREF="g77_toc.html#TOC57">The <CODE>%LOC()</CODE> Construct</A></H3>
<P>
<A NAME="IDX725"></A>

</P>

<PRE>
%LOC(<VAR>arg</VAR>)
</PRE>

<P>
The <CODE>%LOC()</CODE> construct is an expression
that yields the value of the location of its argument,
<VAR>arg</VAR>, in memory.
The size of the type of the expression depends on the system--typically,
it is equivalent to either <CODE>INTEGER(KIND=1)</CODE> or <CODE>INTEGER(KIND=2)</CODE>,
though it is actually type <CODE>INTEGER(KIND=7)</CODE>.

</P>
<P>
The argument to <CODE>%LOC()</CODE> must be suitable as the
left-hand side of an assignment statement.
That is, it may not be a general expression involving
operators such as addition, subtraction, and so on,
nor may it be a constant.

</P>
<P>
Use of <CODE>%LOC()</CODE> is recommended only for code that
is accessing facilities outside of GNU Fortran, such as
operating system or windowing facilities.
It is best to constrain such uses to isolated portions of
a program--portions that deal specifically and exclusively
with low-level, system-dependent facilities.
Such portions might well provide a portable interface for
use by the program as a whole, but are themselves not
portable, and should be thoroughly tested each time they
are rebuilt using a new compiler or version of a compiler.

</P>
<P>
Do not depend on <CODE>%LOC()</CODE> returning a pointer that
can be safely used to <EM>define</EM> (change) the argument.
While this might work in some circumstances, it is hard
to predict whether it will continue to work when a program
(that works using this unsafe behavior)
is recompiled using different command-line options or
a different version of <CODE>g77</CODE>.

</P>
<P>
Generally, <CODE>%LOC()</CODE> is safe when used as an argument
to a procedure that makes use of the value of the corresponding
dummy argument only during its activation, and only when
such use is restricted to referencing (reading) the value
of the argument to <CODE>%LOC()</CODE>.

</P>
<P>
<EM>Implementation Note:</EM> Currently, <CODE>g77</CODE> passes
arguments (those not passed using a construct such as <CODE>%VAL()</CODE>)
by reference or descriptor, depending on the type of
the actual argument.
Thus, given <SAMP>`INTEGER I'</SAMP>, <SAMP>`CALL FOO(I)'</SAMP> would
seem to mean the same thing as <SAMP>`CALL FOO(%VAL(%LOC(I)))'</SAMP>, and
in fact might compile to identical code.

</P>
<P>
However, <SAMP>`CALL FOO(%VAL(%LOC(I)))'</SAMP> emphatically means
"pass, by value, the address of <SAMP>`I'</SAMP> in memory".
While <SAMP>`CALL FOO(I)'</SAMP> might use that same approach in a
particular version of <CODE>g77</CODE>, another version or compiler
might choose a different implementation, such as copy-in/copy-out,
to effect the desired behavior--and which will therefore not
necessarily compile to the same code as would
<SAMP>`CALL FOO(%VAL(%LOC(I)))'</SAMP>
using the same version or compiler.

</P>
<P>
See section <A HREF="g77_18.html#SEC550">Debugging and Interfacing</A>, for detailed information on
how this particular version of <CODE>g77</CODE> implements various
constructs.

</P>


<H2><A NAME="SEC58" HREF="g77_toc.html#TOC58">Specification Statements</A></H2>

<P>
(The following information augments or overrides the information in
Chapter 8 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 8 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>

<UL>
<LI><A HREF="g77_12.html#SEC59">NAMELIST</A>
<LI><A HREF="g77_12.html#SEC60">DOUBLE COMPLEX</A>
</UL>



<H3><A NAME="SEC59" HREF="g77_toc.html#TOC59"><CODE>NAMELIST</CODE> Statement</A></H3>
<P>
<A NAME="IDX726"></A>
<A NAME="IDX727"></A>

</P>
<P>
The <CODE>NAMELIST</CODE> statement, and related I/O constructs, are
supported by the GNU Fortran language in essentially the same
way as they are by <CODE>f2c</CODE>.

</P>
<P>
This follows Fortran 90 with the restriction that on <CODE>NAMELIST</CODE>
input, subscripts must have the form

<PRE>
<VAR>subscript</VAR> [ <CODE>:</CODE> <VAR>subscript</VAR> [ <CODE>:</CODE> <VAR>stride</VAR>]]
</PRE>

<P>
i.e.

<PRE>
&#38;xx x(1:3,8:10:2)=1,2,3,4,5,6/
</PRE>

<P>
is allowed, but not, say,

<PRE>
&#38;xx x(:3,8::2)=1,2,3,4,5,6/
</PRE>

<P>
As an extension of the Fortran 90 form, <CODE>$</CODE> and <CODE>$END</CODE> may be
used in place of <CODE>&#38;</CODE> and <CODE>/</CODE> in <CODE>NAMELIST</CODE> input, so that

<PRE>
$&#38;xx x(1:3,8:10:2)=1,2,3,4,5,6 $end
</PRE>

<P>
could be used instead of the example above.

</P>


<H3><A NAME="SEC60" HREF="g77_toc.html#TOC60"><CODE>DOUBLE COMPLEX</CODE> Statement</A></H3>
<P>
<A NAME="IDX728"></A>

</P>
<P>
<CODE>DOUBLE COMPLEX</CODE> is a type-statement (and type) that
specifies the type <CODE>COMPLEX(KIND=2)</CODE> in GNU Fortran.

</P>


<H2><A NAME="SEC61" HREF="g77_toc.html#TOC61">Control Statements</A></H2>

<P>
(The following information augments or overrides the information in
Chapter 11 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 11 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>

<UL>
<LI><A HREF="g77_12.html#SEC62">DO WHILE</A>
<LI><A HREF="g77_12.html#SEC63">END DO</A>
<LI><A HREF="g77_12.html#SEC64">Construct Names</A>
<LI><A HREF="g77_12.html#SEC65">CYCLE and EXIT</A>
</UL>



<H3><A NAME="SEC62" HREF="g77_toc.html#TOC62">DO WHILE</A></H3>
<P>
<A NAME="IDX729"></A>
<A NAME="IDX730"></A>
<A NAME="IDX731"></A>

</P>
<P>
The <CODE>DO WHILE</CODE> statement, a feature of both the MIL-STD 1753 and
Fortran 90 standards, is provided by the GNU Fortran language.
The Fortran 90 "do forever" statement comprising just <CODE>DO</CODE> is
also supported.

</P>


<H3><A NAME="SEC63" HREF="g77_toc.html#TOC63">END DO</A></H3>
<P>
<A NAME="IDX732"></A>
<A NAME="IDX733"></A>

</P>
<P>
The <CODE>END DO</CODE> statement is provided by the GNU Fortran language.

</P>
<P>
This statement is used in one of two ways:

</P>

<UL>
<LI>

The Fortran 90 meaning, in which it specifies the termination
point of a single <CODE>DO</CODE> loop started with a <CODE>DO</CODE> statement
that specifies no termination label.

<LI>

The MIL-STD 1753 meaning, in which it specifies the termination
point of one or more <CODE>DO</CODE> loops, all of which start with a
<CODE>DO</CODE> statement that specify the label defined for the
<CODE>END DO</CODE> statement.

This kind of <CODE>END DO</CODE> statement is merely a synonym for
<CODE>CONTINUE</CODE>, except it is permitted only when the statement
is labeled and a target of one or more labeled <CODE>DO</CODE> loops.

It is expected that this use of <CODE>END DO</CODE> will be removed from
the GNU Fortran language in the future, though it is likely that
it will long be supported by <CODE>g77</CODE> as a dialect form.
</UL>



<H3><A NAME="SEC64" HREF="g77_toc.html#TOC64">Construct Names</A></H3>
<P>
<A NAME="IDX734"></A>

</P>
<P>
The GNU Fortran language supports construct names as defined
by the Fortran 90 standard.
These names are local to the program unit and are defined
as follows:

</P>

<PRE>
<VAR>construct-name</VAR>: <VAR>block-statement</VAR>
</PRE>

<P>
Here, <VAR>construct-name</VAR> is the construct name itself;
its definition is connoted by the single colon (<SAMP>`:'</SAMP>); and
<VAR>block-statement</VAR> is an <CODE>IF</CODE>, <CODE>DO</CODE>,
or <CODE>SELECT CASE</CODE> statement that begins a block.

</P>
<P>
A block that is given a construct name must also specify the
same construct name in its termination statement:

</P>

<PRE>
END <VAR>block</VAR> <VAR>construct-name</VAR>
</PRE>

<P>
Here, <VAR>block</VAR> must be <CODE>IF</CODE>, <CODE>DO</CODE>, or <CODE>SELECT</CODE>,
as appropriate.

</P>


<H3><A NAME="SEC65" HREF="g77_toc.html#TOC65">The <CODE>CYCLE</CODE> and <CODE>EXIT</CODE> Statements</A></H3>

<P>
<A NAME="IDX735"></A>
<A NAME="IDX736"></A>
<A NAME="IDX737"></A>
<A NAME="IDX738"></A>
The <CODE>CYCLE</CODE> and <CODE>EXIT</CODE> statements specify that
the remaining statements in the current iteration of a
particular active (enclosing) <CODE>DO</CODE> loop are to be skipped.

</P>
<P>
<CODE>CYCLE</CODE> specifies that these statements are skipped,
but the <CODE>END DO</CODE> statement that marks the end of the
<CODE>DO</CODE> loop be executed--that is, the next iteration,
if any, is to be started.
If the statement marking the end of the <CODE>DO</CODE> loop is
not <CODE>END DO</CODE>---in other words, if the loop is not
a block <CODE>DO</CODE>---the <CODE>CYCLE</CODE> statement does not
execute that statement, but does start the next iteration (if any).

</P>
<P>
<CODE>EXIT</CODE> specifies that the loop specified by the
<CODE>DO</CODE> construct is terminated.

</P>
<P>
The <CODE>DO</CODE> loop affected by <CODE>CYCLE</CODE> and <CODE>EXIT</CODE>
is the innermost enclosing <CODE>DO</CODE> loop when the following
forms are used:

</P>

<PRE>
CYCLE
EXIT
</PRE>

<P>
Otherwise, the following forms specify the construct name
of the pertinent <CODE>DO</CODE> loop:

</P>

<PRE>
CYCLE <VAR>construct-name</VAR>
EXIT <VAR>construct-name</VAR>
</PRE>

<P>
<CODE>CYCLE</CODE> and <CODE>EXIT</CODE> can be viewed as glorified <CODE>GO TO</CODE>
statements.
However, they cannot be easily thought of as <CODE>GO TO</CODE> statements
in obscure cases involving FORTRAN 77 loops.
For example:

</P>

<PRE>
      DO 10 I = 1, 5
      DO 10 J = 1, 5
         IF (J .EQ. 5) EXIT
      DO 10 K = 1, 5
         IF (K .EQ. 3) CYCLE
10    PRINT *, 'I=', I, ' J=', J, ' K=', K
20    CONTINUE
</PRE>

<P>
In particular, neither the <CODE>EXIT</CODE> nor <CODE>CYCLE</CODE> statements
above are equivalent to a <CODE>GO TO</CODE> statement to either label
<SAMP>`10'</SAMP> or <SAMP>`20'</SAMP>.

</P>
<P>
To understand the effect of <CODE>CYCLE</CODE> and <CODE>EXIT</CODE> in the
above fragment, it is helpful to first translate it to its equivalent
using only block <CODE>DO</CODE> loops:

</P>

<PRE>
      DO I = 1, 5
         DO J = 1, 5
            IF (J .EQ. 5) EXIT
            DO K = 1, 5
               IF (K .EQ. 3) CYCLE
10             PRINT *, 'I=', I, ' J=', J, ' K=', K
            END DO
         END DO
      END DO
20    CONTINUE
</PRE>

<P>
Adding new labels allows translation of <CODE>CYCLE</CODE> and <CODE>EXIT</CODE>
to <CODE>GO TO</CODE> so they may be more easily understood by programmers
accustomed to FORTRAN coding:

</P>

<PRE>
      DO I = 1, 5
         DO J = 1, 5
            IF (J .EQ. 5) GOTO 18
            DO K = 1, 5
               IF (K .EQ. 3) GO TO 12
10             PRINT *, 'I=', I, ' J=', J, ' K=', K
12          END DO
         END DO
18    END DO
20    CONTINUE
</PRE>

<P>
Thus, the <CODE>CYCLE</CODE> statement in the innermost loop skips over
the <CODE>PRINT</CODE> statement as it begins the next iteration of the
loop, while the <CODE>EXIT</CODE> statement in the middle loop ends that
loop but <EM>not</EM> the outermost loop.

</P>


<H2><A NAME="SEC66" HREF="g77_toc.html#TOC66">Functions and Subroutines</A></H2>

<P>
(The following information augments or overrides the information in
Chapter 15 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 15 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>

<UL>
<LI><A HREF="g77_12.html#SEC67">%VAL()</A>
<LI><A HREF="g77_12.html#SEC68">%REF()</A>
<LI><A HREF="g77_12.html#SEC69">%DESCR()</A>
<LI><A HREF="g77_12.html#SEC70">Generics and Specifics</A>
<LI><A HREF="g77_12.html#SEC71">REAL() and AIMAG() of Complex</A>
<LI><A HREF="g77_12.html#SEC72">CMPLX() of DOUBLE PRECISION</A>
<LI><A HREF="g77_12.html#SEC73">MIL-STD 1753</A>
<LI><A HREF="g77_12.html#SEC74">f77/f2c Intrinsics</A>
<LI><A HREF="g77_12.html#SEC75">Table of Intrinsic Functions</A>
</UL>



<H3><A NAME="SEC67" HREF="g77_toc.html#TOC67">The <CODE>%VAL()</CODE> Construct</A></H3>
<P>
<A NAME="IDX739"></A>

</P>

<PRE>
%VAL(<VAR>arg</VAR>)
</PRE>

<P>
The <CODE>%VAL()</CODE> construct specifies that an argument,
<VAR>arg</VAR>, is to be passed by value, instead of by reference
or descriptor.

</P>
<P>
<CODE>%VAL()</CODE> is restricted to actual arguments in
invocations of external procedures.

</P>
<P>
Use of <CODE>%VAL()</CODE> is recommended only for code that
is accessing facilities outside of GNU Fortran, such as
operating system or windowing facilities.
It is best to constrain such uses to isolated portions of
a program--portions the deal specifically and exclusively
with low-level, system-dependent facilities.
Such portions might well provide a portable interface for
use by the program as a whole, but are themselves not
portable, and should be thoroughly tested each time they
are rebuilt using a new compiler or version of a compiler.

</P>
<P>
<EM>Implementation Note:</EM> Currently, <CODE>g77</CODE> passes
all arguments either by reference or by descriptor.

</P>
<P>
Thus, use of <CODE>%VAL()</CODE> tends to be restricted to cases
where the called procedure is written in a language other
than Fortran that supports call-by-value semantics.
(C is an example of such a language.)

</P>
<P>
See section <A HREF="g77_18.html#SEC552">Procedures (SUBROUTINE and FUNCTION)</A>,
for detailed information on
how this particular version of <CODE>g77</CODE> passes arguments
to procedures.

</P>


<H3><A NAME="SEC68" HREF="g77_toc.html#TOC68">The <CODE>%REF()</CODE> Construct</A></H3>
<P>
<A NAME="IDX740"></A>

</P>

<PRE>
%REF(<VAR>arg</VAR>)
</PRE>

<P>
The <CODE>%REF()</CODE> construct specifies that an argument,
<VAR>arg</VAR>, is to be passed by reference, instead of by
value or descriptor.

</P>
<P>
<CODE>%REF()</CODE> is restricted to actual arguments in
invocations of external procedures.

</P>
<P>
Use of <CODE>%REF()</CODE> is recommended only for code that
is accessing facilities outside of GNU Fortran, such as
operating system or windowing facilities.
It is best to constrain such uses to isolated portions of
a program--portions the deal specifically and exclusively
with low-level, system-dependent facilities.
Such portions might well provide a portable interface for
use by the program as a whole, but are themselves not
portable, and should be thoroughly tested each time they
are rebuilt using a new compiler or version of a compiler.

</P>
<P>
Do not depend on <CODE>%REF()</CODE> supplying a pointer to the
procedure being invoked.
While that is a likely implementation choice, other
implementation choices are available that preserve Fortran
pass-by-reference semantics without passing a pointer to
the argument, <VAR>arg</VAR>.
(For example, a copy-in/copy-out implementation.)

</P>
<P>
<EM>Implementation Note:</EM> Currently, <CODE>g77</CODE> passes
all arguments
(other than variables and arrays of type <CODE>CHARACTER</CODE>)
by reference.
Future versions of, or dialects supported by, <CODE>g77</CODE> might
not pass <CODE>CHARACTER</CODE> functions by reference.

</P>
<P>
Thus, use of <CODE>%REF()</CODE> tends to be restricted to cases
where <VAR>arg</VAR> is type <CODE>CHARACTER</CODE> but the called
procedure accesses it via a means other than the method
used for Fortran <CODE>CHARACTER</CODE> arguments.

</P>
<P>
See section <A HREF="g77_18.html#SEC552">Procedures (SUBROUTINE and FUNCTION)</A>, for detailed information on
how this particular version of <CODE>g77</CODE> passes arguments
to procedures.

</P>


<H3><A NAME="SEC69" HREF="g77_toc.html#TOC69">The <CODE>%DESCR()</CODE> Construct</A></H3>
<P>
<A NAME="IDX741"></A>

</P>

<PRE>
%DESCR(<VAR>arg</VAR>)
</PRE>

<P>
The <CODE>%DESCR()</CODE> construct specifies that an argument,
<VAR>arg</VAR>, is to be passed by descriptor, instead of by
value or reference.

</P>
<P>
<CODE>%DESCR()</CODE> is restricted to actual arguments in
invocations of external procedures.

</P>
<P>
Use of <CODE>%DESCR()</CODE> is recommended only for code that
is accessing facilities outside of GNU Fortran, such as
operating system or windowing facilities.
It is best to constrain such uses to isolated portions of
a program--portions the deal specifically and exclusively
with low-level, system-dependent facilities.
Such portions might well provide a portable interface for
use by the program as a whole, but are themselves not
portable, and should be thoroughly tested each time they
are rebuilt using a new compiler or version of a compiler.

</P>
<P>
Do not depend on <CODE>%DESCR()</CODE> supplying a pointer
and/or a length passed by value
to the procedure being invoked.
While that is a likely implementation choice, other
implementation choices are available that preserve the
pass-by-reference semantics without passing a pointer to
the argument, <VAR>arg</VAR>.
(For example, a copy-in/copy-out implementation.)
And, future versions of <CODE>g77</CODE> might change the
way descriptors are implemented, such as passing a
single argument pointing to a record containing the
pointer/length information instead of passing that same
information via two arguments as it currently does.

</P>
<P>
<EM>Implementation Note:</EM> Currently, <CODE>g77</CODE> passes
all variables and arrays of type <CODE>CHARACTER</CODE>
by descriptor.
Future versions of, or dialects supported by, <CODE>g77</CODE> might
pass <CODE>CHARACTER</CODE> functions by descriptor as well.

</P>
<P>
Thus, use of <CODE>%DESCR()</CODE> tends to be restricted to cases
where <VAR>arg</VAR> is not type <CODE>CHARACTER</CODE> but the called
procedure accesses it via a means similar to the method
used for Fortran <CODE>CHARACTER</CODE> arguments.

</P>
<P>
See section <A HREF="g77_18.html#SEC552">Procedures (SUBROUTINE and FUNCTION)</A>, for detailed information on
how this particular version of <CODE>g77</CODE> passes arguments
to procedures.

</P>


<H3><A NAME="SEC70" HREF="g77_toc.html#TOC70">Generics and Specifics</A></H3>
<P>
<A NAME="IDX742"></A>
<A NAME="IDX743"></A>

</P>
<P>
The ANSI FORTRAN 77 language defines generic and specific
intrinsics.
In short, the distinctions are:

</P>

<UL>
<LI>

<EM>Specific</EM> intrinsics have
specific types for their arguments and a specific return
type.

<LI>

<EM>Generic</EM> intrinsics are treated,
on a case-by-case basis in the program's source code,
as one of several possible specific intrinsics.

Typically, a generic intrinsic has a return type that
is determined by the type of one or more of its arguments.
</UL>

<P>
The GNU Fortran language generalizes these concepts somewhat,
especially by providing intrinsic subroutines and generic
intrinsics that are treated as either a specific intrinsic subroutine
or a specific intrinsic function (e.g. <CODE>SECOND</CODE>).

</P>
<P>
However, GNU Fortran avoids generalizing this concept to
the point where existing code would be accepted as meaning
something possibly different than what was intended.

</P>
<P>
For example, <CODE>ABS</CODE> is a generic intrinsic, so all working
code written using <CODE>ABS</CODE> of an <CODE>INTEGER</CODE> argument
expects an <CODE>INTEGER</CODE> return value.
Similarly, all such code expects that <CODE>ABS</CODE> of an <CODE>INTEGER*2</CODE>
argument returns an <CODE>INTEGER*2</CODE> return value.

</P>
<P>
Yet, <CODE>IABS</CODE> is a <EM>specific</EM> intrinsic that accepts only
an <CODE>INTEGER(KIND=1)</CODE> argument.
Code that passes something other than an <CODE>INTEGER(KIND=1)</CODE>
argument to <CODE>IABS</CODE> is not valid GNU Fortran code, because
it is not clear what the author intended.

</P>
<P>
For example, if <SAMP>`J'</SAMP> is <CODE>INTEGER(KIND=6)</CODE>, <SAMP>`IABS(J)'</SAMP>
is not defined by the GNU Fortran language, because the programmer
might have used that construct to mean any of the following, subtly
different, things:

</P>

<UL>
<LI>

Convert <SAMP>`J'</SAMP> to <CODE>INTEGER(KIND=1)</CODE> first
(as if <SAMP>`IABS(INT(J))'</SAMP> had been written).

<LI>

Convert the result of the intrinsic to <CODE>INTEGER(KIND=1)</CODE>
(as if <SAMP>`INT(ABS(J))'</SAMP> had been written).

<LI>

No conversion (as if <SAMP>`ABS(J)'</SAMP> had been written).
</UL>

<P>
The distinctions matter especially when types and values wider than
<CODE>INTEGER(KIND=1)</CODE> (such as <CODE>INTEGER(KIND=2)</CODE>), or when
operations performing more "arithmetic" than absolute-value, are involved.

</P>
<P>
The following sample program is not a valid GNU Fortran program, but
might be accepted by other compilers.
If so, the output is likely to be revealing in terms of how a given
compiler treats intrinsics (that normally are specific) when they
are given arguments that do not conform to their stated requirements:

</P>
<P>
<A NAME="IDX744"></A>

<PRE>
      PROGRAM JCB002
C Version 1:
C Modified 1999-02-15 (Burley) to delete my email address.
C Modified 1997-05-21 (Burley) to accommodate compilers that implement
C INT(I1-I2) as INT(I1)-INT(I2) given INTEGER*2 I1,I2.
C
C Version 0:
C Written by James Craig Burley 1997-02-20.
C
C Purpose:
C Determine how compilers handle non-standard IDIM
C on INTEGER*2 operands, which presumably can be
C extrapolated into understanding how the compiler
C generally treats specific intrinsics that are passed
C arguments not of the correct types.
C
C If your compiler implements INTEGER*2 and INTEGER
C as the same type, change all INTEGER*2 below to
C INTEGER*1.
C
      INTEGER*2 I0, I4
      INTEGER I1, I2, I3
      INTEGER*2 ISMALL, ILARGE
      INTEGER*2 ITOOLG, ITWO
      INTEGER*2 ITMP
      LOGICAL L2, L3, L4
C
C Find smallest INTEGER*2 number.
C
      ISMALL=0
 10   I0 = ISMALL-1
      IF ((I0 .GE. ISMALL) .OR. (I0+1 .NE. ISMALL)) GOTO 20
      ISMALL = I0
      GOTO 10
 20   CONTINUE
C
C Find largest INTEGER*2 number.
C
      ILARGE=0
 30   I0 = ILARGE+1
      IF ((I0 .LE. ILARGE) .OR. (I0-1 .NE. ILARGE)) GOTO 40
      ILARGE = I0
      GOTO 30
 40   CONTINUE
C
C Multiplying by two adds stress to the situation.
C
      ITWO = 2
C
C Need a number that, added to -2, is too wide to fit in I*2.
C
      ITOOLG = ISMALL
C
C Use IDIM the straightforward way.
C
      I1 = IDIM (ILARGE, ISMALL) * ITWO + ITOOLG
C
C Calculate result for first interpretation.
C
      I2 = (INT (ILARGE) - INT (ISMALL)) * ITWO + ITOOLG
C
C Calculate result for second interpretation.
C
      ITMP = ILARGE - ISMALL
      I3 = (INT (ITMP)) * ITWO + ITOOLG
C
C Calculate result for third interpretation.
C
      I4 = (ILARGE - ISMALL) * ITWO + ITOOLG
C
C Print results.
C
      PRINT *, 'ILARGE=', ILARGE
      PRINT *, 'ITWO=', ITWO
      PRINT *, 'ITOOLG=', ITOOLG
      PRINT *, 'ISMALL=', ISMALL
      PRINT *, 'I1=', I1
      PRINT *, 'I2=', I2
      PRINT *, 'I3=', I3
      PRINT *, 'I4=', I4
      PRINT *
      L2 = (I1 .EQ. I2)
      L3 = (I1 .EQ. I3)
      L4 = (I1 .EQ. I4)
      IF (L2 .AND. .NOT.L3 .AND. .NOT.L4) THEN
         PRINT *, 'Interp 1: IDIM(I*2,I*2) =&#62; IDIM(INT(I*2),INT(I*2))'
         STOP
      END IF
      IF (L3 .AND. .NOT.L2 .AND. .NOT.L4) THEN
         PRINT *, 'Interp 2: IDIM(I*2,I*2) =&#62; INT(DIM(I*2,I*2))'
         STOP
      END IF
      IF (L4 .AND. .NOT.L2 .AND. .NOT.L3) THEN
         PRINT *, 'Interp 3: IDIM(I*2,I*2) =&#62; DIM(I*2,I*2)'
         STOP
      END IF
      PRINT *, 'Results need careful analysis.'
      END
</PRE>

<P>
No future version of the GNU Fortran language
will likely permit specific intrinsic invocations with wrong-typed
arguments (such as <CODE>IDIM</CODE> in the above example), since
it has been determined that disagreements exist among
many production compilers on the interpretation of
such invocations.
These disagreements strongly suggest that Fortran programmers,
and certainly existing Fortran programs, disagree about the
meaning of such invocations.

</P>
<P>
The first version of <CODE>JCB002</CODE> didn't accommodate some compilers'
treatment of <SAMP>`INT(I1-I2)'</SAMP> where <SAMP>`I1'</SAMP> and <SAMP>`I2'</SAMP> are
<CODE>INTEGER*2</CODE>.
In such a case, these compilers apparently convert both
operands to <CODE>INTEGER*4</CODE> and then do an <CODE>INTEGER*4</CODE> subtraction,
instead of doing an <CODE>INTEGER*2</CODE> subtraction on the
original values in <SAMP>`I1'</SAMP> and <SAMP>`I2'</SAMP>.

</P>
<P>
However, the results of the careful analyses done on the outputs
of programs compiled by these various compilers show that they
all implement either <SAMP>`Interp 1'</SAMP> or <SAMP>`Interp 2'</SAMP> above.

</P>
<P>
Specifically, it is believed that the new version of <CODE>JCB002</CODE>
above will confirm that:

</P>

<UL>
<LI>

Digital Semiconductor ("DEC") Alpha OSF/1, HP-UX 10.0.1, AIX 3.2.5
<CODE>f77</CODE> compilers all implement <SAMP>`Interp 1'</SAMP>.

<LI>

IRIX 5.3 <CODE>f77</CODE> compiler implements <SAMP>`Interp 2'</SAMP>.

<LI>

Solaris 2.5, SunOS 4.1.3, DECstation ULTRIX 4.3,
and IRIX 6.1 <CODE>f77</CODE> compilers all implement <SAMP>`Interp 3'</SAMP>.
</UL>

<P>
If you get different results than the above for the stated
compilers, or have results for other compilers that might be
worth adding to the above list, please let us know the details
(compiler product, version, machine, results, and so on).

</P>


<H3><A NAME="SEC71" HREF="g77_toc.html#TOC71"><CODE>REAL()</CODE> and <CODE>AIMAG()</CODE> of Complex</A></H3>
<P>
<A NAME="IDX745"></A>
<A NAME="IDX746"></A>
<A NAME="IDX747"></A>
<A NAME="IDX748"></A>

</P>
<P>
The GNU Fortran language disallows <CODE>REAL(<VAR>expr</VAR>)</CODE>
and <CODE>AIMAG(<VAR>expr</VAR>)</CODE>,
where <VAR>expr</VAR> is any <CODE>COMPLEX</CODE> type other than <CODE>COMPLEX(KIND=1)</CODE>,
except when they are used in the following way:

</P>

<PRE>
REAL(REAL(<VAR>expr</VAR>))
REAL(AIMAG(<VAR>expr</VAR>))
</PRE>

<P>
The above forms explicitly specify that the desired effect
is to convert the real or imaginary part of <VAR>expr</VAR>, which might
be some <CODE>REAL</CODE> type other than <CODE>REAL(KIND=1)</CODE>,
to type <CODE>REAL(KIND=1)</CODE>,
and have that serve as the value of the expression.

</P>
<P>
The GNU Fortran language offers clearly named intrinsics to extract the
real and imaginary parts of a complex entity without any
conversion:

</P>

<PRE>
REALPART(<VAR>expr</VAR>)
IMAGPART(<VAR>expr</VAR>)
</PRE>

<P>
To express the above using typical extended FORTRAN 77,
use the following constructs
(when <VAR>expr</VAR> is <CODE>COMPLEX(KIND=2)</CODE>):

</P>

<PRE>
DBLE(<VAR>expr</VAR>)
DIMAG(<VAR>expr</VAR>)
</PRE>

<P>
The FORTRAN 77 language offers no way
to explicitly specify the real and imaginary parts of a complex expression of
arbitrary type, apparently as a result of requiring support for
only one <CODE>COMPLEX</CODE> type (<CODE>COMPLEX(KIND=1)</CODE>).
The concepts of converting an expression to type <CODE>REAL(KIND=1)</CODE> and
of extracting the real part of a complex expression were
thus "smooshed" by FORTRAN 77 into a single intrinsic, since
they happened to have the exact same effect in that language
(due to having only one <CODE>COMPLEX</CODE> type).

</P>
<P>
<EM>Note:</EM> When <SAMP>`-ff90'</SAMP> is in effect,
<CODE>g77</CODE> treats <SAMP>`REAL(<VAR>expr</VAR>)'</SAMP>, where <VAR>expr</VAR> is of
type <CODE>COMPLEX</CODE>, as <SAMP>`REALPART(<VAR>expr</VAR>)'</SAMP>,
whereas with <SAMP>`-fugly-complex -fno-f90'</SAMP> in effect, it is
treated as <SAMP>`REAL(REALPART(<VAR>expr</VAR>))'</SAMP>.

</P>
<P>
See section <A HREF="g77_13.html#SEC363">Ugly Complex Part Extraction</A>, for more information.

</P>


<H3><A NAME="SEC72" HREF="g77_toc.html#TOC72"><CODE>CMPLX()</CODE> of <CODE>DOUBLE PRECISION</CODE></A></H3>
<P>
<A NAME="IDX749"></A>
<A NAME="IDX750"></A>

</P>
<P>
In accordance with Fortran 90 and at least some (perhaps all)
other compilers, the GNU Fortran language defines <CODE>CMPLX()</CODE>
as always returning a result that is type <CODE>COMPLEX(KIND=1)</CODE>.

</P>
<P>
This means <SAMP>`CMPLX(D1,D2)'</SAMP>, where <SAMP>`D1'</SAMP> and <SAMP>`D2'</SAMP>
are <CODE>REAL(KIND=2)</CODE> (<CODE>DOUBLE PRECISION</CODE>), is treated as:

</P>

<PRE>
CMPLX(SNGL(D1), SNGL(D2))
</PRE>

<P>
(It was necessary for Fortran 90 to specify this behavior
for <CODE>DOUBLE PRECISION</CODE> arguments, since that is
the behavior mandated by FORTRAN 77.)

</P>
<P>
The GNU Fortran language also provides the <CODE>DCMPLX()</CODE> intrinsic,
which is provided by some FORTRAN 77 compilers to construct
a <CODE>DOUBLE COMPLEX</CODE> entity from of <CODE>DOUBLE PRECISION</CODE>
operands.
However, this solution does not scale well when more <CODE>COMPLEX</CODE> types
(having various precisions and ranges) are offered by Fortran implementations.

</P>
<P>
Fortran 90 extends the <CODE>CMPLX()</CODE> intrinsic by adding
an extra argument used to specify the desired kind of complex
result.
However, this solution is somewhat awkward to use, and
<CODE>g77</CODE> currently does not support it.

</P>
<P>
The GNU Fortran language provides a simple way to build a complex
value out of two numbers, with the precise type of the value
determined by the types of the two numbers (via the usual
type-promotion mechanism):

</P>

<PRE>
COMPLEX(<VAR>real</VAR>, <VAR>imag</VAR>)
</PRE>

<P>
When <VAR>real</VAR> and <VAR>imag</VAR> are the same <CODE>REAL</CODE> types, <CODE>COMPLEX()</CODE>
performs no conversion other than to put them together to form a
complex result of the same (complex version of real) type.

</P>
<P>
See section <A HREF="g77_12.html#SEC119">Complex Intrinsic</A>, for more information.

</P>


<H3><A NAME="SEC73" HREF="g77_toc.html#TOC73">MIL-STD 1753 Support</A></H3>
<P>
<A NAME="IDX751"></A>

</P>
<P>
The GNU Fortran language includes the MIL-STD 1753 intrinsics
<CODE>BTEST</CODE>, <CODE>IAND</CODE>, <CODE>IBCLR</CODE>, <CODE>IBITS</CODE>,
<CODE>IBSET</CODE>, <CODE>IEOR</CODE>, <CODE>IOR</CODE>, <CODE>ISHFT</CODE>,
<CODE>ISHFTC</CODE>, <CODE>MVBITS</CODE>, and <CODE>NOT</CODE>.

</P>


<H3><A NAME="SEC74" HREF="g77_toc.html#TOC74"><CODE>f77</CODE>/<CODE>f2c</CODE> Intrinsics</A></H3>

<P>
The bit-manipulation intrinsics supported by traditional
<CODE>f77</CODE> and by <CODE>f2c</CODE> are available in the GNU Fortran language.
These include <CODE>AND</CODE>, <CODE>LSHIFT</CODE>, <CODE>OR</CODE>, <CODE>RSHIFT</CODE>,
and <CODE>XOR</CODE>.

</P>
<P>
Also supported are the intrinsics <CODE>CDABS</CODE>,
<CODE>CDCOS</CODE>, <CODE>CDEXP</CODE>, <CODE>CDLOG</CODE>, <CODE>CDSIN</CODE>,
<CODE>CDSQRT</CODE>, <CODE>DCMPLX</CODE>, <CODE>DCONJG</CODE>, <CODE>DFLOAT</CODE>,
<CODE>DIMAG</CODE>, <CODE>DREAL</CODE>, and <CODE>IMAG</CODE>,
<CODE>ZABS</CODE>, <CODE>ZCOS</CODE>, <CODE>ZEXP</CODE>, <CODE>ZLOG</CODE>, <CODE>ZSIN</CODE>,
and <CODE>ZSQRT</CODE>.

</P>


<H3><A NAME="SEC75" HREF="g77_toc.html#TOC75">Table of Intrinsic Functions</A></H3>
<P>
<A NAME="IDX752"></A>
<A NAME="IDX753"></A>

</P>
<P>
(Corresponds to Section 15.10 of ANSI X3.9-1978 FORTRAN 77.)

</P>
<P>
The GNU Fortran language adds various functions, subroutines, types,
and arguments to the set of intrinsic functions in ANSI FORTRAN 77.
The complete set of intrinsics supported by the GNU Fortran language
is described below.

</P>
<P>
Note that a name is not treated as that of an intrinsic if it is
specified in an <CODE>EXTERNAL</CODE> statement in the same program unit;
if a command-line option is used to disable the groups to which
the intrinsic belongs; or if the intrinsic is not named in an
<CODE>INTRINSIC</CODE> statement and a command-line option is used to
hide the groups to which the intrinsic belongs.

</P>
<P>
So, it is recommended that any reference in a program unit to
an intrinsic procedure that is not a standard FORTRAN 77
intrinsic be accompanied by an appropriate <CODE>INTRINSIC</CODE>
statement in that program unit.
This sort of defensive programming makes it more
likely that an implementation will issue a diagnostic rather
than generate incorrect code for such a reference.

</P>
<P>
The terminology used below is based on that of the Fortran 90
standard, so that the text may be more concise and accurate:

</P>

<UL>
<LI>

<CODE>OPTIONAL</CODE> means the argument may be omitted.

<LI>

<SAMP>`A-1, A-2, ..., A-n'</SAMP> means more than one argument
(generally named <SAMP>`A'</SAMP>) may be specified.

<LI>

<SAMP>`scalar'</SAMP> means the argument must not be an array (must
be a variable or array element, or perhaps a constant if expressions
are permitted).

<LI>

<SAMP>`DIMENSION(4)'</SAMP> means the argument must be an array having 4 elements.

<LI>

<CODE>INTENT(IN)</CODE> means the argument must be an expression
(such as a constant or a variable that is defined upon invocation
of the intrinsic).

<LI>

<CODE>INTENT(OUT)</CODE> means the argument must be definable by the
invocation of the intrinsic (that is, must not be a constant nor
an expression involving operators other than array reference and
substring reference).

<LI>

<CODE>INTENT(INOUT)</CODE> means the argument must be defined prior to,
and definable by, invocation of the intrinsic (a combination of
the requirements of <CODE>INTENT(IN)</CODE> and <CODE>INTENT(OUT)</CODE>.

<LI>

See section <A HREF="g77_12.html#SEC52">Kind Notation</A>, for an explanation of <CODE>KIND</CODE>.
</UL>


<UL>
<LI><A HREF="g77_12.html#SEC76">Abort Intrinsic</A>: Abort the program.
<LI><A HREF="g77_12.html#SEC77">Abs Intrinsic</A>: Absolute value.
<LI><A HREF="g77_12.html#SEC78">Access Intrinsic</A>: Check file accessibility.
<LI><A HREF="g77_12.html#SEC79">AChar Intrinsic</A>: ASCII character from code.
<LI><A HREF="g77_12.html#SEC80">ACos Intrinsic</A>: Arc cosine.
<LI><A HREF="g77_12.html#SEC81">AdjustL Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC82">AdjustR Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC83">AImag Intrinsic</A>: Convert/extract imaginary part of complex.
<LI><A HREF="g77_12.html#SEC84">AInt Intrinsic</A>: Truncate to whole number.
<LI><A HREF="g77_12.html#SEC85">Alarm Intrinsic</A>: Execute a routine after a given delay.
<LI><A HREF="g77_12.html#SEC86">All Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC87">Allocated Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC88">ALog Intrinsic</A>: Natural logarithm (archaic).
<LI><A HREF="g77_12.html#SEC89">ALog10 Intrinsic</A>: Common logarithm (archaic).
<LI><A HREF="g77_12.html#SEC90">AMax0 Intrinsic</A>: Maximum value (archaic).
<LI><A HREF="g77_12.html#SEC91">AMax1 Intrinsic</A>: Maximum value (archaic).
<LI><A HREF="g77_12.html#SEC92">AMin0 Intrinsic</A>: Minimum value (archaic).
<LI><A HREF="g77_12.html#SEC93">AMin1 Intrinsic</A>: Minimum value (archaic).
<LI><A HREF="g77_12.html#SEC94">AMod Intrinsic</A>: Remainder (archaic).
<LI><A HREF="g77_12.html#SEC95">And Intrinsic</A>: Boolean AND.
<LI><A HREF="g77_12.html#SEC96">ANInt Intrinsic</A>: Round to nearest whole number.
<LI><A HREF="g77_12.html#SEC97">Any Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC98">ASin Intrinsic</A>: Arc sine.
<LI><A HREF="g77_12.html#SEC99">Associated Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC100">ATan Intrinsic</A>: Arc tangent.
<LI><A HREF="g77_12.html#SEC101">ATan2 Intrinsic</A>: Arc tangent.
<LI><A HREF="g77_12.html#SEC102">BesJ0 Intrinsic</A>: Bessel function.
<LI><A HREF="g77_12.html#SEC103">BesJ1 Intrinsic</A>: Bessel function.
<LI><A HREF="g77_12.html#SEC104">BesJN Intrinsic</A>: Bessel function.
<LI><A HREF="g77_12.html#SEC105">BesY0 Intrinsic</A>: Bessel function.
<LI><A HREF="g77_12.html#SEC106">BesY1 Intrinsic</A>: Bessel function.
<LI><A HREF="g77_12.html#SEC107">BesYN Intrinsic</A>: Bessel function.
<LI><A HREF="g77_12.html#SEC108">Bit_Size Intrinsic</A>: Number of bits in argument's type.
<LI><A HREF="g77_12.html#SEC109">BTest Intrinsic</A>: Test bit.
<LI><A HREF="g77_12.html#SEC110">CAbs Intrinsic</A>: Absolute value (archaic).
<LI><A HREF="g77_12.html#SEC111">CCos Intrinsic</A>: Cosine (archaic).
<LI><A HREF="g77_12.html#SEC112">Ceiling Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC113">CExp Intrinsic</A>: Exponential (archaic).
<LI><A HREF="g77_12.html#SEC114">Char Intrinsic</A>: Character from code.
<LI><A HREF="g77_12.html#SEC115">ChDir Intrinsic (subroutine)</A>: Change directory.
<LI><A HREF="g77_12.html#SEC116">ChMod Intrinsic (subroutine)</A>: Change file modes.
<LI><A HREF="g77_12.html#SEC117">CLog Intrinsic</A>: Natural logarithm (archaic).
<LI><A HREF="g77_12.html#SEC118">Cmplx Intrinsic</A>: Construct <CODE>COMPLEX(KIND=1)</CODE> value.
<LI><A HREF="g77_12.html#SEC119">Complex Intrinsic</A>: Build complex value from real and
                         imaginary parts.
<LI><A HREF="g77_12.html#SEC120">Conjg Intrinsic</A>: Complex conjugate.
<LI><A HREF="g77_12.html#SEC121">Cos Intrinsic</A>: Cosine.
<LI><A HREF="g77_12.html#SEC122">CosH Intrinsic</A>: Hyperbolic cosine.
<LI><A HREF="g77_12.html#SEC123">Count Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC124">CPU_Time Intrinsic</A>: Get current CPU time.
<LI><A HREF="g77_12.html#SEC125">CShift Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC126">CSin Intrinsic</A>: Sine (archaic).
<LI><A HREF="g77_12.html#SEC127">CSqRt Intrinsic</A>: Square root (archaic).
<LI><A HREF="g77_12.html#SEC128">CTime Intrinsic (subroutine)</A>: Convert time to Day Mon dd hh:mm:ss yyyy.
<LI><A HREF="g77_12.html#SEC129">CTime Intrinsic (function)</A>: Convert time to Day Mon dd hh:mm:ss yyyy.
<LI><A HREF="g77_12.html#SEC130">DAbs Intrinsic</A>: Absolute value (archaic).
<LI><A HREF="g77_12.html#SEC131">DACos Intrinsic</A>: Arc cosine (archaic).
<LI><A HREF="g77_12.html#SEC132">DASin Intrinsic</A>: Arc sine (archaic).
<LI><A HREF="g77_12.html#SEC133">DATan Intrinsic</A>: Arc tangent (archaic).
<LI><A HREF="g77_12.html#SEC134">DATan2 Intrinsic</A>: Arc tangent (archaic).
<LI><A HREF="g77_12.html#SEC135">Date_and_Time Intrinsic</A>: Get the current date and time.
<LI><A HREF="g77_12.html#SEC136">DbesJ0 Intrinsic</A>: Bessel function (archaic).
<LI><A HREF="g77_12.html#SEC137">DbesJ1 Intrinsic</A>: Bessel function (archaic).
<LI><A HREF="g77_12.html#SEC138">DbesJN Intrinsic</A>: Bessel function (archaic).
<LI><A HREF="g77_12.html#SEC139">DbesY0 Intrinsic</A>: Bessel function (archaic).
<LI><A HREF="g77_12.html#SEC140">DbesY1 Intrinsic</A>: Bessel function (archaic).
<LI><A HREF="g77_12.html#SEC141">DbesYN Intrinsic</A>: Bessel function (archaic).
<LI><A HREF="g77_12.html#SEC142">Dble Intrinsic</A>: Convert to double precision.
<LI><A HREF="g77_12.html#SEC143">DCos Intrinsic</A>: Cosine (archaic).
<LI><A HREF="g77_12.html#SEC144">DCosH Intrinsic</A>: Hyperbolic cosine (archaic).
<LI><A HREF="g77_12.html#SEC145">DDiM Intrinsic</A>: Difference magnitude (archaic).
<LI><A HREF="g77_12.html#SEC146">DErF Intrinsic</A>: Error function (archaic).
<LI><A HREF="g77_12.html#SEC147">DErFC Intrinsic</A>: Complementary error function (archaic).
<LI><A HREF="g77_12.html#SEC148">DExp Intrinsic</A>: Exponential (archaic).
<LI><A HREF="g77_12.html#SEC149">Digits Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC150">DiM Intrinsic</A>: Difference magnitude (non-negative subtract).
<LI><A HREF="g77_12.html#SEC151">DInt Intrinsic</A>: Truncate to whole number (archaic).
<LI><A HREF="g77_12.html#SEC152">DLog Intrinsic</A>: Natural logarithm (archaic).
<LI><A HREF="g77_12.html#SEC153">DLog10 Intrinsic</A>: Common logarithm (archaic).
<LI><A HREF="g77_12.html#SEC154">DMax1 Intrinsic</A>: Maximum value (archaic).
<LI><A HREF="g77_12.html#SEC155">DMin1 Intrinsic</A>: Minimum value (archaic).
<LI><A HREF="g77_12.html#SEC156">DMod Intrinsic</A>: Remainder (archaic).
<LI><A HREF="g77_12.html#SEC157">DNInt Intrinsic</A>: Round to nearest whole number (archaic).
<LI><A HREF="g77_12.html#SEC158">Dot_Product Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC159">DProd Intrinsic</A>: Double-precision product.
<LI><A HREF="g77_12.html#SEC160">DSign Intrinsic</A>: Apply sign to magnitude (archaic).
<LI><A HREF="g77_12.html#SEC161">DSin Intrinsic</A>: Sine (archaic).
<LI><A HREF="g77_12.html#SEC162">DSinH Intrinsic</A>: Hyperbolic sine (archaic).
<LI><A HREF="g77_12.html#SEC163">DSqRt Intrinsic</A>: Square root (archaic).
<LI><A HREF="g77_12.html#SEC164">DTan Intrinsic</A>: Tangent (archaic).
<LI><A HREF="g77_12.html#SEC165">DTanH Intrinsic</A>: Hyperbolic tangent (archaic).
<LI><A HREF="g77_12.html#SEC166">DTime Intrinsic (subroutine)</A>: Get elapsed time since last time.
<LI><A HREF="g77_12.html#SEC167">EOShift Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC168">Epsilon Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC169">ErF Intrinsic</A>: Error function.
<LI><A HREF="g77_12.html#SEC170">ErFC Intrinsic</A>: Complementary error function.
<LI><A HREF="g77_12.html#SEC171">ETime Intrinsic (subroutine)</A>: Get elapsed time for process.
<LI><A HREF="g77_12.html#SEC172">ETime Intrinsic (function)</A>: Get elapsed time for process.
<LI><A HREF="g77_12.html#SEC173">Exit Intrinsic</A>: Terminate the program.
<LI><A HREF="g77_12.html#SEC174">Exp Intrinsic</A>: Exponential.
<LI><A HREF="g77_12.html#SEC175">Exponent Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC176">FDate Intrinsic (subroutine)</A>: Get current time as Day Mon dd hh:mm:ss yyyy.
<LI><A HREF="g77_12.html#SEC177">FDate Intrinsic (function)</A>: Get current time as Day Mon dd hh:mm:ss yyyy.
<LI><A HREF="g77_12.html#SEC178">FGet Intrinsic (subroutine)</A>: Read a character from unit 5 stream-wise.
<LI><A HREF="g77_12.html#SEC179">FGetC Intrinsic (subroutine)</A>: Read a character stream-wise.
<LI><A HREF="g77_12.html#SEC180">Float Intrinsic</A>: Conversion (archaic).
<LI><A HREF="g77_12.html#SEC181">Floor Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC182">Flush Intrinsic</A>: Flush buffered output.
<LI><A HREF="g77_12.html#SEC183">FNum Intrinsic</A>: Get file descriptor from Fortran unit number.
<LI><A HREF="g77_12.html#SEC184">FPut Intrinsic (subroutine)</A>: Write a character to unit 6 stream-wise.
<LI><A HREF="g77_12.html#SEC185">FPutC Intrinsic (subroutine)</A>: Write a character stream-wise.
<LI><A HREF="g77_12.html#SEC186">Fraction Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC187">FSeek Intrinsic</A>: Position file (low-level).
<LI><A HREF="g77_12.html#SEC188">FStat Intrinsic (subroutine)</A>: Get file information.
<LI><A HREF="g77_12.html#SEC189">FStat Intrinsic (function)</A>: Get file information.
<LI><A HREF="g77_12.html#SEC190">FTell Intrinsic (subroutine)</A>: Get file position (low-level).
<LI><A HREF="g77_12.html#SEC191">FTell Intrinsic (function)</A>: Get file position (low-level).
<LI><A HREF="g77_12.html#SEC192">GError Intrinsic</A>: Get error message for last error.
<LI><A HREF="g77_12.html#SEC193">GetArg Intrinsic</A>: Obtain command-line argument.
<LI><A HREF="g77_12.html#SEC194">GetCWD Intrinsic (subroutine)</A>: Get current working directory.
<LI><A HREF="g77_12.html#SEC195">GetCWD Intrinsic (function)</A>: Get current working directory.
<LI><A HREF="g77_12.html#SEC196">GetEnv Intrinsic</A>: Get environment variable.
<LI><A HREF="g77_12.html#SEC197">GetGId Intrinsic</A>: Get process group id.
<LI><A HREF="g77_12.html#SEC198">GetLog Intrinsic</A>: Get login name.
<LI><A HREF="g77_12.html#SEC199">GetPId Intrinsic</A>: Get process id.
<LI><A HREF="g77_12.html#SEC200">GetUId Intrinsic</A>: Get process user id.
<LI><A HREF="g77_12.html#SEC201">GMTime Intrinsic</A>: Convert time to GMT time info.
<LI><A HREF="g77_12.html#SEC202">HostNm Intrinsic (subroutine)</A>: Get host name.
<LI><A HREF="g77_12.html#SEC203">HostNm Intrinsic (function)</A>: Get host name.
<LI><A HREF="g77_12.html#SEC204">Huge Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC205">IAbs Intrinsic</A>: Absolute value (archaic).
<LI><A HREF="g77_12.html#SEC206">IAChar Intrinsic</A>: ASCII code for character.
<LI><A HREF="g77_12.html#SEC207">IAnd Intrinsic</A>: Boolean AND.
<LI><A HREF="g77_12.html#SEC208">IArgC Intrinsic</A>: Obtain count of command-line arguments.
<LI><A HREF="g77_12.html#SEC209">IBClr Intrinsic</A>: Clear a bit.
<LI><A HREF="g77_12.html#SEC210">IBits Intrinsic</A>: Extract a bit subfield of a variable.
<LI><A HREF="g77_12.html#SEC211">IBSet Intrinsic</A>: Set a bit.
<LI><A HREF="g77_12.html#SEC212">IChar Intrinsic</A>: Code for character.
<LI><A HREF="g77_12.html#SEC213">IDate Intrinsic (UNIX)</A>: Get local time info.
<LI><A HREF="g77_12.html#SEC214">IDiM Intrinsic</A>: Difference magnitude (archaic).
<LI><A HREF="g77_12.html#SEC215">IDInt Intrinsic</A>: Convert to <CODE>INTEGER</CODE> value truncated
                         to whole number (archaic).
<LI><A HREF="g77_12.html#SEC216">IDNInt Intrinsic</A>: Convert to <CODE>INTEGER</CODE> value rounded
                         to nearest whole number (archaic).
<LI><A HREF="g77_12.html#SEC217">IEOr Intrinsic</A>: Boolean XOR.
<LI><A HREF="g77_12.html#SEC218">IErrNo Intrinsic</A>: Get error number for last error.
<LI><A HREF="g77_12.html#SEC219">IFix Intrinsic</A>: Conversion (archaic).
<LI><A HREF="g77_12.html#SEC220">Imag Intrinsic</A>: Extract imaginary part of complex.
<LI><A HREF="g77_12.html#SEC221">ImagPart Intrinsic</A>: Extract imaginary part of complex.
<LI><A HREF="g77_12.html#SEC222">Index Intrinsic</A>: Locate a CHARACTER substring.
<LI><A HREF="g77_12.html#SEC223">Int Intrinsic</A>: Convert to <CODE>INTEGER</CODE> value truncated
                         to whole number.
<LI><A HREF="g77_12.html#SEC224">Int2 Intrinsic</A>: Convert to <CODE>INTEGER(KIND=6)</CODE> value
                         truncated to whole number.
<LI><A HREF="g77_12.html#SEC225">Int8 Intrinsic</A>: Convert to <CODE>INTEGER(KIND=2)</CODE> value
                         truncated to whole number.
<LI><A HREF="g77_12.html#SEC226">IOr Intrinsic</A>: Boolean OR.
<LI><A HREF="g77_12.html#SEC227">IRand Intrinsic</A>: Random number.
<LI><A HREF="g77_12.html#SEC228">IsaTty Intrinsic</A>: Is unit connected to a terminal?
<LI><A HREF="g77_12.html#SEC229">IShft Intrinsic</A>: Logical bit shift.
<LI><A HREF="g77_12.html#SEC230">IShftC Intrinsic</A>: Circular bit shift.
<LI><A HREF="g77_12.html#SEC231">ISign Intrinsic</A>: Apply sign to magnitude (archaic).
<LI><A HREF="g77_12.html#SEC232">ITime Intrinsic</A>: Get local time of day.
<LI><A HREF="g77_12.html#SEC233">Kill Intrinsic (subroutine)</A>: Signal a process.
<LI><A HREF="g77_12.html#SEC234">Kind Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC235">LBound Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC236">Len Intrinsic</A>: Length of character entity.
<LI><A HREF="g77_12.html#SEC237">Len_Trim Intrinsic</A>: Get last non-blank character in string.
<LI><A HREF="g77_12.html#SEC238">LGe Intrinsic</A>: Lexically greater than or equal.
<LI><A HREF="g77_12.html#SEC239">LGt Intrinsic</A>: Lexically greater than.
<LI><A HREF="g77_12.html#SEC240">Link Intrinsic (subroutine)</A>: Make hard link in file system.
<LI><A HREF="g77_12.html#SEC241">LLe Intrinsic</A>: Lexically less than or equal.
<LI><A HREF="g77_12.html#SEC242">LLt Intrinsic</A>: Lexically less than.
<LI><A HREF="g77_12.html#SEC243">LnBlnk Intrinsic</A>: Get last non-blank character in string.
<LI><A HREF="g77_12.html#SEC244">Loc Intrinsic</A>: Address of entity in core.
<LI><A HREF="g77_12.html#SEC245">Log Intrinsic</A>: Natural logarithm.
<LI><A HREF="g77_12.html#SEC246">Log10 Intrinsic</A>: Common logarithm.
<LI><A HREF="g77_12.html#SEC247">Logical Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC248">Long Intrinsic</A>: Conversion to <CODE>INTEGER(KIND=1)</CODE> (archaic).
<LI><A HREF="g77_12.html#SEC249">LShift Intrinsic</A>: Left-shift bits.
<LI><A HREF="g77_12.html#SEC250">LStat Intrinsic (subroutine)</A>: Get file information.
<LI><A HREF="g77_12.html#SEC251">LStat Intrinsic (function)</A>: Get file information.
<LI><A HREF="g77_12.html#SEC252">LTime Intrinsic</A>: Convert time to local time info.
<LI><A HREF="g77_12.html#SEC253">MatMul Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC254">Max Intrinsic</A>: Maximum value.
<LI><A HREF="g77_12.html#SEC255">Max0 Intrinsic</A>: Maximum value (archaic).
<LI><A HREF="g77_12.html#SEC256">Max1 Intrinsic</A>: Maximum value (archaic).
<LI><A HREF="g77_12.html#SEC257">MaxExponent Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC258">MaxLoc Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC259">MaxVal Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC260">MClock Intrinsic</A>: Get number of clock ticks for process.
<LI><A HREF="g77_12.html#SEC261">MClock8 Intrinsic</A>: Get number of clock ticks for process.
<LI><A HREF="g77_12.html#SEC262">Merge Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC263">Min Intrinsic</A>: Minimum value.
<LI><A HREF="g77_12.html#SEC264">Min0 Intrinsic</A>: Minimum value (archaic).
<LI><A HREF="g77_12.html#SEC265">Min1 Intrinsic</A>: Minimum value (archaic).
<LI><A HREF="g77_12.html#SEC266">MinExponent Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC267">MinLoc Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC268">MinVal Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC269">Mod Intrinsic</A>: Remainder.
<LI><A HREF="g77_12.html#SEC270">Modulo Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC271">MvBits Intrinsic</A>: Moving a bit field.
<LI><A HREF="g77_12.html#SEC272">Nearest Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC273">NInt Intrinsic</A>: Convert to <CODE>INTEGER</CODE> value rounded
                         to nearest whole number.
<LI><A HREF="g77_12.html#SEC274">Not Intrinsic</A>: Boolean NOT.
<LI><A HREF="g77_12.html#SEC275">Or Intrinsic</A>: Boolean OR.
<LI><A HREF="g77_12.html#SEC276">Pack Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC277">PError Intrinsic</A>: Print error message for last error.
<LI><A HREF="g77_12.html#SEC278">Precision Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC279">Present Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC280">Product Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC281">Radix Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC282">Rand Intrinsic</A>: Random number.
<LI><A HREF="g77_12.html#SEC283">Random_Number Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC284">Random_Seed Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC285">Range Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC286">Real Intrinsic</A>: Convert value to type <CODE>REAL(KIND=1)</CODE>.
<LI><A HREF="g77_12.html#SEC287">RealPart Intrinsic</A>: Extract real part of complex.
<LI><A HREF="g77_12.html#SEC288">Rename Intrinsic (subroutine)</A>: Rename file.
<LI><A HREF="g77_12.html#SEC289">Repeat Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC290">Reshape Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC291">RRSpacing Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC292">RShift Intrinsic</A>: Right-shift bits.
<LI><A HREF="g77_12.html#SEC293">Scale Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC294">Scan Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC295">Second Intrinsic (function)</A>: Get CPU time for process in seconds.
<LI><A HREF="g77_12.html#SEC296">Second Intrinsic (subroutine)</A>: Get CPU time for process
                         in seconds.
<LI><A HREF="g77_12.html#SEC297">Selected_Int_Kind Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC298">Selected_Real_Kind Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC299">Set_Exponent Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC300">Shape Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC301">Short Intrinsic</A>: Convert to <CODE>INTEGER(KIND=6)</CODE> value
                         truncated to whole number.
<LI><A HREF="g77_12.html#SEC302">Sign Intrinsic</A>: Apply sign to magnitude.
<LI><A HREF="g77_12.html#SEC303">Signal Intrinsic (subroutine)</A>: Muck with signal handling.
<LI><A HREF="g77_12.html#SEC304">Sin Intrinsic</A>: Sine.
<LI><A HREF="g77_12.html#SEC305">SinH Intrinsic</A>: Hyperbolic sine.
<LI><A HREF="g77_12.html#SEC306">Sleep Intrinsic</A>: Sleep for a specified time.
<LI><A HREF="g77_12.html#SEC307">Sngl Intrinsic</A>: Convert (archaic).
<LI><A HREF="g77_12.html#SEC308">Spacing Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC309">Spread Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC310">SqRt Intrinsic</A>: Square root.
<LI><A HREF="g77_12.html#SEC311">SRand Intrinsic</A>: Random seed.
<LI><A HREF="g77_12.html#SEC312">Stat Intrinsic (subroutine)</A>: Get file information.
<LI><A HREF="g77_12.html#SEC313">Stat Intrinsic (function)</A>: Get file information.
<LI><A HREF="g77_12.html#SEC314">Sum Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC315">SymLnk Intrinsic (subroutine)</A>: Make symbolic link in file system.
<LI><A HREF="g77_12.html#SEC316">System Intrinsic (subroutine)</A>: Invoke shell (system) command.
<LI><A HREF="g77_12.html#SEC317">System_Clock Intrinsic</A>: Get current system clock value.
<LI><A HREF="g77_12.html#SEC318">Tan Intrinsic</A>: Tangent.
<LI><A HREF="g77_12.html#SEC319">TanH Intrinsic</A>: Hyperbolic tangent.
<LI><A HREF="g77_12.html#SEC320">Time Intrinsic (UNIX)</A>: Get current time as time value.
<LI><A HREF="g77_12.html#SEC321">Time8 Intrinsic</A>: Get current time as time value.
<LI><A HREF="g77_12.html#SEC322">Tiny Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC323">Transfer Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC324">Transpose Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC325">Trim Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC326">TtyNam Intrinsic (subroutine)</A>: Get name of terminal device for unit.
<LI><A HREF="g77_12.html#SEC327">TtyNam Intrinsic (function)</A>: Get name of terminal device for unit.
<LI><A HREF="g77_12.html#SEC328">UBound Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC329">UMask Intrinsic (subroutine)</A>: Set file creation permissions mask.
<LI><A HREF="g77_12.html#SEC330">Unlink Intrinsic (subroutine)</A>: Unlink file.
<LI><A HREF="g77_12.html#SEC331">Unpack Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC332">Verify Intrinsic</A>: (Reserved for future use.)
<LI><A HREF="g77_12.html#SEC333">XOr Intrinsic</A>: Boolean XOR.
<LI><A HREF="g77_12.html#SEC334">ZAbs Intrinsic</A>: Absolute value (archaic).
<LI><A HREF="g77_12.html#SEC335">ZCos Intrinsic</A>: Cosine (archaic).
<LI><A HREF="g77_12.html#SEC336">ZExp Intrinsic</A>: Exponential (archaic).
<LI><A HREF="g77_12.html#SEC337">ZLog Intrinsic</A>: Natural logarithm (archaic).
<LI><A HREF="g77_12.html#SEC338">ZSin Intrinsic</A>: Sine (archaic).
<LI><A HREF="g77_12.html#SEC339">ZSqRt Intrinsic</A>: Square root (archaic).
</UL>



<H4><A NAME="SEC76" HREF="g77_toc.html#TOC76">Abort Intrinsic</A></H4>
<P>
<A NAME="IDX754"></A>
<A NAME="IDX755"></A>

</P>
<P>

<PRE>
CALL Abort()
</PRE>

<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Prints a message and potentially causes a core dump via <CODE>abort(3)</CODE>.

</P>


<H4><A NAME="SEC77" HREF="g77_toc.html#TOC77">Abs Intrinsic</A></H4>
<P>
<A NAME="IDX756"></A>
<A NAME="IDX757"></A>

</P>
<P>

<PRE>
Abs(<VAR>A</VAR>)
</PRE>

<P>
Abs: <CODE>INTEGER</CODE> or <CODE>REAL</CODE> function.
The exact type depends on that of argument <VAR>A</VAR>---if <VAR>A</VAR> is
<CODE>COMPLEX</CODE>, this function's type is <CODE>REAL</CODE>
with the same <SAMP>`KIND='</SAMP> value as the type of <VAR>A</VAR>.
Otherwise, this function's type is the same as that of <VAR>A</VAR>.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE>, <CODE>REAL</CODE>, or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the absolute value of <VAR>A</VAR>.

</P>
<P>
If <VAR>A</VAR> is type <CODE>COMPLEX</CODE>, the absolute
value is computed as:

</P>

<PRE>
SQRT(REALPART(<VAR>A</VAR>)**2, IMAGPART(<VAR>A</VAR>)**2)
</PRE>

<P>
Otherwise, it is computed by negating the <VAR>A</VAR> if
it is negative, or returning <VAR>A</VAR>.

</P>
<P>
See section <A HREF="g77_12.html#SEC302">Sign Intrinsic</A>, for how to explicitly
compute the positive or negative form of the absolute
value of an expression.

</P>


<H4><A NAME="SEC78" HREF="g77_toc.html#TOC78">Access Intrinsic</A></H4>
<P>
<A NAME="IDX758"></A>
<A NAME="IDX759"></A>

</P>
<P>

<PRE>
Access(<VAR>Name</VAR>, <VAR>Mode</VAR>)
</PRE>

<P>
Access: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>Name</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Mode</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Checks file <VAR>Name</VAR> for accessibility in the mode specified by <VAR>Mode</VAR> and
returns 0 if the file is accessible in that mode, otherwise an error
code if the file is inaccessible or <VAR>Mode</VAR> is invalid.
See <CODE>access(2)</CODE>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the name in <VAR>Name</VAR>---otherwise,
trailing blanks in <VAR>Name</VAR> are ignored.
<VAR>Mode</VAR> may be a concatenation of any of the following characters:

</P>
<DL COMPACT>

<DT><SAMP>`r'</SAMP>
<DD>
Read permission

<DT><SAMP>`w'</SAMP>
<DD>
Write permission

<DT><SAMP>`x'</SAMP>
<DD>
Execute permission

<DT><SAMP>`<KBD>SPC</KBD>'</SAMP>
<DD>
Existence
</DL>



<H4><A NAME="SEC79" HREF="g77_toc.html#TOC79">AChar Intrinsic</A></H4>
<P>
<A NAME="IDX760"></A>
<A NAME="IDX761"></A>

</P>
<P>

<PRE>
AChar(<VAR>I</VAR>)
</PRE>

<P>
AChar: <CODE>CHARACTER*1</CODE> function.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>, <CODE>f90</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the ASCII character corresponding to the
code specified by <VAR>I</VAR>.

</P>
<P>
See section <A HREF="g77_12.html#SEC206">IAChar Intrinsic</A>, for the inverse of this function.

</P>
<P>
See section <A HREF="g77_12.html#SEC114">Char Intrinsic</A>, for the function corresponding
to the system's native character set.

</P>


<H4><A NAME="SEC80" HREF="g77_toc.html#TOC80">ACos Intrinsic</A></H4>
<P>
<A NAME="IDX762"></A>
<A NAME="IDX763"></A>

</P>
<P>

<PRE>
ACos(<VAR>X</VAR>)
</PRE>

<P>
ACos: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the arc-cosine (inverse cosine) of <VAR>X</VAR>
in radians.

</P>
<P>
See section <A HREF="g77_12.html#SEC121">Cos Intrinsic</A>, for the inverse of this function.

</P>


<H4><A NAME="SEC81" HREF="g77_toc.html#TOC81">AdjustL Intrinsic</A></H4>
<P>
<A NAME="IDX764"></A>
<A NAME="IDX765"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL AdjustL'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC82" HREF="g77_toc.html#TOC82">AdjustR Intrinsic</A></H4>
<P>
<A NAME="IDX766"></A>
<A NAME="IDX767"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL AdjustR'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC83" HREF="g77_toc.html#TOC83">AImag Intrinsic</A></H4>
<P>
<A NAME="IDX768"></A>
<A NAME="IDX769"></A>

</P>
<P>

<PRE>
AImag(<VAR>Z</VAR>)
</PRE>

<P>
AImag: <CODE>REAL</CODE> function.
This intrinsic is valid when argument <VAR>Z</VAR> is
<CODE>COMPLEX(KIND=1)</CODE>.
When <VAR>Z</VAR> is any other <CODE>COMPLEX</CODE> type,
this intrinsic is valid only when used as the argument to
<CODE>REAL()</CODE>, as explained below.

</P>
<P>
<VAR>Z</VAR>: <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the (possibly converted) imaginary part of <VAR>Z</VAR>.

</P>
<P>
Use of <CODE>AIMAG()</CODE> with an argument of a type
other than <CODE>COMPLEX(KIND=1)</CODE> is restricted to the following case:

</P>

<PRE>
REAL(AIMAG(Z))
</PRE>

<P>
This expression converts the imaginary part of Z to
<CODE>REAL(KIND=1)</CODE>.

</P>
<P>
See section <A HREF="g77_12.html#SEC71"><CODE>REAL()</CODE> and <CODE>AIMAG()</CODE> of Complex</A>, for more information.

</P>


<H4><A NAME="SEC84" HREF="g77_toc.html#TOC84">AInt Intrinsic</A></H4>
<P>
<A NAME="IDX770"></A>
<A NAME="IDX771"></A>

</P>
<P>

<PRE>
AInt(<VAR>A</VAR>)
</PRE>

<P>
AInt: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>A</VAR>.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <VAR>A</VAR> with the fractional portion of its
magnitude truncated and its sign preserved.
(Also called "truncation towards zero".)

</P>
<P>
See section <A HREF="g77_12.html#SEC96">ANInt Intrinsic</A>, for how to round to nearest
whole number.

</P>
<P>
See section <A HREF="g77_12.html#SEC223">Int Intrinsic</A>, for how to truncate and then convert
number to <CODE>INTEGER</CODE>.

</P>


<H4><A NAME="SEC85" HREF="g77_toc.html#TOC85">Alarm Intrinsic</A></H4>
<P>
<A NAME="IDX772"></A>
<A NAME="IDX773"></A>

</P>
<P>

<PRE>
CALL Alarm(<VAR>Seconds</VAR>, <VAR>Handler</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Seconds</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Handler</VAR>: Signal handler (<CODE>INTEGER FUNCTION</CODE> or <CODE>SUBROUTINE</CODE>)
or dummy/global <CODE>INTEGER(KIND=1)</CODE> scalar.

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Causes external subroutine <VAR>Handler</VAR> to be executed after a delay of
<VAR>Seconds</VAR> seconds by using <CODE>alarm(1)</CODE> to set up a signal and
<CODE>signal(2)</CODE> to catch it.
If <VAR>Status</VAR> is supplied, it will be
returned with the number of seconds remaining until any previously
scheduled alarm was due to be delivered, or zero if there was no
previously scheduled alarm.
See section <A HREF="g77_12.html#SEC303">Signal Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC86" HREF="g77_toc.html#TOC86">All Intrinsic</A></H4>
<P>
<A NAME="IDX774"></A>
<A NAME="IDX775"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL All'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC87" HREF="g77_toc.html#TOC87">Allocated Intrinsic</A></H4>
<P>
<A NAME="IDX776"></A>
<A NAME="IDX777"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Allocated'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC88" HREF="g77_toc.html#TOC88">ALog Intrinsic</A></H4>
<P>
<A NAME="IDX778"></A>
<A NAME="IDX779"></A>

</P>
<P>

<PRE>
ALog(<VAR>X</VAR>)
</PRE>

<P>
ALog: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>LOG()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC245">Log Intrinsic</A>.

</P>


<H4><A NAME="SEC89" HREF="g77_toc.html#TOC89">ALog10 Intrinsic</A></H4>
<P>
<A NAME="IDX780"></A>
<A NAME="IDX781"></A>

</P>
<P>

<PRE>
ALog10(<VAR>X</VAR>)
</PRE>

<P>
ALog10: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>LOG10()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC246">Log10 Intrinsic</A>.

</P>


<H4><A NAME="SEC90" HREF="g77_toc.html#TOC90">AMax0 Intrinsic</A></H4>
<P>
<A NAME="IDX782"></A>
<A NAME="IDX783"></A>

</P>
<P>

<PRE>
AMax0(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
AMax0: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER(KIND=1)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MAX()</CODE> that is specific
to one type for <VAR>A</VAR> and a different return type.
See section <A HREF="g77_12.html#SEC254">Max Intrinsic</A>.

</P>


<H4><A NAME="SEC91" HREF="g77_toc.html#TOC91">AMax1 Intrinsic</A></H4>
<P>
<A NAME="IDX784"></A>
<A NAME="IDX785"></A>

</P>
<P>

<PRE>
AMax1(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
AMax1: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=1)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MAX()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC254">Max Intrinsic</A>.

</P>


<H4><A NAME="SEC92" HREF="g77_toc.html#TOC92">AMin0 Intrinsic</A></H4>
<P>
<A NAME="IDX786"></A>
<A NAME="IDX787"></A>

</P>
<P>

<PRE>
AMin0(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
AMin0: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER(KIND=1)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MIN()</CODE> that is specific
to one type for <VAR>A</VAR> and a different return type.
See section <A HREF="g77_12.html#SEC263">Min Intrinsic</A>.

</P>


<H4><A NAME="SEC93" HREF="g77_toc.html#TOC93">AMin1 Intrinsic</A></H4>
<P>
<A NAME="IDX788"></A>
<A NAME="IDX789"></A>

</P>
<P>

<PRE>
AMin1(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
AMin1: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=1)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MIN()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC263">Min Intrinsic</A>.

</P>


<H4><A NAME="SEC94" HREF="g77_toc.html#TOC94">AMod Intrinsic</A></H4>
<P>
<A NAME="IDX790"></A>
<A NAME="IDX791"></A>

</P>
<P>

<PRE>
AMod(<VAR>A</VAR>, <VAR>P</VAR>)
</PRE>

<P>
AMod: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>P</VAR>: <CODE>REAL(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MOD()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC269">Mod Intrinsic</A>.

</P>


<H4><A NAME="SEC95" HREF="g77_toc.html#TOC95">And Intrinsic</A></H4>
<P>
<A NAME="IDX792"></A>
<A NAME="IDX793"></A>

</P>
<P>

<PRE>
And(<VAR>I</VAR>, <VAR>J</VAR>)
</PRE>

<P>
And: <CODE>INTEGER</CODE> or <CODE>LOGICAL</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE> or <CODE>LOGICAL</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>J</VAR>: <CODE>INTEGER</CODE> or <CODE>LOGICAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns value resulting from boolean AND of
pair of bits in each of <VAR>I</VAR> and <VAR>J</VAR>.

</P>


<H4><A NAME="SEC96" HREF="g77_toc.html#TOC96">ANInt Intrinsic</A></H4>
<P>
<A NAME="IDX794"></A>
<A NAME="IDX795"></A>

</P>
<P>

<PRE>
ANInt(<VAR>A</VAR>)
</PRE>

<P>
ANInt: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>A</VAR>.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <VAR>A</VAR> with the fractional portion of its
magnitude eliminated by rounding to the nearest whole
number and with its sign preserved.

</P>
<P>
A fractional portion exactly equal to
<SAMP>`.5'</SAMP> is rounded to the whole number that
is larger in magnitude.
(Also called "Fortran round".)

</P>
<P>
See section <A HREF="g77_12.html#SEC84">AInt Intrinsic</A>, for how to truncate to
whole number.

</P>
<P>
See section <A HREF="g77_12.html#SEC273">NInt Intrinsic</A>, for how to round and then convert
number to <CODE>INTEGER</CODE>.

</P>


<H4><A NAME="SEC97" HREF="g77_toc.html#TOC97">Any Intrinsic</A></H4>
<P>
<A NAME="IDX796"></A>
<A NAME="IDX797"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Any'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC98" HREF="g77_toc.html#TOC98">ASin Intrinsic</A></H4>
<P>
<A NAME="IDX798"></A>
<A NAME="IDX799"></A>

</P>
<P>

<PRE>
ASin(<VAR>X</VAR>)
</PRE>

<P>
ASin: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the arc-sine (inverse sine) of <VAR>X</VAR>
in radians.

</P>
<P>
See section <A HREF="g77_12.html#SEC304">Sin Intrinsic</A>, for the inverse of this function.

</P>


<H4><A NAME="SEC99" HREF="g77_toc.html#TOC99">Associated Intrinsic</A></H4>
<P>
<A NAME="IDX800"></A>
<A NAME="IDX801"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Associated'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC100" HREF="g77_toc.html#TOC100">ATan Intrinsic</A></H4>
<P>
<A NAME="IDX802"></A>
<A NAME="IDX803"></A>

</P>
<P>

<PRE>
ATan(<VAR>X</VAR>)
</PRE>

<P>
ATan: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the arc-tangent (inverse tangent) of <VAR>X</VAR>
in radians.

</P>
<P>
See section <A HREF="g77_12.html#SEC318">Tan Intrinsic</A>, for the inverse of this function.

</P>


<H4><A NAME="SEC101" HREF="g77_toc.html#TOC101">ATan2 Intrinsic</A></H4>
<P>
<A NAME="IDX804"></A>
<A NAME="IDX805"></A>

</P>
<P>

<PRE>
ATan2(<VAR>Y</VAR>, <VAR>X</VAR>)
</PRE>

<P>
ATan2: <CODE>REAL</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>Y</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the arc-tangent (inverse tangent) of the complex
number (<VAR>Y</VAR>, <VAR>X</VAR>) in radians.

</P>
<P>
See section <A HREF="g77_12.html#SEC318">Tan Intrinsic</A>, for the inverse of this function.

</P>


<H4><A NAME="SEC102" HREF="g77_toc.html#TOC102">BesJ0 Intrinsic</A></H4>
<P>
<A NAME="IDX806"></A>
<A NAME="IDX807"></A>

</P>
<P>

<PRE>
BesJ0(<VAR>X</VAR>)
</PRE>

<P>
BesJ0: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Calculates the Bessel function of the first kind of order 0 of <VAR>X</VAR>.
See <CODE>bessel(3m)</CODE>, on whose implementation the function depends.


<H4><A NAME="SEC103" HREF="g77_toc.html#TOC103">BesJ1 Intrinsic</A></H4>
<P>
<A NAME="IDX808"></A>
<A NAME="IDX809"></A>

</P>
<P>

<PRE>
BesJ1(<VAR>X</VAR>)
</PRE>

<P>
BesJ1: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Calculates the Bessel function of the first kind of order 1 of <VAR>X</VAR>.
See <CODE>bessel(3m)</CODE>, on whose implementation the function depends.


<H4><A NAME="SEC104" HREF="g77_toc.html#TOC104">BesJN Intrinsic</A></H4>
<P>
<A NAME="IDX810"></A>
<A NAME="IDX811"></A>

</P>
<P>

<PRE>
BesJN(<VAR>N</VAR>, <VAR>X</VAR>)
</PRE>

<P>
BesJN: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>N</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Calculates the Bessel function of the first kind of order <VAR>N</VAR> of <VAR>X</VAR>.
See <CODE>bessel(3m)</CODE>, on whose implementation the function depends.


<H4><A NAME="SEC105" HREF="g77_toc.html#TOC105">BesY0 Intrinsic</A></H4>
<P>
<A NAME="IDX812"></A>
<A NAME="IDX813"></A>

</P>
<P>

<PRE>
BesY0(<VAR>X</VAR>)
</PRE>

<P>
BesY0: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Calculates the Bessel function of the second kind of order 0 of <VAR>X</VAR>.
See <CODE>bessel(3m)</CODE>, on whose implementation the function depends.


<H4><A NAME="SEC106" HREF="g77_toc.html#TOC106">BesY1 Intrinsic</A></H4>
<P>
<A NAME="IDX814"></A>
<A NAME="IDX815"></A>

</P>
<P>

<PRE>
BesY1(<VAR>X</VAR>)
</PRE>

<P>
BesY1: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Calculates the Bessel function of the second kind of order 1 of <VAR>X</VAR>.
See <CODE>bessel(3m)</CODE>, on whose implementation the function depends.


<H4><A NAME="SEC107" HREF="g77_toc.html#TOC107">BesYN Intrinsic</A></H4>
<P>
<A NAME="IDX816"></A>
<A NAME="IDX817"></A>

</P>
<P>

<PRE>
BesYN(<VAR>N</VAR>, <VAR>X</VAR>)
</PRE>

<P>
BesYN: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>N</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Calculates the Bessel function of the second kind of order <VAR>N</VAR> of <VAR>X</VAR>.
See <CODE>bessel(3m)</CODE>, on whose implementation the function depends.


<H4><A NAME="SEC108" HREF="g77_toc.html#TOC108">Bit_Size Intrinsic</A></H4>
<P>
<A NAME="IDX818"></A>
<A NAME="IDX819"></A>

</P>
<P>

<PRE>
Bit_Size(<VAR>I</VAR>)
</PRE>

<P>
Bit_Size: <CODE>INTEGER</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>I</VAR>.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar.

</P>
<P>
Intrinsic groups: <CODE>f90</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the number of bits (integer precision plus sign bit)
represented by the type for <VAR>I</VAR>.

</P>
<P>
See section <A HREF="g77_12.html#SEC109">BTest Intrinsic</A>, for how to test the value of a
bit in a variable or array.

</P>
<P>
See section <A HREF="g77_12.html#SEC211">IBSet Intrinsic</A>, for how to set a bit in a variable to 1.

</P>
<P>
See section <A HREF="g77_12.html#SEC209">IBClr Intrinsic</A>, for how to set a bit in a variable to 0.

</P>



<H4><A NAME="SEC109" HREF="g77_toc.html#TOC109">BTest Intrinsic</A></H4>
<P>
<A NAME="IDX820"></A>
<A NAME="IDX821"></A>

</P>
<P>

<PRE>
BTest(<VAR>I</VAR>, <VAR>Pos</VAR>)
</PRE>

<P>
BTest: <CODE>LOGICAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Pos</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns <CODE>.TRUE.</CODE> if bit <VAR>Pos</VAR> in <VAR>I</VAR> is
1, <CODE>.FALSE.</CODE> otherwise.

</P>
<P>
(Bit 0 is the low-order (rightmost) bit, adding the value 
or 1,
to the number if set to 1;
bit 1 is the next-higher-order bit, adding 
or 2;
bit 2 adds 
or 4; and so on.)

</P>
<P>
See section <A HREF="g77_12.html#SEC108">Bit_Size Intrinsic</A>, for how to obtain the number of bits
in a type.
The leftmost bit of <VAR>I</VAR> is <SAMP>`BIT_SIZE(<VAR>I</VAR>-1)'</SAMP>.

</P>


<H4><A NAME="SEC110" HREF="g77_toc.html#TOC110">CAbs Intrinsic</A></H4>
<P>
<A NAME="IDX822"></A>
<A NAME="IDX823"></A>

</P>
<P>

<PRE>
CAbs(<VAR>A</VAR>)
</PRE>

<P>
CAbs: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>COMPLEX(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ABS()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC77">Abs Intrinsic</A>.

</P>


<H4><A NAME="SEC111" HREF="g77_toc.html#TOC111">CCos Intrinsic</A></H4>
<P>
<A NAME="IDX824"></A>
<A NAME="IDX825"></A>

</P>
<P>

<PRE>
CCos(<VAR>X</VAR>)
</PRE>

<P>
CCos: <CODE>COMPLEX(KIND=1)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>COS()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC121">Cos Intrinsic</A>.

</P>


<H4><A NAME="SEC112" HREF="g77_toc.html#TOC112">Ceiling Intrinsic</A></H4>
<P>
<A NAME="IDX826"></A>
<A NAME="IDX827"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Ceiling'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC113" HREF="g77_toc.html#TOC113">CExp Intrinsic</A></H4>
<P>
<A NAME="IDX828"></A>
<A NAME="IDX829"></A>

</P>
<P>

<PRE>
CExp(<VAR>X</VAR>)
</PRE>

<P>
CExp: <CODE>COMPLEX(KIND=1)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>EXP()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC174">Exp Intrinsic</A>.

</P>


<H4><A NAME="SEC114" HREF="g77_toc.html#TOC114">Char Intrinsic</A></H4>
<P>
<A NAME="IDX830"></A>
<A NAME="IDX831"></A>

</P>
<P>

<PRE>
Char(<VAR>I</VAR>)
</PRE>

<P>
Char: <CODE>CHARACTER*1</CODE> function.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the character corresponding to the
code specified by <VAR>I</VAR>, using the system's
native character set.

</P>
<P>
Because the system's native character set is used,
the correspondence between character and their codes
is not necessarily the same between GNU Fortran
implementations.

</P>
<P>
Note that no intrinsic exists to convert a numerical
value to a printable character string.
For example, there is no intrinsic that, given
an <CODE>INTEGER</CODE> or <CODE>REAL</CODE> argument with the
value <SAMP>`154'</SAMP>, returns the <CODE>CHARACTER</CODE>
result <SAMP>`'154''</SAMP>.

</P>
<P>
Instead, you can use internal-file I/O to do this kind
of conversion.
For example:

</P>

<PRE>
INTEGER VALUE
CHARACTER*10 STRING
VALUE = 154
WRITE (STRING, '(I10)'), VALUE
PRINT *, STRING
END
</PRE>

<P>
The above program, when run, prints:

</P>

<PRE>
        154
</PRE>

<P>
See section <A HREF="g77_12.html#SEC212">IChar Intrinsic</A>, for the inverse of the <CODE>CHAR</CODE> function.

</P>
<P>
See section <A HREF="g77_12.html#SEC79">AChar Intrinsic</A>, for the function corresponding
to the ASCII character set.

</P>


<H4><A NAME="SEC115" HREF="g77_toc.html#TOC115">ChDir Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX832"></A>
<A NAME="IDX833"></A>

</P>
<P>

<PRE>
CALL ChDir(<VAR>Dir</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Dir</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Sets the current working directory to be <VAR>Dir</VAR>.
If the <VAR>Status</VAR> argument is supplied, it contains 0
on success or a non-zero error code otherwise upon return.
See <CODE>chdir(3)</CODE>.

</P>
<P>
<EM>Caution:</EM> Using this routine during I/O to a unit connected with a
non-absolute file name can cause subsequent I/O on such a unit to fail
because the I/O library might reopen files by name.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC397">ChDir Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC116" HREF="g77_toc.html#TOC116">ChMod Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX834"></A>
<A NAME="IDX835"></A>

</P>
<P>

<PRE>
CALL ChMod(<VAR>Name</VAR>, <VAR>Mode</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Name</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Mode</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Changes the access mode of file <VAR>Name</VAR> according to the
specification <VAR>Mode</VAR>, which is given in the format of
<CODE>chmod(1)</CODE>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the name in <VAR>Name</VAR>---otherwise,
trailing blanks in <VAR>Name</VAR> are ignored.
Currently, <VAR>Name</VAR> must not contain the single quote
character.

</P>
<P>
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return.

</P>
<P>
Note that this currently works
by actually invoking <CODE>/bin/chmod</CODE> (or the <CODE>chmod</CODE> found when
the library was configured) and so might fail in some circumstances and
will, anyway, be slow.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC398">ChMod Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC117" HREF="g77_toc.html#TOC117">CLog Intrinsic</A></H4>
<P>
<A NAME="IDX836"></A>
<A NAME="IDX837"></A>

</P>
<P>

<PRE>
CLog(<VAR>X</VAR>)
</PRE>

<P>
CLog: <CODE>COMPLEX(KIND=1)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>LOG()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC245">Log Intrinsic</A>.

</P>


<H4><A NAME="SEC118" HREF="g77_toc.html#TOC118">Cmplx Intrinsic</A></H4>
<P>
<A NAME="IDX838"></A>
<A NAME="IDX839"></A>

</P>
<P>

<PRE>
Cmplx(<VAR>X</VAR>, <VAR>Y</VAR>)
</PRE>

<P>
Cmplx: <CODE>COMPLEX(KIND=1)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>INTEGER</CODE>, <CODE>REAL</CODE>, or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Y</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; OPTIONAL (must be omitted if <VAR>X</VAR> is <CODE>COMPLEX</CODE>); scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
If <VAR>X</VAR> is not type <CODE>COMPLEX</CODE>,
constructs a value of type <CODE>COMPLEX(KIND=1)</CODE> from the
real and imaginary values specified by <VAR>X</VAR> and
<VAR>Y</VAR>, respectively.
If <VAR>Y</VAR> is omitted, <SAMP>`0.'</SAMP> is assumed.

</P>
<P>
If <VAR>X</VAR> is type <CODE>COMPLEX</CODE>,
converts it to type <CODE>COMPLEX(KIND=1)</CODE>.

</P>
<P>
See section <A HREF="g77_12.html#SEC119">Complex Intrinsic</A>, for information on easily constructing
a <CODE>COMPLEX</CODE> value of arbitrary precision from <CODE>REAL</CODE>
arguments.

</P>


<H4><A NAME="SEC119" HREF="g77_toc.html#TOC119">Complex Intrinsic</A></H4>
<P>
<A NAME="IDX840"></A>
<A NAME="IDX841"></A>

</P>
<P>

<PRE>
Complex(<VAR>Real</VAR>, <VAR>Imag</VAR>)
</PRE>

<P>
Complex: <CODE>COMPLEX</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>Real</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Imag</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>gnu</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns a <CODE>COMPLEX</CODE> value that has <SAMP>`Real'</SAMP> and <SAMP>`Imag'</SAMP> as its
real and imaginary parts, respectively.

</P>
<P>
If <VAR>Real</VAR> and <VAR>Imag</VAR> are the same type, and that type is not
<CODE>INTEGER</CODE>, no data conversion is performed, and the type of
the resulting value has the same kind value as the types
of <VAR>Real</VAR> and <VAR>Imag</VAR>.

</P>
<P>
If <VAR>Real</VAR> and <VAR>Imag</VAR> are not the same type, the usual type-promotion
rules are applied to both, converting either or both to the
appropriate <CODE>REAL</CODE> type.
The type of the resulting value has the same kind value as the
type to which both <VAR>Real</VAR> and <VAR>Imag</VAR> were converted, in this case.

</P>
<P>
If <VAR>Real</VAR> and <VAR>Imag</VAR> are both <CODE>INTEGER</CODE>, they are both converted
to <CODE>REAL(KIND=1)</CODE>, and the result of the <CODE>COMPLEX()</CODE>
invocation is type <CODE>COMPLEX(KIND=1)</CODE>.

</P>
<P>
<EM>Note:</EM> The way to do this in standard Fortran 90
is too hairy to describe here, but it is important to
note that <SAMP>`CMPLX(D1,D2)'</SAMP> returns a <CODE>COMPLEX(KIND=1)</CODE>
result even if <SAMP>`D1'</SAMP> and <SAMP>`D2'</SAMP> are type <CODE>REAL(KIND=2)</CODE>.
Hence the availability of <CODE>COMPLEX()</CODE> in GNU Fortran.

</P>


<H4><A NAME="SEC120" HREF="g77_toc.html#TOC120">Conjg Intrinsic</A></H4>
<P>
<A NAME="IDX842"></A>
<A NAME="IDX843"></A>

</P>
<P>

<PRE>
Conjg(<VAR>Z</VAR>)
</PRE>

<P>
Conjg: <CODE>COMPLEX</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>Z</VAR>.

</P>
<P>
<VAR>Z</VAR>: <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the complex conjugate:

</P>

<PRE>
COMPLEX(REALPART(<VAR>Z</VAR>), -IMAGPART(<VAR>Z</VAR>))
</PRE>



<H4><A NAME="SEC121" HREF="g77_toc.html#TOC121">Cos Intrinsic</A></H4>
<P>
<A NAME="IDX844"></A>
<A NAME="IDX845"></A>

</P>
<P>

<PRE>
Cos(<VAR>X</VAR>)
</PRE>

<P>
Cos: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE> function, the exact type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the cosine of <VAR>X</VAR>, an angle measured
in radians.

</P>
<P>
See section <A HREF="g77_12.html#SEC80">ACos Intrinsic</A>, for the inverse of this function.

</P>


<H4><A NAME="SEC122" HREF="g77_toc.html#TOC122">CosH Intrinsic</A></H4>
<P>
<A NAME="IDX846"></A>
<A NAME="IDX847"></A>

</P>
<P>

<PRE>
CosH(<VAR>X</VAR>)
</PRE>

<P>
CosH: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the hyperbolic cosine of <VAR>X</VAR>.

</P>


<H4><A NAME="SEC123" HREF="g77_toc.html#TOC123">Count Intrinsic</A></H4>
<P>
<A NAME="IDX848"></A>
<A NAME="IDX849"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Count'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC124" HREF="g77_toc.html#TOC124">CPU_Time Intrinsic</A></H4>
<P>
<A NAME="IDX850"></A>
<A NAME="IDX851"></A>

</P>
<P>

<PRE>
CALL CPU_Time(<VAR>Seconds</VAR>)
</PRE>

<P>
<VAR>Seconds</VAR>: <CODE>REAL</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>f90</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns in <VAR>Seconds</VAR> the current value of the system time.
This implementation of the Fortran 95 intrinsic is just an alias for
<CODE>second</CODE> See section <A HREF="g77_12.html#SEC296">Second Intrinsic (subroutine)</A>.

</P>
<P>
<A NAME="IDX852"></A>
<A NAME="IDX853"></A>
On some systems, the underlying timings are represented
using types with sufficiently small limits that overflows
(wraparounds) are possible, such as 32-bit types.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>


<H4><A NAME="SEC125" HREF="g77_toc.html#TOC125">CShift Intrinsic</A></H4>
<P>
<A NAME="IDX854"></A>
<A NAME="IDX855"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL CShift'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC126" HREF="g77_toc.html#TOC126">CSin Intrinsic</A></H4>
<P>
<A NAME="IDX856"></A>
<A NAME="IDX857"></A>

</P>
<P>

<PRE>
CSin(<VAR>X</VAR>)
</PRE>

<P>
CSin: <CODE>COMPLEX(KIND=1)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>SIN()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC304">Sin Intrinsic</A>.

</P>


<H4><A NAME="SEC127" HREF="g77_toc.html#TOC127">CSqRt Intrinsic</A></H4>
<P>
<A NAME="IDX858"></A>
<A NAME="IDX859"></A>

</P>
<P>

<PRE>
CSqRt(<VAR>X</VAR>)
</PRE>

<P>
CSqRt: <CODE>COMPLEX(KIND=1)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>SQRT()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC310">SqRt Intrinsic</A>.

</P>


<H4><A NAME="SEC128" HREF="g77_toc.html#TOC128">CTime Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX860"></A>
<A NAME="IDX861"></A>

</P>
<P>

<PRE>
CALL CTime(<VAR>STime</VAR>, <VAR>Result</VAR>)
</PRE>

<P>
<VAR>STime</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Result</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Converts <VAR>STime</VAR>, a system time value, such as returned by
<CODE>TIME8()</CODE>, to a string of the form <SAMP>`Sat Aug 19 18:13:14 1995'</SAMP>,
and returns that string in <VAR>Result</VAR>.

</P>
<P>
See section <A HREF="g77_12.html#SEC321">Time8 Intrinsic</A>.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC129">CTime Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC129" HREF="g77_toc.html#TOC129">CTime Intrinsic (function)</A></H4>
<P>
<A NAME="IDX862"></A>
<A NAME="IDX863"></A>

</P>
<P>

<PRE>
CTime(<VAR>STime</VAR>)
</PRE>

<P>
CTime: <CODE>CHARACTER*(*)</CODE> function.

</P>
<P>
<VAR>STime</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Converts <VAR>STime</VAR>, a system time value, such as returned by
<CODE>TIME8()</CODE>, to a string of the form <SAMP>`Sat Aug 19 18:13:14 1995'</SAMP>,
and returns that string as the function value.

</P>
<P>
See section <A HREF="g77_12.html#SEC321">Time8 Intrinsic</A>.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC128">CTime Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC130" HREF="g77_toc.html#TOC130">DAbs Intrinsic</A></H4>
<P>
<A NAME="IDX864"></A>
<A NAME="IDX865"></A>

</P>
<P>

<PRE>
DAbs(<VAR>A</VAR>)
</PRE>

<P>
DAbs: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ABS()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC77">Abs Intrinsic</A>.

</P>


<H4><A NAME="SEC131" HREF="g77_toc.html#TOC131">DACos Intrinsic</A></H4>
<P>
<A NAME="IDX866"></A>
<A NAME="IDX867"></A>

</P>
<P>

<PRE>
DACos(<VAR>X</VAR>)
</PRE>

<P>
DACos: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ACOS()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC80">ACos Intrinsic</A>.

</P>


<H4><A NAME="SEC132" HREF="g77_toc.html#TOC132">DASin Intrinsic</A></H4>
<P>
<A NAME="IDX868"></A>
<A NAME="IDX869"></A>

</P>
<P>

<PRE>
DASin(<VAR>X</VAR>)
</PRE>

<P>
DASin: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ASIN()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC98">ASin Intrinsic</A>.

</P>


<H4><A NAME="SEC133" HREF="g77_toc.html#TOC133">DATan Intrinsic</A></H4>
<P>
<A NAME="IDX870"></A>
<A NAME="IDX871"></A>

</P>
<P>

<PRE>
DATan(<VAR>X</VAR>)
</PRE>

<P>
DATan: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ATAN()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC100">ATan Intrinsic</A>.

</P>


<H4><A NAME="SEC134" HREF="g77_toc.html#TOC134">DATan2 Intrinsic</A></H4>
<P>
<A NAME="IDX872"></A>
<A NAME="IDX873"></A>

</P>
<P>

<PRE>
DATan2(<VAR>Y</VAR>, <VAR>X</VAR>)
</PRE>

<P>
DATan2: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>Y</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ATAN2()</CODE> that is specific
to one type for <VAR>Y</VAR> and <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC101">ATan2 Intrinsic</A>.

</P>


<H4><A NAME="SEC135" HREF="g77_toc.html#TOC135">Date_and_Time Intrinsic</A></H4>
<P>
<A NAME="IDX874"></A>
<A NAME="IDX875"></A>

</P>
<P>

<PRE>
CALL Date_and_Time(<VAR>Date</VAR>, <VAR>Time</VAR>, <VAR>Zone</VAR>, <VAR>Values</VAR>)
</PRE>

<P>
<VAR>Date</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
<VAR>Time</VAR>: <CODE>CHARACTER</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
<VAR>Zone</VAR>: <CODE>CHARACTER</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
<VAR>Values</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; DIMENSION(8); INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>f90</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns:
<DL COMPACT>

<DT><VAR>Date</VAR>
<DD>
The date in the form <VAR>ccyymmdd</VAR>: century, year, month and day;
<DT><VAR>Time</VAR>
<DD>
The time in the form <SAMP>`<VAR>hhmmss.ss</VAR>'</SAMP>: hours, minutes, seconds
and milliseconds;
<DT><VAR>Zone</VAR>
<DD>
The difference between local time and UTC (GMT) in the form <VAR>Shhmm</VAR>:
sign, hours and minutes, e.g. <SAMP>`-0500'</SAMP> (winter in New York);
<DT><VAR>Values</VAR>
<DD>
The year, month of the year, day of the month, time difference in
minutes from UTC, hour of the day, minutes of the hour, seconds
of the minute, and milliseconds
of the second in successive values of the array.
</DL>

<P>
<A NAME="IDX876"></A>
<A NAME="IDX877"></A>
<A NAME="IDX878"></A>
<A NAME="IDX879"></A>
Programs making use of this intrinsic
might not be Year 10000 (Y10K) compliant.
For example, the date might appear,
to such programs, to wrap around
(change from a larger value to a smaller one)
as of the Year 10000.

</P>
<P>
On systems where a millisecond timer isn't available, the millisecond
value is returned as zero.

</P>


<H4><A NAME="SEC136" HREF="g77_toc.html#TOC136">DbesJ0 Intrinsic</A></H4>
<P>
<A NAME="IDX880"></A>
<A NAME="IDX881"></A>

</P>
<P>

<PRE>
DbesJ0(<VAR>X</VAR>)
</PRE>

<P>
DbesJ0: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>BESJ0()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC102">BesJ0 Intrinsic</A>.

</P>


<H4><A NAME="SEC137" HREF="g77_toc.html#TOC137">DbesJ1 Intrinsic</A></H4>
<P>
<A NAME="IDX882"></A>
<A NAME="IDX883"></A>

</P>
<P>

<PRE>
DbesJ1(<VAR>X</VAR>)
</PRE>

<P>
DbesJ1: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>BESJ1()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC103">BesJ1 Intrinsic</A>.

</P>


<H4><A NAME="SEC138" HREF="g77_toc.html#TOC138">DbesJN Intrinsic</A></H4>
<P>
<A NAME="IDX884"></A>
<A NAME="IDX885"></A>

</P>
<P>

<PRE>
DbesJN(<VAR>N</VAR>, <VAR>X</VAR>)
</PRE>

<P>
DbesJN: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>N</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>BESJN()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC104">BesJN Intrinsic</A>.

</P>


<H4><A NAME="SEC139" HREF="g77_toc.html#TOC139">DbesY0 Intrinsic</A></H4>
<P>
<A NAME="IDX886"></A>
<A NAME="IDX887"></A>

</P>
<P>

<PRE>
DbesY0(<VAR>X</VAR>)
</PRE>

<P>
DbesY0: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>BESY0()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC105">BesY0 Intrinsic</A>.

</P>


<H4><A NAME="SEC140" HREF="g77_toc.html#TOC140">DbesY1 Intrinsic</A></H4>
<P>
<A NAME="IDX888"></A>
<A NAME="IDX889"></A>

</P>
<P>

<PRE>
DbesY1(<VAR>X</VAR>)
</PRE>

<P>
DbesY1: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>BESY1()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC106">BesY1 Intrinsic</A>.

</P>


<H4><A NAME="SEC141" HREF="g77_toc.html#TOC141">DbesYN Intrinsic</A></H4>
<P>
<A NAME="IDX890"></A>
<A NAME="IDX891"></A>

</P>
<P>

<PRE>
DbesYN(<VAR>N</VAR>, <VAR>X</VAR>)
</PRE>

<P>
DbesYN: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>N</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>BESYN()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC107">BesYN Intrinsic</A>.

</P>


<H4><A NAME="SEC142" HREF="g77_toc.html#TOC142">Dble Intrinsic</A></H4>
<P>
<A NAME="IDX892"></A>
<A NAME="IDX893"></A>

</P>
<P>

<PRE>
Dble(<VAR>A</VAR>)
</PRE>

<P>
Dble: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE>, <CODE>REAL</CODE>, or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <VAR>A</VAR> converted to double precision
(<CODE>REAL(KIND=2)</CODE>).
If <VAR>A</VAR> is <CODE>COMPLEX</CODE>, the real part of
<VAR>A</VAR> is used for the conversion
and the imaginary part disregarded.

</P>
<P>
See section <A HREF="g77_12.html#SEC307">Sngl Intrinsic</A>, for the function that converts
to single precision.

</P>
<P>
See section <A HREF="g77_12.html#SEC223">Int Intrinsic</A>, for the function that converts
to <CODE>INTEGER</CODE>.

</P>
<P>
See section <A HREF="g77_12.html#SEC119">Complex Intrinsic</A>, for the function that converts
to <CODE>COMPLEX</CODE>.

</P>


<H4><A NAME="SEC143" HREF="g77_toc.html#TOC143">DCos Intrinsic</A></H4>
<P>
<A NAME="IDX894"></A>
<A NAME="IDX895"></A>

</P>
<P>

<PRE>
DCos(<VAR>X</VAR>)
</PRE>

<P>
DCos: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>COS()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC121">Cos Intrinsic</A>.

</P>


<H4><A NAME="SEC144" HREF="g77_toc.html#TOC144">DCosH Intrinsic</A></H4>
<P>
<A NAME="IDX896"></A>
<A NAME="IDX897"></A>

</P>
<P>

<PRE>
DCosH(<VAR>X</VAR>)
</PRE>

<P>
DCosH: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>COSH()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC122">CosH Intrinsic</A>.

</P>


<H4><A NAME="SEC145" HREF="g77_toc.html#TOC145">DDiM Intrinsic</A></H4>
<P>
<A NAME="IDX898"></A>
<A NAME="IDX899"></A>

</P>
<P>

<PRE>
DDiM(<VAR>X</VAR>, <VAR>Y</VAR>)
</PRE>

<P>
DDiM: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Y</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>DIM()</CODE> that is specific
to one type for <VAR>X</VAR> and <VAR>Y</VAR>.
See section <A HREF="g77_12.html#SEC150">DiM Intrinsic</A>.

</P>


<H4><A NAME="SEC146" HREF="g77_toc.html#TOC146">DErF Intrinsic</A></H4>
<P>
<A NAME="IDX900"></A>
<A NAME="IDX901"></A>

</P>
<P>

<PRE>
DErF(<VAR>X</VAR>)
</PRE>

<P>
DErF: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ERF()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC169">ErF Intrinsic</A>.

</P>


<H4><A NAME="SEC147" HREF="g77_toc.html#TOC147">DErFC Intrinsic</A></H4>
<P>
<A NAME="IDX902"></A>
<A NAME="IDX903"></A>

</P>
<P>

<PRE>
DErFC(<VAR>X</VAR>)
</PRE>

<P>
DErFC: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ERFC()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC170">ErFC Intrinsic</A>.

</P>


<H4><A NAME="SEC148" HREF="g77_toc.html#TOC148">DExp Intrinsic</A></H4>
<P>
<A NAME="IDX904"></A>
<A NAME="IDX905"></A>

</P>
<P>

<PRE>
DExp(<VAR>X</VAR>)
</PRE>

<P>
DExp: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>EXP()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC174">Exp Intrinsic</A>.

</P>


<H4><A NAME="SEC149" HREF="g77_toc.html#TOC149">Digits Intrinsic</A></H4>
<P>
<A NAME="IDX906"></A>
<A NAME="IDX907"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Digits'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC150" HREF="g77_toc.html#TOC150">DiM Intrinsic</A></H4>
<P>
<A NAME="IDX908"></A>
<A NAME="IDX909"></A>

</P>
<P>

<PRE>
DiM(<VAR>X</VAR>, <VAR>Y</VAR>)
</PRE>

<P>
DiM: <CODE>INTEGER</CODE> or <CODE>REAL</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>X</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Y</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <SAMP>`<VAR>X</VAR>-<VAR>Y</VAR>'</SAMP> if <VAR>X</VAR> is greater than
<VAR>Y</VAR>; otherwise returns zero.

</P>


<H4><A NAME="SEC151" HREF="g77_toc.html#TOC151">DInt Intrinsic</A></H4>
<P>
<A NAME="IDX910"></A>
<A NAME="IDX911"></A>

</P>
<P>

<PRE>
DInt(<VAR>A</VAR>)
</PRE>

<P>
DInt: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>AINT()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC84">AInt Intrinsic</A>.

</P>


<H4><A NAME="SEC152" HREF="g77_toc.html#TOC152">DLog Intrinsic</A></H4>
<P>
<A NAME="IDX912"></A>
<A NAME="IDX913"></A>

</P>
<P>

<PRE>
DLog(<VAR>X</VAR>)
</PRE>

<P>
DLog: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>LOG()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC245">Log Intrinsic</A>.

</P>


<H4><A NAME="SEC153" HREF="g77_toc.html#TOC153">DLog10 Intrinsic</A></H4>
<P>
<A NAME="IDX914"></A>
<A NAME="IDX915"></A>

</P>
<P>

<PRE>
DLog10(<VAR>X</VAR>)
</PRE>

<P>
DLog10: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>LOG10()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC246">Log10 Intrinsic</A>.

</P>


<H4><A NAME="SEC154" HREF="g77_toc.html#TOC154">DMax1 Intrinsic</A></H4>
<P>
<A NAME="IDX916"></A>
<A NAME="IDX917"></A>

</P>
<P>

<PRE>
DMax1(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
DMax1: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MAX()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC254">Max Intrinsic</A>.

</P>


<H4><A NAME="SEC155" HREF="g77_toc.html#TOC155">DMin1 Intrinsic</A></H4>
<P>
<A NAME="IDX918"></A>
<A NAME="IDX919"></A>

</P>
<P>

<PRE>
DMin1(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
DMin1: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MIN()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC263">Min Intrinsic</A>.

</P>


<H4><A NAME="SEC156" HREF="g77_toc.html#TOC156">DMod Intrinsic</A></H4>
<P>
<A NAME="IDX920"></A>
<A NAME="IDX921"></A>

</P>
<P>

<PRE>
DMod(<VAR>A</VAR>, <VAR>P</VAR>)
</PRE>

<P>
DMod: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>P</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MOD()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC269">Mod Intrinsic</A>.

</P>


<H4><A NAME="SEC157" HREF="g77_toc.html#TOC157">DNInt Intrinsic</A></H4>
<P>
<A NAME="IDX922"></A>
<A NAME="IDX923"></A>

</P>
<P>

<PRE>
DNInt(<VAR>A</VAR>)
</PRE>

<P>
DNInt: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ANINT()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC96">ANInt Intrinsic</A>.

</P>


<H4><A NAME="SEC158" HREF="g77_toc.html#TOC158">Dot_Product Intrinsic</A></H4>
<P>
<A NAME="IDX924"></A>
<A NAME="IDX925"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Dot_Product'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC159" HREF="g77_toc.html#TOC159">DProd Intrinsic</A></H4>
<P>
<A NAME="IDX926"></A>
<A NAME="IDX927"></A>

</P>
<P>

<PRE>
DProd(<VAR>X</VAR>, <VAR>Y</VAR>)
</PRE>

<P>
DProd: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Y</VAR>: <CODE>REAL(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <SAMP>`DBLE(<VAR>X</VAR>)*DBLE(<VAR>Y</VAR>)'</SAMP>.

</P>


<H4><A NAME="SEC160" HREF="g77_toc.html#TOC160">DSign Intrinsic</A></H4>
<P>
<A NAME="IDX928"></A>
<A NAME="IDX929"></A>

</P>
<P>

<PRE>
DSign(<VAR>A</VAR>, <VAR>B</VAR>)
</PRE>

<P>
DSign: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>B</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>SIGN()</CODE> that is specific
to one type for <VAR>A</VAR> and <VAR>B</VAR>.
See section <A HREF="g77_12.html#SEC302">Sign Intrinsic</A>.

</P>


<H4><A NAME="SEC161" HREF="g77_toc.html#TOC161">DSin Intrinsic</A></H4>
<P>
<A NAME="IDX930"></A>
<A NAME="IDX931"></A>

</P>
<P>

<PRE>
DSin(<VAR>X</VAR>)
</PRE>

<P>
DSin: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>SIN()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC304">Sin Intrinsic</A>.

</P>


<H4><A NAME="SEC162" HREF="g77_toc.html#TOC162">DSinH Intrinsic</A></H4>
<P>
<A NAME="IDX932"></A>
<A NAME="IDX933"></A>

</P>
<P>

<PRE>
DSinH(<VAR>X</VAR>)
</PRE>

<P>
DSinH: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>SINH()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC305">SinH Intrinsic</A>.

</P>


<H4><A NAME="SEC163" HREF="g77_toc.html#TOC163">DSqRt Intrinsic</A></H4>
<P>
<A NAME="IDX934"></A>
<A NAME="IDX935"></A>

</P>
<P>

<PRE>
DSqRt(<VAR>X</VAR>)
</PRE>

<P>
DSqRt: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>SQRT()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC310">SqRt Intrinsic</A>.

</P>


<H4><A NAME="SEC164" HREF="g77_toc.html#TOC164">DTan Intrinsic</A></H4>
<P>
<A NAME="IDX936"></A>
<A NAME="IDX937"></A>

</P>
<P>

<PRE>
DTan(<VAR>X</VAR>)
</PRE>

<P>
DTan: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>TAN()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC318">Tan Intrinsic</A>.

</P>


<H4><A NAME="SEC165" HREF="g77_toc.html#TOC165">DTanH Intrinsic</A></H4>
<P>
<A NAME="IDX938"></A>
<A NAME="IDX939"></A>

</P>
<P>

<PRE>
DTanH(<VAR>X</VAR>)
</PRE>

<P>
DTanH: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>TANH()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC319">TanH Intrinsic</A>.

</P>


<H4><A NAME="SEC166" HREF="g77_toc.html#TOC166">DTime Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX940"></A>
<A NAME="IDX941"></A>

</P>
<P>

<PRE>
CALL DTime(<VAR>TArray</VAR>, <VAR>Result</VAR>)
</PRE>

<P>
<VAR>TArray</VAR>: <CODE>REAL(KIND=1)</CODE>; DIMENSION(2); INTENT(OUT).

</P>
<P>
<VAR>Result</VAR>: <CODE>REAL(KIND=1)</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Initially, return the number of seconds of runtime
since the start of the process's execution
in <VAR>Result</VAR>,
and the user and system components of this in <SAMP>`<VAR>TArray</VAR>(1)'</SAMP>
and <SAMP>`<VAR>TArray</VAR>(2)'</SAMP> respectively.
The value of <VAR>Result</VAR> is equal to <SAMP>`<VAR>TArray</VAR>(1) + <VAR>TArray</VAR>(2)'</SAMP>.

</P>
<P>
Subsequent invocations of <SAMP>`DTIME()'</SAMP> set values based on accumulations
since the previous invocation.

</P>
<P>
<A NAME="IDX942"></A>
<A NAME="IDX943"></A>
On some systems, the underlying timings are represented
using types with sufficiently small limits that overflows
(wraparounds) are possible, such as 32-bit types.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC416">DTime Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC167" HREF="g77_toc.html#TOC167">EOShift Intrinsic</A></H4>
<P>
<A NAME="IDX944"></A>
<A NAME="IDX945"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL EOShift'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC168" HREF="g77_toc.html#TOC168">Epsilon Intrinsic</A></H4>
<P>
<A NAME="IDX946"></A>
<A NAME="IDX947"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Epsilon'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC169" HREF="g77_toc.html#TOC169">ErF Intrinsic</A></H4>
<P>
<A NAME="IDX948"></A>
<A NAME="IDX949"></A>

</P>
<P>

<PRE>
ErF(<VAR>X</VAR>)
</PRE>

<P>
ErF: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the error function of <VAR>X</VAR>.
See <CODE>erf(3m)</CODE>, which provides the implementation.

</P>


<H4><A NAME="SEC170" HREF="g77_toc.html#TOC170">ErFC Intrinsic</A></H4>
<P>
<A NAME="IDX950"></A>
<A NAME="IDX951"></A>

</P>
<P>

<PRE>
ErFC(<VAR>X</VAR>)
</PRE>

<P>
ErFC: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the complementary error function of <VAR>X</VAR>:
<SAMP>`ERFC(R) = 1 - ERF(R)'</SAMP> (except that the result might be more
accurate than explicitly evaluating that formulae would give).
See <CODE>erfc(3m)</CODE>, which provides the implementation.

</P>


<H4><A NAME="SEC171" HREF="g77_toc.html#TOC171">ETime Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX952"></A>
<A NAME="IDX953"></A>

</P>
<P>

<PRE>
CALL ETime(<VAR>TArray</VAR>, <VAR>Result</VAR>)
</PRE>

<P>
<VAR>TArray</VAR>: <CODE>REAL(KIND=1)</CODE>; DIMENSION(2); INTENT(OUT).

</P>
<P>
<VAR>Result</VAR>: <CODE>REAL(KIND=1)</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Return the number of seconds of runtime
since the start of the process's execution
in <VAR>Result</VAR>,
and the user and system components of this in <SAMP>`<VAR>TArray</VAR>(1)'</SAMP>
and <SAMP>`<VAR>TArray</VAR>(2)'</SAMP> respectively.
The value of <VAR>Result</VAR> is equal to <SAMP>`<VAR>TArray</VAR>(1) + <VAR>TArray</VAR>(2)'</SAMP>.

</P>
<P>
<A NAME="IDX954"></A>
<A NAME="IDX955"></A>
On some systems, the underlying timings are represented
using types with sufficiently small limits that overflows
(wraparounds) are possible, such as 32-bit types.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC172">ETime Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC172" HREF="g77_toc.html#TOC172">ETime Intrinsic (function)</A></H4>
<P>
<A NAME="IDX956"></A>
<A NAME="IDX957"></A>

</P>
<P>

<PRE>
ETime(<VAR>TArray</VAR>)
</PRE>

<P>
ETime: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>TArray</VAR>: <CODE>REAL(KIND=1)</CODE>; DIMENSION(2); INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Return the number of seconds of runtime
since the start of the process's execution
as the function value,
and the user and system components of this in <SAMP>`<VAR>TArray</VAR>(1)'</SAMP>
and <SAMP>`<VAR>TArray</VAR>(2)'</SAMP> respectively.
The functions' value is equal to <SAMP>`<VAR>TArray</VAR>(1) + <VAR>TArray</VAR>(2)'</SAMP>.

</P>
<P>
<A NAME="IDX958"></A>
<A NAME="IDX959"></A>
On some systems, the underlying timings are represented
using types with sufficiently small limits that overflows
(wraparounds) are possible, such as 32-bit types.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC171">ETime Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC173" HREF="g77_toc.html#TOC173">Exit Intrinsic</A></H4>
<P>
<A NAME="IDX960"></A>
<A NAME="IDX961"></A>

</P>
<P>

<PRE>
CALL Exit(<VAR>Status</VAR>)
</PRE>

<P>
<VAR>Status</VAR>: <CODE>INTEGER</CODE>; OPTIONAL; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Exit the program with status <VAR>Status</VAR> after closing open Fortran
I/O units and otherwise behaving as <CODE>exit(2)</CODE>.
If <VAR>Status</VAR> is omitted the canonical `success' value
will be returned to the system.

</P>


<H4><A NAME="SEC174" HREF="g77_toc.html#TOC174">Exp Intrinsic</A></H4>
<P>
<A NAME="IDX962"></A>
<A NAME="IDX963"></A>

</P>
<P>

<PRE>
Exp(<VAR>X</VAR>)
</PRE>

<P>
Exp: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE> function, the exact type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <SAMP>`<VAR>e</VAR>**<VAR>X</VAR>'</SAMP>, where
<VAR>e</VAR> is approximately 2.7182818.

</P>
<P>
See section <A HREF="g77_12.html#SEC245">Log Intrinsic</A>, for the inverse of this function.

</P>


<H4><A NAME="SEC175" HREF="g77_toc.html#TOC175">Exponent Intrinsic</A></H4>
<P>
<A NAME="IDX964"></A>
<A NAME="IDX965"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Exponent'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC176" HREF="g77_toc.html#TOC176">FDate Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX966"></A>
<A NAME="IDX967"></A>

</P>
<P>

<PRE>
CALL FDate(<VAR>Date</VAR>)
</PRE>

<P>
<VAR>Date</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the current date (using the same format as <CODE>CTIME()</CODE>)
in <VAR>Date</VAR>.

</P>
<P>
Equivalent to:

</P>

<PRE>
CALL CTIME(<VAR>Date</VAR>, TIME8())
</PRE>

<P>
<A NAME="IDX968"></A>
<A NAME="IDX969"></A>
<A NAME="IDX970"></A>
<A NAME="IDX971"></A>
Programs making use of this intrinsic
might not be Year 10000 (Y10K) compliant.
For example, the date might appear,
to such programs, to wrap around
(change from a larger value to a smaller one)
as of the Year 10000.

</P>
<P>
See section <A HREF="g77_12.html#SEC128">CTime Intrinsic (subroutine)</A>.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC177">FDate Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC177" HREF="g77_toc.html#TOC177">FDate Intrinsic (function)</A></H4>
<P>
<A NAME="IDX972"></A>
<A NAME="IDX973"></A>

</P>
<P>

<PRE>
FDate()
</PRE>

<P>
FDate: <CODE>CHARACTER*(*)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the current date (using the same format as <CODE>CTIME()</CODE>).

</P>
<P>
Equivalent to:

</P>

<PRE>
CTIME(TIME8())
</PRE>

<P>
<A NAME="IDX974"></A>
<A NAME="IDX975"></A>
<A NAME="IDX976"></A>
<A NAME="IDX977"></A>
Programs making use of this intrinsic
might not be Year 10000 (Y10K) compliant.
For example, the date might appear,
to such programs, to wrap around
(change from a larger value to a smaller one)
as of the Year 10000.

</P>
<P>
See section <A HREF="g77_12.html#SEC129">CTime Intrinsic (function)</A>.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC176">FDate Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC178" HREF="g77_toc.html#TOC178">FGet Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX978"></A>
<A NAME="IDX979"></A>

</P>
<P>

<PRE>
CALL FGet(<VAR>C</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>C</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Reads a single character into <VAR>C</VAR> in stream mode from unit 5
(by-passing normal formatted output) using <CODE>getc(3)</CODE>.
Returns in
<VAR>Status</VAR> 0 on success, -1 on end-of-file, and the error code
from <CODE>ferror(3)</CODE> otherwise.

</P>
<P>
Stream I/O should not be mixed with normal record-oriented (formatted or
unformatted) I/O on the same unit; the results are unpredictable.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC417">FGet Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC179" HREF="g77_toc.html#TOC179">FGetC Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX980"></A>
<A NAME="IDX981"></A>

</P>
<P>

<PRE>
CALL FGetC(<VAR>Unit</VAR>, <VAR>C</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>C</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Reads a single character into <VAR>C</VAR> in stream mode from unit <VAR>Unit</VAR>
(by-passing normal formatted output) using <CODE>getc(3)</CODE>.
Returns in
<VAR>Status</VAR> 0 on success, -1 on end-of-file, and the error code from
<CODE>ferror(3)</CODE> otherwise.

</P>
<P>
Stream I/O should not be mixed with normal record-oriented (formatted or
unformatted) I/O on the same unit; the results are unpredictable.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC418">FGetC Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC180" HREF="g77_toc.html#TOC180">Float Intrinsic</A></H4>
<P>
<A NAME="IDX982"></A>
<A NAME="IDX983"></A>

</P>
<P>

<PRE>
Float(<VAR>A</VAR>)
</PRE>

<P>
Float: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>REAL()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC286">Real Intrinsic</A>.

</P>


<H4><A NAME="SEC181" HREF="g77_toc.html#TOC181">Floor Intrinsic</A></H4>
<P>
<A NAME="IDX984"></A>
<A NAME="IDX985"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Floor'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC182" HREF="g77_toc.html#TOC182">Flush Intrinsic</A></H4>
<P>
<A NAME="IDX986"></A>
<A NAME="IDX987"></A>

</P>
<P>

<PRE>
CALL Flush(<VAR>Unit</VAR>)
</PRE>

<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; OPTIONAL; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Flushes Fortran unit(s) currently open for output.
Without the optional argument, all such units are flushed,
otherwise just the unit specified by <VAR>Unit</VAR>.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic
as a library procedure that might or might not support the
(optional) <VAR>Unit</VAR> argument.

</P>


<H4><A NAME="SEC183" HREF="g77_toc.html#TOC183">FNum Intrinsic</A></H4>
<P>
<A NAME="IDX988"></A>
<A NAME="IDX989"></A>

</P>
<P>

<PRE>
FNum(<VAR>Unit</VAR>)
</PRE>

<P>
FNum: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the Unix file descriptor number corresponding to the open
Fortran I/O unit <VAR>Unit</VAR>.
This could be passed to an interface to C I/O routines.

</P>


<H4><A NAME="SEC184" HREF="g77_toc.html#TOC184">FPut Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX990"></A>
<A NAME="IDX991"></A>

</P>
<P>

<PRE>
CALL FPut(<VAR>C</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>C</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Writes the single character <VAR>C</VAR> in stream mode to unit 6
(by-passing normal formatted output) using <CODE>putc(3)</CODE>.
Returns in
<VAR>Status</VAR> 0 on success, the error code from <CODE>ferror(3)</CODE> otherwise.

</P>
<P>
Stream I/O should not be mixed with normal record-oriented (formatted or
unformatted) I/O on the same unit; the results are unpredictable.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC421">FPut Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC185" HREF="g77_toc.html#TOC185">FPutC Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX992"></A>
<A NAME="IDX993"></A>

</P>
<P>

<PRE>
CALL FPutC(<VAR>Unit</VAR>, <VAR>C</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>C</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Writes the single character <VAR>Unit</VAR> in stream mode to unit 6
(by-passing normal formatted output) using <CODE>putc(3)</CODE>.
Returns in
<VAR>C</VAR> 0 on success, the error code from <CODE>ferror(3)</CODE> otherwise.

</P>
<P>
Stream I/O should not be mixed with normal record-oriented (formatted or
unformatted) I/O on the same unit; the results are unpredictable.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC422">FPutC Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC186" HREF="g77_toc.html#TOC186">Fraction Intrinsic</A></H4>
<P>
<A NAME="IDX994"></A>
<A NAME="IDX995"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Fraction'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC187" HREF="g77_toc.html#TOC187">FSeek Intrinsic</A></H4>
<P>
<A NAME="IDX996"></A>
<A NAME="IDX997"></A>

</P>
<P>

<PRE>
CALL FSeek(<VAR>Unit</VAR>, <VAR>Offset</VAR>, <VAR>Whence</VAR>, <VAR>ErrLab</VAR>)
</PRE>

<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Offset</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Whence</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>ErrLab</VAR>: <SAMP>`*<VAR>label</VAR>'</SAMP>, where <VAR>label</VAR> is the label
of an executable statement; OPTIONAL.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Attempts to move Fortran unit <VAR>Unit</VAR> to the specified
<VAR>Offset</VAR>: absolute offset if <VAR>Whence</VAR>=0; relative to the
current offset if <VAR>Whence</VAR>=1; relative to the end of the file if
<VAR>Whence</VAR>=2.
It branches to label <VAR>ErrLab</VAR> if <VAR>Unit</VAR> is
not open or if the call otherwise fails.

</P>


<H4><A NAME="SEC188" HREF="g77_toc.html#TOC188">FStat Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX998"></A>
<A NAME="IDX999"></A>

</P>
<P>

<PRE>
CALL FStat(<VAR>Unit</VAR>, <VAR>SArray</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>SArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(13); INTENT(OUT).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Obtains data about the file open on Fortran I/O unit <VAR>Unit</VAR> and
places them in the array <VAR>SArray</VAR>.
The values in this array are
extracted from the <CODE>stat</CODE> structure as returned by
<CODE>fstat(2)</CODE> q.v., as follows:

</P>

<OL>
<LI>

Device ID

<LI>

Inode number

<LI>

File mode

<LI>

Number of links

<LI>

Owner's uid

<LI>

Owner's gid

<LI>

ID of device containing directory entry for file
(0 if not available)

<LI>

File size (bytes)

<LI>

Last access time

<LI>

Last modification time

<LI>

Last file status change time

<LI>

Preferred I/O block size (-1 if not available)

<LI>

Number of blocks allocated (-1 if not available)
</OL>

<P>
Not all these elements are relevant on all systems.
If an element is not relevant, it is returned as 0.

</P>
<P>
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC189">FStat Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC189" HREF="g77_toc.html#TOC189">FStat Intrinsic (function)</A></H4>
<P>
<A NAME="IDX1000"></A>
<A NAME="IDX1001"></A>

</P>
<P>

<PRE>
FStat(<VAR>Unit</VAR>, <VAR>SArray</VAR>)
</PRE>

<P>
FStat: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>SArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(13); INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Obtains data about the file open on Fortran I/O unit <VAR>Unit</VAR> and
places them in the array <VAR>SArray</VAR>.
The values in this array are
extracted from the <CODE>stat</CODE> structure as returned by
<CODE>fstat(2)</CODE> q.v., as follows:

</P>

<OL>
<LI>

Device ID

<LI>

Inode number

<LI>

File mode

<LI>

Number of links

<LI>

Owner's uid

<LI>

Owner's gid

<LI>

ID of device containing directory entry for file
(0 if not available)

<LI>

File size (bytes)

<LI>

Last access time

<LI>

Last modification time

<LI>

Last file status change time

<LI>

Preferred I/O block size (-1 if not available)

<LI>

Number of blocks allocated (-1 if not available)
</OL>

<P>
Not all these elements are relevant on all systems.
If an element is not relevant, it is returned as 0.

</P>
<P>
Returns 0 on success or a non-zero error code.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC188">FStat Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC190" HREF="g77_toc.html#TOC190">FTell Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1002"></A>
<A NAME="IDX1003"></A>

</P>
<P>

<PRE>
CALL FTell(<VAR>Unit</VAR>, <VAR>Offset</VAR>)
</PRE>

<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Offset</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Sets <VAR>Offset</VAR> to the current offset of Fortran unit <VAR>Unit</VAR>
(or to -1 if <VAR>Unit</VAR> is not open).

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC191">FTell Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC191" HREF="g77_toc.html#TOC191">FTell Intrinsic (function)</A></H4>
<P>
<A NAME="IDX1004"></A>
<A NAME="IDX1005"></A>

</P>
<P>

<PRE>
FTell(<VAR>Unit</VAR>)
</PRE>

<P>
FTell: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the current offset of Fortran unit <VAR>Unit</VAR>
(or -1 if <VAR>Unit</VAR> is not open).

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC190">FTell Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC192" HREF="g77_toc.html#TOC192">GError Intrinsic</A></H4>
<P>
<A NAME="IDX1006"></A>
<A NAME="IDX1007"></A>

</P>
<P>

<PRE>
CALL GError(<VAR>Message</VAR>)
</PRE>

<P>
<VAR>Message</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the system error message corresponding to the last system
error (C <CODE>errno</CODE>).

</P>


<H4><A NAME="SEC193" HREF="g77_toc.html#TOC193">GetArg Intrinsic</A></H4>
<P>
<A NAME="IDX1008"></A>
<A NAME="IDX1009"></A>

</P>
<P>

<PRE>
CALL GetArg(<VAR>Pos</VAR>, <VAR>Value</VAR>)
</PRE>

<P>
<VAR>Pos</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Value</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Sets <VAR>Value</VAR> to the <VAR>Pos</VAR>-th command-line argument (or to all
blanks if there are fewer than <VAR>Value</VAR> command-line arguments);
<CODE>CALL GETARG(0, <VAR>value</VAR>)</CODE> sets <VAR>value</VAR> to the name of the
program (on systems that support this feature).

</P>
<P>
See section <A HREF="g77_12.html#SEC208">IArgC Intrinsic</A>, for information on how to get the number
of arguments.

</P>


<H4><A NAME="SEC194" HREF="g77_toc.html#TOC194">GetCWD Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1010"></A>
<A NAME="IDX1011"></A>

</P>
<P>

<PRE>
CALL GetCWD(<VAR>Name</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Name</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Places the current working directory in <VAR>Name</VAR>.
If the <VAR>Status</VAR> argument is supplied, it contains 0
success or a non-zero error code upon return
(<CODE>ENOSYS</CODE> if the system does not provide <CODE>getcwd(3)</CODE>
or <CODE>getwd(3)</CODE>).

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC195">GetCWD Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC195" HREF="g77_toc.html#TOC195">GetCWD Intrinsic (function)</A></H4>
<P>
<A NAME="IDX1012"></A>
<A NAME="IDX1013"></A>

</P>
<P>

<PRE>
GetCWD(<VAR>Name</VAR>)
</PRE>

<P>
GetCWD: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>Name</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Places the current working directory in <VAR>Name</VAR>.
Returns 0 on
success, otherwise a non-zero error code
(<CODE>ENOSYS</CODE> if the system does not provide <CODE>getcwd(3)</CODE>
or <CODE>getwd(3)</CODE>).

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC194">GetCWD Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC196" HREF="g77_toc.html#TOC196">GetEnv Intrinsic</A></H4>
<P>
<A NAME="IDX1014"></A>
<A NAME="IDX1015"></A>

</P>
<P>

<PRE>
CALL GetEnv(<VAR>Name</VAR>, <VAR>Value</VAR>)
</PRE>

<P>
<VAR>Name</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Value</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Sets <VAR>Value</VAR> to the value of environment variable given by the
value of <VAR>Name</VAR> (<CODE>$name</CODE> in shell terms) or to blanks if
<CODE>$name</CODE> has not been set.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the name in <VAR>Name</VAR>---otherwise,
trailing blanks in <VAR>Name</VAR> are ignored.

</P>


<H4><A NAME="SEC197" HREF="g77_toc.html#TOC197">GetGId Intrinsic</A></H4>
<P>
<A NAME="IDX1016"></A>
<A NAME="IDX1017"></A>

</P>
<P>

<PRE>
GetGId()
</PRE>

<P>
GetGId: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the group id for the current process.

</P>


<H4><A NAME="SEC198" HREF="g77_toc.html#TOC198">GetLog Intrinsic</A></H4>
<P>
<A NAME="IDX1018"></A>
<A NAME="IDX1019"></A>

</P>
<P>

<PRE>
CALL GetLog(<VAR>Login</VAR>)
</PRE>

<P>
<VAR>Login</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the login name for the process in <VAR>Login</VAR>.

</P>
<P>
<EM>Caution:</EM> On some systems, the <CODE>getlogin(3)</CODE>
function, which this intrinsic calls at run time,
is either not implemented or returns a null pointer.
In the latter case, this intrinsic returns blanks
in <VAR>Login</VAR>.

</P>


<H4><A NAME="SEC199" HREF="g77_toc.html#TOC199">GetPId Intrinsic</A></H4>
<P>
<A NAME="IDX1020"></A>
<A NAME="IDX1021"></A>

</P>
<P>

<PRE>
GetPId()
</PRE>

<P>
GetPId: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the process id for the current process.

</P>


<H4><A NAME="SEC200" HREF="g77_toc.html#TOC200">GetUId Intrinsic</A></H4>
<P>
<A NAME="IDX1022"></A>
<A NAME="IDX1023"></A>

</P>
<P>

<PRE>
GetUId()
</PRE>

<P>
GetUId: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the user id for the current process.

</P>


<H4><A NAME="SEC201" HREF="g77_toc.html#TOC201">GMTime Intrinsic</A></H4>
<P>
<A NAME="IDX1024"></A>
<A NAME="IDX1025"></A>

</P>
<P>

<PRE>
CALL GMTime(<VAR>STime</VAR>, <VAR>TArray</VAR>)
</PRE>

<P>
<VAR>STime</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>TArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(9); INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Given a system time value <VAR>STime</VAR>, fills <VAR>TArray</VAR> with values
extracted from it appropriate to the GMT time zone using
<CODE>gmtime(3)</CODE>.

</P>
<P>
The array elements are as follows:

</P>

<OL>
<LI>

Seconds after the minute, range 0--59 or 0--61 to allow for leap
seconds

<LI>

Minutes after the hour, range 0--59

<LI>

Hours past midnight, range 0--23

<LI>

Day of month, range 0--31

<LI>

Number of months since January, range 0--12

<LI>

Years since 1900

<LI>

Number of days since Sunday, range 0--6

<LI>

Days since January 1

<LI>

Daylight savings indicator: positive if daylight savings is in effect,
zero if not, and negative if the information isn't available.
</OL>



<H4><A NAME="SEC202" HREF="g77_toc.html#TOC202">HostNm Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1026"></A>
<A NAME="IDX1027"></A>

</P>
<P>

<PRE>
CALL HostNm(<VAR>Name</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Name</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Fills <VAR>Name</VAR> with the system's host name returned by
<CODE>gethostname(2)</CODE>.
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return
(<CODE>ENOSYS</CODE> if the system does not provide <CODE>gethostname(2)</CODE>).

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
On some systems (specifically SCO) it might be necessary to link the
"socket" library if you call this routine.
Typically this means adding <SAMP>`-lg2c -lsocket -lm'</SAMP>
to the <CODE>g77</CODE> command line when linking the program.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC203">HostNm Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC203" HREF="g77_toc.html#TOC203">HostNm Intrinsic (function)</A></H4>
<P>
<A NAME="IDX1028"></A>
<A NAME="IDX1029"></A>

</P>
<P>

<PRE>
HostNm(<VAR>Name</VAR>)
</PRE>

<P>
HostNm: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>Name</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Fills <VAR>Name</VAR> with the system's host name returned by
<CODE>gethostname(2)</CODE>, returning 0 on success or a non-zero error code
(<CODE>ENOSYS</CODE> if the system does not provide <CODE>gethostname(2)</CODE>).

</P>
<P>
On some systems (specifically SCO) it might be necessary to link the
"socket" library if you call this routine.
Typically this means adding <SAMP>`-lg2c -lsocket -lm'</SAMP>
to the <CODE>g77</CODE> command line when linking the program.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC202">HostNm Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC204" HREF="g77_toc.html#TOC204">Huge Intrinsic</A></H4>
<P>
<A NAME="IDX1030"></A>
<A NAME="IDX1031"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Huge'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC205" HREF="g77_toc.html#TOC205">IAbs Intrinsic</A></H4>
<P>
<A NAME="IDX1032"></A>
<A NAME="IDX1033"></A>

</P>
<P>

<PRE>
IAbs(<VAR>A</VAR>)
</PRE>

<P>
IAbs: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ABS()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC77">Abs Intrinsic</A>.

</P>


<H4><A NAME="SEC206" HREF="g77_toc.html#TOC206">IAChar Intrinsic</A></H4>
<P>
<A NAME="IDX1034"></A>
<A NAME="IDX1035"></A>

</P>
<P>

<PRE>
IAChar(<VAR>C</VAR>)
</PRE>

<P>
IAChar: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>C</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>, <CODE>f90</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the code for the ASCII character in the
first character position of <VAR>C</VAR>.

</P>
<P>
See section <A HREF="g77_12.html#SEC79">AChar Intrinsic</A>, for the inverse of this function.

</P>
<P>
See section <A HREF="g77_12.html#SEC212">IChar Intrinsic</A>, for the function corresponding
to the system's native character set.

</P>


<H4><A NAME="SEC207" HREF="g77_toc.html#TOC207">IAnd Intrinsic</A></H4>
<P>
<A NAME="IDX1036"></A>
<A NAME="IDX1037"></A>

</P>
<P>

<PRE>
IAnd(<VAR>I</VAR>, <VAR>J</VAR>)
</PRE>

<P>
IAnd: <CODE>INTEGER</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>J</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns value resulting from boolean AND of
pair of bits in each of <VAR>I</VAR> and <VAR>J</VAR>.

</P>


<H4><A NAME="SEC208" HREF="g77_toc.html#TOC208">IArgC Intrinsic</A></H4>
<P>
<A NAME="IDX1038"></A>
<A NAME="IDX1039"></A>

</P>
<P>

<PRE>
IArgC()
</PRE>

<P>
IArgC: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the number of command-line arguments.

</P>
<P>
This count does not include the specification of the program
name itself.

</P>


<H4><A NAME="SEC209" HREF="g77_toc.html#TOC209">IBClr Intrinsic</A></H4>
<P>
<A NAME="IDX1040"></A>
<A NAME="IDX1041"></A>

</P>
<P>

<PRE>
IBClr(<VAR>I</VAR>, <VAR>Pos</VAR>)
</PRE>

<P>
IBClr: <CODE>INTEGER</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>I</VAR>.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Pos</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the value of <VAR>I</VAR> with bit <VAR>Pos</VAR> cleared (set to
zero).
See section <A HREF="g77_12.html#SEC109">BTest Intrinsic</A>, for information on bit positions.

</P>


<H4><A NAME="SEC210" HREF="g77_toc.html#TOC210">IBits Intrinsic</A></H4>
<P>
<A NAME="IDX1042"></A>
<A NAME="IDX1043"></A>

</P>
<P>

<PRE>
IBits(<VAR>I</VAR>, <VAR>Pos</VAR>, <VAR>Len</VAR>)
</PRE>

<P>
IBits: <CODE>INTEGER</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>I</VAR>.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Pos</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Len</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
Extracts a subfield of length <VAR>Len</VAR> from <VAR>I</VAR>, starting from
bit position <VAR>Pos</VAR> and extending left for <VAR>Len</VAR> bits.
The result is right-justified and the remaining bits are zeroed.
The value
of <SAMP>`<VAR>Pos</VAR>+<VAR>Len</VAR>'</SAMP> must be less than or equal to the value
<SAMP>`BIT_SIZE(<VAR>I</VAR>)'</SAMP>.
See section <A HREF="g77_12.html#SEC108">Bit_Size Intrinsic</A>.

</P>


<H4><A NAME="SEC211" HREF="g77_toc.html#TOC211">IBSet Intrinsic</A></H4>
<P>
<A NAME="IDX1044"></A>
<A NAME="IDX1045"></A>

</P>
<P>

<PRE>
IBSet(<VAR>I</VAR>, <VAR>Pos</VAR>)
</PRE>

<P>
IBSet: <CODE>INTEGER</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>I</VAR>.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Pos</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the value of <VAR>I</VAR> with bit <VAR>Pos</VAR> set (to one).
See section <A HREF="g77_12.html#SEC109">BTest Intrinsic</A>, for information on bit positions.

</P>


<H4><A NAME="SEC212" HREF="g77_toc.html#TOC212">IChar Intrinsic</A></H4>
<P>
<A NAME="IDX1046"></A>
<A NAME="IDX1047"></A>

</P>
<P>

<PRE>
IChar(<VAR>C</VAR>)
</PRE>

<P>
IChar: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>C</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the code for the character in the
first character position of <VAR>C</VAR>.

</P>
<P>
Because the system's native character set is used,
the correspondence between character and their codes
is not necessarily the same between GNU Fortran
implementations.

</P>
<P>
Note that no intrinsic exists to convert a printable
character string to a numerical value.
For example, there is no intrinsic that, given
the <CODE>CHARACTER</CODE> value <SAMP>`'154''</SAMP>, returns an
<CODE>INTEGER</CODE> or <CODE>REAL</CODE> value with the value <SAMP>`154'</SAMP>.

</P>
<P>
Instead, you can use internal-file I/O to do this kind
of conversion.
For example:

</P>

<PRE>
INTEGER VALUE
CHARACTER*10 STRING
STRING = '154'
READ (STRING, '(I10)'), VALUE
PRINT *, VALUE
END
</PRE>

<P>
The above program, when run, prints:

</P>

<PRE>
 154
</PRE>

<P>
See section <A HREF="g77_12.html#SEC114">Char Intrinsic</A>, for the inverse of the <CODE>ICHAR</CODE> function.

</P>
<P>
See section <A HREF="g77_12.html#SEC206">IAChar Intrinsic</A>, for the function corresponding
to the ASCII character set.

</P>


<H4><A NAME="SEC213" HREF="g77_toc.html#TOC213">IDate Intrinsic (UNIX)</A></H4>
<P>
<A NAME="IDX1048"></A>
<A NAME="IDX1049"></A>

</P>
<P>

<PRE>
CALL IDate(<VAR>TArray</VAR>)
</PRE>

<P>
<VAR>TArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(3); INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Fills <VAR>TArray</VAR> with the numerical values at the current local time
of day, month (in the range 1--12), and year in elements 1, 2, and 3,
respectively.
The year has four significant digits.

</P>
<P>
<A NAME="IDX1050"></A>
<A NAME="IDX1051"></A>
<A NAME="IDX1052"></A>
<A NAME="IDX1053"></A>
Programs making use of this intrinsic
might not be Year 10000 (Y10K) compliant.
For example, the date might appear,
to such programs, to wrap around
(change from a larger value to a smaller one)
as of the Year 10000.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC423">IDate Intrinsic (VXT)</A>.

</P>


<H4><A NAME="SEC214" HREF="g77_toc.html#TOC214">IDiM Intrinsic</A></H4>
<P>
<A NAME="IDX1054"></A>
<A NAME="IDX1055"></A>

</P>
<P>

<PRE>
IDiM(<VAR>X</VAR>, <VAR>Y</VAR>)
</PRE>

<P>
IDiM: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Y</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>DIM()</CODE> that is specific
to one type for <VAR>X</VAR> and <VAR>Y</VAR>.
See section <A HREF="g77_12.html#SEC150">DiM Intrinsic</A>.

</P>


<H4><A NAME="SEC215" HREF="g77_toc.html#TOC215">IDInt Intrinsic</A></H4>
<P>
<A NAME="IDX1056"></A>
<A NAME="IDX1057"></A>

</P>
<P>

<PRE>
IDInt(<VAR>A</VAR>)
</PRE>

<P>
IDInt: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>INT()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC223">Int Intrinsic</A>.

</P>


<H4><A NAME="SEC216" HREF="g77_toc.html#TOC216">IDNInt Intrinsic</A></H4>
<P>
<A NAME="IDX1058"></A>
<A NAME="IDX1059"></A>

</P>
<P>

<PRE>
IDNInt(<VAR>A</VAR>)
</PRE>

<P>
IDNInt: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>NINT()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC273">NInt Intrinsic</A>.

</P>


<H4><A NAME="SEC217" HREF="g77_toc.html#TOC217">IEOr Intrinsic</A></H4>
<P>
<A NAME="IDX1060"></A>
<A NAME="IDX1061"></A>

</P>
<P>

<PRE>
IEOr(<VAR>I</VAR>, <VAR>J</VAR>)
</PRE>

<P>
IEOr: <CODE>INTEGER</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>J</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns value resulting from boolean exclusive-OR of
pair of bits in each of <VAR>I</VAR> and <VAR>J</VAR>.

</P>


<H4><A NAME="SEC218" HREF="g77_toc.html#TOC218">IErrNo Intrinsic</A></H4>
<P>
<A NAME="IDX1062"></A>
<A NAME="IDX1063"></A>

</P>
<P>

<PRE>
IErrNo()
</PRE>

<P>
IErrNo: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the last system error number (corresponding to the C
<CODE>errno</CODE>).

</P>


<H4><A NAME="SEC219" HREF="g77_toc.html#TOC219">IFix Intrinsic</A></H4>
<P>
<A NAME="IDX1064"></A>
<A NAME="IDX1065"></A>

</P>
<P>

<PRE>
IFix(<VAR>A</VAR>)
</PRE>

<P>
IFix: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>INT()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC223">Int Intrinsic</A>.

</P>


<H4><A NAME="SEC220" HREF="g77_toc.html#TOC220">Imag Intrinsic</A></H4>
<P>
<A NAME="IDX1066"></A>
<A NAME="IDX1067"></A>

</P>
<P>

<PRE>
Imag(<VAR>Z</VAR>)
</PRE>

<P>
Imag: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>Z</VAR>.

</P>
<P>
<VAR>Z</VAR>: <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
The imaginary part of <VAR>Z</VAR> is returned, without conversion.

</P>
<P>
<EM>Note:</EM> The way to do this in standard Fortran 90
is <SAMP>`AIMAG(<VAR>Z</VAR>)'</SAMP>.
However, when, for example, <VAR>Z</VAR> is <CODE>DOUBLE COMPLEX</CODE>,
<SAMP>`AIMAG(<VAR>Z</VAR>)'</SAMP> means something different for some compilers
that are not true Fortran 90 compilers but offer some
extensions standardized by Fortran 90 (such as the
<CODE>DOUBLE COMPLEX</CODE> type, also known as <CODE>COMPLEX(KIND=2)</CODE>).

</P>
<P>
The advantage of <CODE>IMAG()</CODE> is that, while not necessarily
more or less portable than <CODE>AIMAG()</CODE>, it is more likely to
cause a compiler that doesn't support it to produce a diagnostic
than generate incorrect code.

</P>
<P>
See section <A HREF="g77_12.html#SEC71"><CODE>REAL()</CODE> and <CODE>AIMAG()</CODE> of Complex</A>, for more information.

</P>


<H4><A NAME="SEC221" HREF="g77_toc.html#TOC221">ImagPart Intrinsic</A></H4>
<P>
<A NAME="IDX1068"></A>
<A NAME="IDX1069"></A>

</P>
<P>

<PRE>
ImagPart(<VAR>Z</VAR>)
</PRE>

<P>
ImagPart: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>Z</VAR>.

</P>
<P>
<VAR>Z</VAR>: <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>gnu</CODE>.

</P>
<P>
Description:

</P>
<P>
The imaginary part of <VAR>Z</VAR> is returned, without conversion.

</P>
<P>
<EM>Note:</EM> The way to do this in standard Fortran 90
is <SAMP>`AIMAG(<VAR>Z</VAR>)'</SAMP>.
However, when, for example, <VAR>Z</VAR> is <CODE>DOUBLE COMPLEX</CODE>,
<SAMP>`AIMAG(<VAR>Z</VAR>)'</SAMP> means something different for some compilers
that are not true Fortran 90 compilers but offer some
extensions standardized by Fortran 90 (such as the
<CODE>DOUBLE COMPLEX</CODE> type, also known as <CODE>COMPLEX(KIND=2)</CODE>).

</P>
<P>
The advantage of <CODE>IMAGPART()</CODE> is that, while not necessarily
more or less portable than <CODE>AIMAG()</CODE>, it is more likely to
cause a compiler that doesn't support it to produce a diagnostic
than generate incorrect code.

</P>
<P>
See section <A HREF="g77_12.html#SEC71"><CODE>REAL()</CODE> and <CODE>AIMAG()</CODE> of Complex</A>, for more information.

</P>


<H4><A NAME="SEC222" HREF="g77_toc.html#TOC222">Index Intrinsic</A></H4>
<P>
<A NAME="IDX1070"></A>
<A NAME="IDX1071"></A>

</P>
<P>

<PRE>
Index(<VAR>String</VAR>, <VAR>Substring</VAR>)
</PRE>

<P>
Index: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>String</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Substring</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the position of the start of the first occurrence of string
<VAR>Substring</VAR> as a substring in <VAR>String</VAR>, counting from one.
If <VAR>Substring</VAR> doesn't occur in <VAR>String</VAR>, zero is returned.

</P>


<H4><A NAME="SEC223" HREF="g77_toc.html#TOC223">Int Intrinsic</A></H4>
<P>
<A NAME="IDX1072"></A>
<A NAME="IDX1073"></A>

</P>
<P>

<PRE>
Int(<VAR>A</VAR>)
</PRE>

<P>
Int: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE>, <CODE>REAL</CODE>, or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <VAR>A</VAR> with the fractional portion of its
magnitude truncated and its sign preserved, converted
to type <CODE>INTEGER(KIND=1)</CODE>.

</P>
<P>
If <VAR>A</VAR> is type <CODE>COMPLEX</CODE>, its real part is
truncated and converted, and its imaginary part is disregarded.

</P>
<P>
See section <A HREF="g77_12.html#SEC273">NInt Intrinsic</A>, for how to convert, rounded to nearest
whole number.

</P>
<P>
See section <A HREF="g77_12.html#SEC84">AInt Intrinsic</A>, for how to truncate to whole number
without converting.

</P>


<H4><A NAME="SEC224" HREF="g77_toc.html#TOC224">Int2 Intrinsic</A></H4>
<P>
<A NAME="IDX1074"></A>
<A NAME="IDX1075"></A>

</P>
<P>

<PRE>
Int2(<VAR>A</VAR>)
</PRE>

<P>
Int2: <CODE>INTEGER(KIND=6)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE>, <CODE>REAL</CODE>, or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>gnu</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns <VAR>A</VAR> with the fractional portion of its
magnitude truncated and its sign preserved, converted
to type <CODE>INTEGER(KIND=6)</CODE>.

</P>
<P>
If <VAR>A</VAR> is type <CODE>COMPLEX</CODE>, its real part
is truncated and converted, and its imaginary part is disgregarded.

</P>
<P>
See section <A HREF="g77_12.html#SEC223">Int Intrinsic</A>.

</P>
<P>
The precise meaning of this intrinsic might change
in a future version of the GNU Fortran language,
as more is learned about how it is used.

</P>


<H4><A NAME="SEC225" HREF="g77_toc.html#TOC225">Int8 Intrinsic</A></H4>
<P>
<A NAME="IDX1076"></A>
<A NAME="IDX1077"></A>

</P>
<P>

<PRE>
Int8(<VAR>A</VAR>)
</PRE>

<P>
Int8: <CODE>INTEGER(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE>, <CODE>REAL</CODE>, or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>gnu</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns <VAR>A</VAR> with the fractional portion of its
magnitude truncated and its sign preserved, converted
to type <CODE>INTEGER(KIND=2)</CODE>.

</P>
<P>
If <VAR>A</VAR> is type <CODE>COMPLEX</CODE>, its real part
is truncated and converted, and its imaginary part is disgregarded.

</P>
<P>
See section <A HREF="g77_12.html#SEC223">Int Intrinsic</A>.

</P>
<P>
The precise meaning of this intrinsic might change
in a future version of the GNU Fortran language,
as more is learned about how it is used.

</P>


<H4><A NAME="SEC226" HREF="g77_toc.html#TOC226">IOr Intrinsic</A></H4>
<P>
<A NAME="IDX1078"></A>
<A NAME="IDX1079"></A>

</P>
<P>

<PRE>
IOr(<VAR>I</VAR>, <VAR>J</VAR>)
</PRE>

<P>
IOr: <CODE>INTEGER</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>J</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns value resulting from boolean OR of
pair of bits in each of <VAR>I</VAR> and <VAR>J</VAR>.

</P>


<H4><A NAME="SEC227" HREF="g77_toc.html#TOC227">IRand Intrinsic</A></H4>
<P>
<A NAME="IDX1080"></A>
<A NAME="IDX1081"></A>

</P>
<P>

<PRE>
IRand(<VAR>Flag</VAR>)
</PRE>

<P>
IRand: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>Flag</VAR>: <CODE>INTEGER</CODE>; OPTIONAL; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns a uniform quasi-random number up to a system-dependent limit.
If <VAR>Flag</VAR> is 0, the next number in sequence is returned; if
<VAR>Flag</VAR> is 1, the generator is restarted by calling the UNIX function
<SAMP>`srand(0)'</SAMP>; if <VAR>Flag</VAR> has any other value,
it is used as a new seed with <CODE>srand()</CODE>.

</P>
<P>
See section <A HREF="g77_12.html#SEC311">SRand Intrinsic</A>.

</P>
<P>
<EM>Note:</EM> As typically implemented (by the routine of the same
name in the C library), this random number generator is a very poor
one, though the BSD and GNU libraries provide a much better
implementation than the `traditional' one.
On a different system you almost certainly want to use something better.

</P>


<H4><A NAME="SEC228" HREF="g77_toc.html#TOC228">IsaTty Intrinsic</A></H4>
<P>
<A NAME="IDX1082"></A>
<A NAME="IDX1083"></A>

</P>
<P>

<PRE>
IsaTty(<VAR>Unit</VAR>)
</PRE>

<P>
IsaTty: <CODE>LOGICAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns <CODE>.TRUE.</CODE> if and only if the Fortran I/O unit
specified by <VAR>Unit</VAR> is connected
to a terminal device.
See <CODE>isatty(3)</CODE>.

</P>


<H4><A NAME="SEC229" HREF="g77_toc.html#TOC229">IShft Intrinsic</A></H4>
<P>
<A NAME="IDX1084"></A>
<A NAME="IDX1085"></A>

</P>
<P>

<PRE>
IShft(<VAR>I</VAR>, <VAR>Shift</VAR>)
</PRE>

<P>
IShft: <CODE>INTEGER</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>I</VAR>.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Shift</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
All bits representing <VAR>I</VAR> are shifted <VAR>Shift</VAR> places.
<SAMP>`<VAR>Shift</VAR>.GT.0'</SAMP> indicates a left shift, <SAMP>`<VAR>Shift</VAR>.EQ.0'</SAMP>
indicates no shift and <SAMP>`<VAR>Shift</VAR>.LT.0'</SAMP> indicates a right shift.
If the absolute value of the shift count is greater than
<SAMP>`BIT_SIZE(<VAR>I</VAR>)'</SAMP>, the result is undefined.
Bits shifted out from the left end or the right end are lost.
Zeros are shifted in from the opposite end.

</P>
<P>
See section <A HREF="g77_12.html#SEC230">IShftC Intrinsic</A>, for the circular-shift equivalent.

</P>


<H4><A NAME="SEC230" HREF="g77_toc.html#TOC230">IShftC Intrinsic</A></H4>
<P>
<A NAME="IDX1086"></A>
<A NAME="IDX1087"></A>

</P>
<P>

<PRE>
IShftC(<VAR>I</VAR>, <VAR>Shift</VAR>, <VAR>Size</VAR>)
</PRE>

<P>
IShftC: <CODE>INTEGER</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>I</VAR>.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Shift</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Size</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
The rightmost <VAR>Size</VAR> bits of the argument <VAR>I</VAR>
are shifted circularly <VAR>Shift</VAR>
places, i.e. the bits shifted out of one end are shifted into 
the opposite end.
No bits are lost.
The unshifted bits of the result are the same as
the unshifted bits of <VAR>I</VAR>.
The  absolute value of the argument <VAR>Shift</VAR>
must be less than or equal to <VAR>Size</VAR>.  
The value of <VAR>Size</VAR> must be greater than or equal to one and less than 
or equal to <SAMP>`BIT_SIZE(<VAR>I</VAR>)'</SAMP>.

</P>
<P>
See section <A HREF="g77_12.html#SEC229">IShft Intrinsic</A>, for the logical shift equivalent.

</P>


<H4><A NAME="SEC231" HREF="g77_toc.html#TOC231">ISign Intrinsic</A></H4>
<P>
<A NAME="IDX1088"></A>
<A NAME="IDX1089"></A>

</P>
<P>

<PRE>
ISign(<VAR>A</VAR>, <VAR>B</VAR>)
</PRE>

<P>
ISign: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>B</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>SIGN()</CODE> that is specific
to one type for <VAR>A</VAR> and <VAR>B</VAR>.
See section <A HREF="g77_12.html#SEC302">Sign Intrinsic</A>.

</P>


<H4><A NAME="SEC232" HREF="g77_toc.html#TOC232">ITime Intrinsic</A></H4>
<P>
<A NAME="IDX1090"></A>
<A NAME="IDX1091"></A>

</P>
<P>

<PRE>
CALL ITime(<VAR>TArray</VAR>)
</PRE>

<P>
<VAR>TArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(3); INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the current local time hour, minutes, and seconds in elements
1, 2, and 3 of <VAR>TArray</VAR>, respectively.

</P>


<H4><A NAME="SEC233" HREF="g77_toc.html#TOC233">Kill Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1092"></A>
<A NAME="IDX1093"></A>

</P>
<P>

<PRE>
CALL Kill(<VAR>Pid</VAR>, <VAR>Signal</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Pid</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Signal</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Sends the signal specified by <VAR>Signal</VAR> to the process <VAR>Pid</VAR>.
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return.
See <CODE>kill(2)</CODE>.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC473">Kill Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC234" HREF="g77_toc.html#TOC234">Kind Intrinsic</A></H4>
<P>
<A NAME="IDX1094"></A>
<A NAME="IDX1095"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Kind'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC235" HREF="g77_toc.html#TOC235">LBound Intrinsic</A></H4>
<P>
<A NAME="IDX1096"></A>
<A NAME="IDX1097"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL LBound'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC236" HREF="g77_toc.html#TOC236">Len Intrinsic</A></H4>
<P>
<A NAME="IDX1098"></A>
<A NAME="IDX1099"></A>

</P>
<P>

<PRE>
Len(<VAR>String</VAR>)
</PRE>

<P>
Len: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>String</VAR>: <CODE>CHARACTER</CODE>; scalar.

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the length of <VAR>String</VAR>.

</P>
<P>
If <VAR>String</VAR> is an array, the length of an element
of <VAR>String</VAR> is returned.

</P>
<P>
Note that <VAR>String</VAR> need not be defined when this
intrinsic is invoked, since only the length, not
the content, of <VAR>String</VAR> is needed.

</P>
<P>
See section <A HREF="g77_12.html#SEC108">Bit_Size Intrinsic</A>, for the function that determines
the size of its argument in bits.

</P>


<H4><A NAME="SEC237" HREF="g77_toc.html#TOC237">Len_Trim Intrinsic</A></H4>
<P>
<A NAME="IDX1100"></A>
<A NAME="IDX1101"></A>

</P>
<P>

<PRE>
Len_Trim(<VAR>String</VAR>)
</PRE>

<P>
Len_Trim: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>String</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f90</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the index of the last non-blank character in <VAR>String</VAR>.
<CODE>LNBLNK</CODE> and <CODE>LEN_TRIM</CODE> are equivalent.

</P>


<H4><A NAME="SEC238" HREF="g77_toc.html#TOC238">LGe Intrinsic</A></H4>
<P>
<A NAME="IDX1102"></A>
<A NAME="IDX1103"></A>

</P>
<P>

<PRE>
LGe(<VAR>String_A</VAR>, <VAR>String_B</VAR>)
</PRE>

<P>
LGe: <CODE>LOGICAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>String_A</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>String_B</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <SAMP>`.TRUE.'</SAMP> if <SAMP>`<VAR>String_A</VAR>.GE.<VAR>String_B</VAR>'</SAMP>,
<SAMP>`.FALSE.'</SAMP> otherwise.
<VAR>String_A</VAR> and <VAR>String_B</VAR> are interpreted as containing
ASCII character codes.
If either value contains a character not in the ASCII
character set, the result is processor dependent.

</P>
<P>
If the <VAR>String_A</VAR> and <VAR>String_B</VAR> are not the same length,
the shorter is compared as if spaces were appended to
it to form a value that has the same length as the longer.

</P>
<P>
The lexical comparison intrinsics <CODE>LGe</CODE>, <CODE>LGt</CODE>,
<CODE>LLe</CODE>, and <CODE>LLt</CODE> differ from the corresponding
intrinsic operators <CODE>.GE.</CODE>, <CODE>.GT.</CODE>,
<CODE>.LE.</CODE>, <CODE>.LT.</CODE>.
Because the ASCII collating sequence is assumed,
the following expressions always return <SAMP>`.TRUE.'</SAMP>:

</P>

<PRE>
LGE ('0', ' ')
LGE ('A', '0')
LGE ('a', 'A')
</PRE>

<P>
The following related expressions do <EM>not</EM> always
return <SAMP>`.TRUE.'</SAMP>, as they are not necessarily evaluated
assuming the arguments use ASCII encoding:

</P>

<PRE>
'0' .GE. ' '
'A' .GE. '0'
'a' .GE. 'A'
</PRE>

<P>
The same difference exists
between <CODE>LGt</CODE> and <CODE>.GT.</CODE>;
between <CODE>LLe</CODE> and <CODE>.LE.</CODE>; and
between <CODE>LLt</CODE> and <CODE>.LT.</CODE>.

</P>


<H4><A NAME="SEC239" HREF="g77_toc.html#TOC239">LGt Intrinsic</A></H4>
<P>
<A NAME="IDX1104"></A>
<A NAME="IDX1105"></A>

</P>
<P>

<PRE>
LGt(<VAR>String_A</VAR>, <VAR>String_B</VAR>)
</PRE>

<P>
LGt: <CODE>LOGICAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>String_A</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>String_B</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <SAMP>`.TRUE.'</SAMP> if <SAMP>`<VAR>String_A</VAR>.GT.<VAR>String_B</VAR>'</SAMP>,
<SAMP>`.FALSE.'</SAMP> otherwise.
<VAR>String_A</VAR> and <VAR>String_B</VAR> are interpreted as containing
ASCII character codes.
If either value contains a character not in the ASCII
character set, the result is processor dependent.

</P>
<P>
If the <VAR>String_A</VAR> and <VAR>String_B</VAR> are not the same length,
the shorter is compared as if spaces were appended to
it to form a value that has the same length as the longer.

</P>
<P>
See section <A HREF="g77_12.html#SEC238">LGe Intrinsic</A>, for information on the distinction
between the <CODE>LGT</CODE> intrinsic and the <CODE>.GT.</CODE>
operator.

</P>


<H4><A NAME="SEC240" HREF="g77_toc.html#TOC240">Link Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1106"></A>
<A NAME="IDX1107"></A>

</P>
<P>

<PRE>
CALL Link(<VAR>Path1</VAR>, <VAR>Path2</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Path1</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Path2</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Makes a (hard) link from file <VAR>Path1</VAR> to <VAR>Path2</VAR>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the names in <VAR>Path1</VAR> and <VAR>Path2</VAR>---otherwise,
trailing blanks in <VAR>Path1</VAR> and <VAR>Path2</VAR> are ignored.
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return.
See <CODE>link(2)</CODE>.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC474">Link Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC241" HREF="g77_toc.html#TOC241">LLe Intrinsic</A></H4>
<P>
<A NAME="IDX1108"></A>
<A NAME="IDX1109"></A>

</P>
<P>

<PRE>
LLe(<VAR>String_A</VAR>, <VAR>String_B</VAR>)
</PRE>

<P>
LLe: <CODE>LOGICAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>String_A</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>String_B</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <SAMP>`.TRUE.'</SAMP> if <SAMP>`<VAR>String_A</VAR>.LE.<VAR>String_B</VAR>'</SAMP>,
<SAMP>`.FALSE.'</SAMP> otherwise.
<VAR>String_A</VAR> and <VAR>String_B</VAR> are interpreted as containing
ASCII character codes.
If either value contains a character not in the ASCII
character set, the result is processor dependent.

</P>
<P>
If the <VAR>String_A</VAR> and <VAR>String_B</VAR> are not the same length,
the shorter is compared as if spaces were appended to
it to form a value that has the same length as the longer.

</P>
<P>
See section <A HREF="g77_12.html#SEC238">LGe Intrinsic</A>, for information on the distinction
between the <CODE>LLE</CODE> intrinsic and the <CODE>.LE.</CODE>
operator.

</P>


<H4><A NAME="SEC242" HREF="g77_toc.html#TOC242">LLt Intrinsic</A></H4>
<P>
<A NAME="IDX1110"></A>
<A NAME="IDX1111"></A>

</P>
<P>

<PRE>
LLt(<VAR>String_A</VAR>, <VAR>String_B</VAR>)
</PRE>

<P>
LLt: <CODE>LOGICAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>String_A</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>String_B</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <SAMP>`.TRUE.'</SAMP> if <SAMP>`<VAR>String_A</VAR>.LT.<VAR>String_B</VAR>'</SAMP>,
<SAMP>`.FALSE.'</SAMP> otherwise.
<VAR>String_A</VAR> and <VAR>String_B</VAR> are interpreted as containing
ASCII character codes.
If either value contains a character not in the ASCII
character set, the result is processor dependent.

</P>
<P>
If the <VAR>String_A</VAR> and <VAR>String_B</VAR> are not the same length,
the shorter is compared as if spaces were appended to
it to form a value that has the same length as the longer.

</P>
<P>
See section <A HREF="g77_12.html#SEC238">LGe Intrinsic</A>, for information on the distinction
between the <CODE>LLT</CODE> intrinsic and the <CODE>.LT.</CODE>
operator.

</P>


<H4><A NAME="SEC243" HREF="g77_toc.html#TOC243">LnBlnk Intrinsic</A></H4>
<P>
<A NAME="IDX1112"></A>
<A NAME="IDX1113"></A>

</P>
<P>

<PRE>
LnBlnk(<VAR>String</VAR>)
</PRE>

<P>
LnBlnk: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>String</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the index of the last non-blank character in <VAR>String</VAR>.
<CODE>LNBLNK</CODE> and <CODE>LEN_TRIM</CODE> are equivalent.

</P>


<H4><A NAME="SEC244" HREF="g77_toc.html#TOC244">Loc Intrinsic</A></H4>
<P>
<A NAME="IDX1114"></A>
<A NAME="IDX1115"></A>

</P>
<P>

<PRE>
Loc(<VAR>Entity</VAR>)
</PRE>

<P>
Loc: <CODE>INTEGER(KIND=7)</CODE> function.

</P>
<P>
<VAR>Entity</VAR>: Any type; cannot be a constant or expression.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
The <CODE>LOC()</CODE> intrinsic works the
same way as the <CODE>%LOC()</CODE> construct.
See section <A HREF="g77_12.html#SEC57">The <CODE>%LOC()</CODE> Construct</A>, for
more information.

</P>


<H4><A NAME="SEC245" HREF="g77_toc.html#TOC245">Log Intrinsic</A></H4>
<P>
<A NAME="IDX1116"></A>
<A NAME="IDX1117"></A>

</P>
<P>

<PRE>
Log(<VAR>X</VAR>)
</PRE>

<P>
Log: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE> function, the exact type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the natural logarithm of <VAR>X</VAR>, which must
be greater than zero or, if type <CODE>COMPLEX</CODE>, must not
be zero.

</P>
<P>
See section <A HREF="g77_12.html#SEC174">Exp Intrinsic</A>, for the inverse of this function.

</P>
<P>
See section <A HREF="g77_12.html#SEC246">Log10 Intrinsic</A>, for the `common' (base-10) logarithm function.

</P>


<H4><A NAME="SEC246" HREF="g77_toc.html#TOC246">Log10 Intrinsic</A></H4>
<P>
<A NAME="IDX1118"></A>
<A NAME="IDX1119"></A>

</P>
<P>

<PRE>
Log10(<VAR>X</VAR>)
</PRE>

<P>
Log10: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the common logarithm (base 10) of <VAR>X</VAR>, which must
be greater than zero.

</P>
<P>
The inverse of this function is <SAMP>`10. ** LOG10(<VAR>X</VAR>)'</SAMP>.

</P>
<P>
See section <A HREF="g77_12.html#SEC245">Log Intrinsic</A>, for the natural logarithm function.

</P>


<H4><A NAME="SEC247" HREF="g77_toc.html#TOC247">Logical Intrinsic</A></H4>
<P>
<A NAME="IDX1120"></A>
<A NAME="IDX1121"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Logical'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC248" HREF="g77_toc.html#TOC248">Long Intrinsic</A></H4>
<P>
<A NAME="IDX1122"></A>
<A NAME="IDX1123"></A>

</P>
<P>

<PRE>
Long(<VAR>A</VAR>)
</PRE>

<P>
Long: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER(KIND=6)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>INT()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC223">Int Intrinsic</A>.

</P>
<P>
The precise meaning of this intrinsic might change
in a future version of the GNU Fortran language,
as more is learned about how it is used.

</P>


<H4><A NAME="SEC249" HREF="g77_toc.html#TOC249">LShift Intrinsic</A></H4>
<P>
<A NAME="IDX1124"></A>
<A NAME="IDX1125"></A>

</P>
<P>

<PRE>
LShift(<VAR>I</VAR>, <VAR>Shift</VAR>)
</PRE>

<P>
LShift: <CODE>INTEGER</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>I</VAR>.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Shift</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns <VAR>I</VAR> shifted to the left
<VAR>Shift</VAR> bits.

</P>
<P>
Although similar to the expression
<SAMP>`<VAR>I</VAR>*(2**<VAR>Shift</VAR>)'</SAMP>, there
are important differences.
For example, the sign of the result is
not necessarily the same as the sign of
<VAR>I</VAR>.

</P>
<P>
Currently this intrinsic is defined assuming
the underlying representation of <VAR>I</VAR>
is as a two's-complement integer.
It is unclear at this point whether that
definition will apply when a different
representation is involved.

</P>
<P>
See section <A HREF="g77_12.html#SEC249">LShift Intrinsic</A>, for the inverse of this function.

</P>
<P>
See section <A HREF="g77_12.html#SEC229">IShft Intrinsic</A>, for information
on a more widely available left-shifting
intrinsic that is also more precisely defined.

</P>


<H4><A NAME="SEC250" HREF="g77_toc.html#TOC250">LStat Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1126"></A>
<A NAME="IDX1127"></A>

</P>
<P>

<PRE>
CALL LStat(<VAR>File</VAR>, <VAR>SArray</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>File</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>SArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(13); INTENT(OUT).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Obtains data about the given file <VAR>File</VAR> and places them in the array
<VAR>SArray</VAR>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the name in <VAR>File</VAR>---otherwise,
trailing blanks in <VAR>File</VAR> are ignored.
If <VAR>File</VAR> is a symbolic link it returns data on the
link itself, so the routine is available only on systems that support
symbolic links.
The values in this array are extracted from the
<CODE>stat</CODE> structure as returned by <CODE>fstat(2)</CODE> q.v., as follows:

</P>

<OL>
<LI>

Device ID

<LI>

Inode number

<LI>

File mode

<LI>

Number of links

<LI>

Owner's uid

<LI>

Owner's gid

<LI>

ID of device containing directory entry for file
(0 if not available)

<LI>

File size (bytes)

<LI>

Last access time

<LI>

Last modification time

<LI>

Last file status change time

<LI>

Preferred I/O block size (-1 if not available)

<LI>

Number of blocks allocated (-1 if not available)
</OL>

<P>
Not all these elements are relevant on all systems.
If an element is not relevant, it is returned as 0.

</P>
<P>
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return
(<CODE>ENOSYS</CODE> if the system does not provide <CODE>lstat(2)</CODE>).

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC251">LStat Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC251" HREF="g77_toc.html#TOC251">LStat Intrinsic (function)</A></H4>
<P>
<A NAME="IDX1128"></A>
<A NAME="IDX1129"></A>

</P>
<P>

<PRE>
LStat(<VAR>File</VAR>, <VAR>SArray</VAR>)
</PRE>

<P>
LStat: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>File</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>SArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(13); INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Obtains data about the given file <VAR>File</VAR> and places them in the array
<VAR>SArray</VAR>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the name in <VAR>File</VAR>---otherwise,
trailing blanks in <VAR>File</VAR> are ignored.
If <VAR>File</VAR> is a symbolic link it returns data on the
link itself, so the routine is available only on systems that support
symbolic links.
The values in this array are extracted from the
<CODE>stat</CODE> structure as returned by <CODE>fstat(2)</CODE> q.v., as follows:

</P>

<OL>
<LI>

Device ID

<LI>

Inode number

<LI>

File mode

<LI>

Number of links

<LI>

Owner's uid

<LI>

Owner's gid

<LI>

ID of device containing directory entry for file
(0 if not available)

<LI>

File size (bytes)

<LI>

Last access time

<LI>

Last modification time

<LI>

Last file status change time

<LI>

Preferred I/O block size (-1 if not available)

<LI>

Number of blocks allocated (-1 if not available)
</OL>

<P>
Not all these elements are relevant on all systems.
If an element is not relevant, it is returned as 0.

</P>
<P>
Returns 0 on success or a non-zero error code
(<CODE>ENOSYS</CODE> if the system does not provide <CODE>lstat(2)</CODE>).

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC250">LStat Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC252" HREF="g77_toc.html#TOC252">LTime Intrinsic</A></H4>
<P>
<A NAME="IDX1130"></A>
<A NAME="IDX1131"></A>

</P>
<P>

<PRE>
CALL LTime(<VAR>STime</VAR>, <VAR>TArray</VAR>)
</PRE>

<P>
<VAR>STime</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>TArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(9); INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Given a system time value <VAR>STime</VAR>, fills <VAR>TArray</VAR> with values
extracted from it appropriate to the GMT time zone using
<CODE>localtime(3)</CODE>.

</P>
<P>
The array elements are as follows:

</P>

<OL>
<LI>

Seconds after the minute, range 0--59 or 0--61 to allow for leap
seconds

<LI>

Minutes after the hour, range 0--59

<LI>

Hours past midnight, range 0--23

<LI>

Day of month, range 0--31

<LI>

Number of months since January, range 0--12

<LI>

Years since 1900

<LI>

Number of days since Sunday, range 0--6

<LI>

Days since January 1

<LI>

Daylight savings indicator: positive if daylight savings is in effect,
zero if not, and negative if the information isn't available.
</OL>



<H4><A NAME="SEC253" HREF="g77_toc.html#TOC253">MatMul Intrinsic</A></H4>
<P>
<A NAME="IDX1132"></A>
<A NAME="IDX1133"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL MatMul'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC254" HREF="g77_toc.html#TOC254">Max Intrinsic</A></H4>
<P>
<A NAME="IDX1134"></A>
<A NAME="IDX1135"></A>

</P>
<P>

<PRE>
Max(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
Max: <CODE>INTEGER</CODE> or <CODE>REAL</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the argument with the largest value.

</P>
<P>
See section <A HREF="g77_12.html#SEC263">Min Intrinsic</A>, for the opposite function.

</P>


<H4><A NAME="SEC255" HREF="g77_toc.html#TOC255">Max0 Intrinsic</A></H4>
<P>
<A NAME="IDX1136"></A>
<A NAME="IDX1137"></A>

</P>
<P>

<PRE>
Max0(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
Max0: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER(KIND=1)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MAX()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC254">Max Intrinsic</A>.

</P>


<H4><A NAME="SEC256" HREF="g77_toc.html#TOC256">Max1 Intrinsic</A></H4>
<P>
<A NAME="IDX1138"></A>
<A NAME="IDX1139"></A>

</P>
<P>

<PRE>
Max1(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
Max1: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=1)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MAX()</CODE> that is specific
to one type for <VAR>A</VAR> and a different return type.
See section <A HREF="g77_12.html#SEC254">Max Intrinsic</A>.

</P>


<H4><A NAME="SEC257" HREF="g77_toc.html#TOC257">MaxExponent Intrinsic</A></H4>
<P>
<A NAME="IDX1140"></A>
<A NAME="IDX1141"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL MaxExponent'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC258" HREF="g77_toc.html#TOC258">MaxLoc Intrinsic</A></H4>
<P>
<A NAME="IDX1142"></A>
<A NAME="IDX1143"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL MaxLoc'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC259" HREF="g77_toc.html#TOC259">MaxVal Intrinsic</A></H4>
<P>
<A NAME="IDX1144"></A>
<A NAME="IDX1145"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL MaxVal'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC260" HREF="g77_toc.html#TOC260">MClock Intrinsic</A></H4>
<P>
<A NAME="IDX1146"></A>
<A NAME="IDX1147"></A>

</P>
<P>

<PRE>
MClock()
</PRE>

<P>
MClock: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the number of clock ticks since the start of the process.
Supported on systems with <CODE>clock(3)</CODE> (q.v.).

</P>
<P>
<A NAME="IDX1148"></A>
<A NAME="IDX1149"></A>
This intrinsic is not fully portable, such as to systems
with 32-bit <CODE>INTEGER</CODE> types but supporting times
wider than 32 bits.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>
<P>
See section <A HREF="g77_12.html#SEC261">MClock8 Intrinsic</A>, for information on a
similar intrinsic that might be portable to more
GNU Fortran implementations, though to fewer
Fortran compilers.

</P>
<P>
If the system does not support <CODE>clock(3)</CODE>,
-1 is returned.

</P>


<H4><A NAME="SEC261" HREF="g77_toc.html#TOC261">MClock8 Intrinsic</A></H4>
<P>
<A NAME="IDX1150"></A>
<A NAME="IDX1151"></A>

</P>
<P>

<PRE>
MClock8()
</PRE>

<P>
MClock8: <CODE>INTEGER(KIND=2)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the number of clock ticks since the start of the process.
Supported on systems with <CODE>clock(3)</CODE> (q.v.).

</P>
<P>
<A NAME="IDX1152"></A>
<A NAME="IDX1153"></A>
<EM>Warning:</EM> this intrinsic does not increase the range
of the timing values over that returned by <CODE>clock(3)</CODE>.
On a system with a 32-bit <CODE>clock(3)</CODE>,
<CODE>MCLOCK8</CODE> will return a 32-bit value,
even though converted to an <SAMP>`INTEGER(KIND=2)'</SAMP> value.
That means overflows of the 32-bit value can still occur.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>
<P>
No Fortran implementations other than GNU Fortran are
known to support this intrinsic at the time of this
writing.
See section <A HREF="g77_12.html#SEC260">MClock Intrinsic</A>, for information on a
similar intrinsic that might be portable to more Fortran
compilers, though to fewer GNU Fortran implementations.

</P>
<P>
If the system does not support <CODE>clock(3)</CODE>,
-1 is returned.

</P>


<H4><A NAME="SEC262" HREF="g77_toc.html#TOC262">Merge Intrinsic</A></H4>
<P>
<A NAME="IDX1154"></A>
<A NAME="IDX1155"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Merge'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC263" HREF="g77_toc.html#TOC263">Min Intrinsic</A></H4>
<P>
<A NAME="IDX1156"></A>
<A NAME="IDX1157"></A>

</P>
<P>

<PRE>
Min(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
Min: <CODE>INTEGER</CODE> or <CODE>REAL</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the argument with the smallest value.

</P>
<P>
See section <A HREF="g77_12.html#SEC254">Max Intrinsic</A>, for the opposite function.

</P>


<H4><A NAME="SEC264" HREF="g77_toc.html#TOC264">Min0 Intrinsic</A></H4>
<P>
<A NAME="IDX1158"></A>
<A NAME="IDX1159"></A>

</P>
<P>

<PRE>
Min0(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
Min0: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER(KIND=1)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MIN()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC263">Min Intrinsic</A>.

</P>


<H4><A NAME="SEC265" HREF="g77_toc.html#TOC265">Min1 Intrinsic</A></H4>
<P>
<A NAME="IDX1160"></A>
<A NAME="IDX1161"></A>

</P>
<P>

<PRE>
Min1(<VAR>A</VAR>-1, <VAR>A</VAR>-2, ..., <VAR>A</VAR>-n)
</PRE>

<P>
Min1: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=1)</CODE>; at least two such arguments must be provided; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>MIN()</CODE> that is specific
to one type for <VAR>A</VAR> and a different return type.
See section <A HREF="g77_12.html#SEC263">Min Intrinsic</A>.

</P>


<H4><A NAME="SEC266" HREF="g77_toc.html#TOC266">MinExponent Intrinsic</A></H4>
<P>
<A NAME="IDX1162"></A>
<A NAME="IDX1163"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL MinExponent'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC267" HREF="g77_toc.html#TOC267">MinLoc Intrinsic</A></H4>
<P>
<A NAME="IDX1164"></A>
<A NAME="IDX1165"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL MinLoc'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC268" HREF="g77_toc.html#TOC268">MinVal Intrinsic</A></H4>
<P>
<A NAME="IDX1166"></A>
<A NAME="IDX1167"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL MinVal'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC269" HREF="g77_toc.html#TOC269">Mod Intrinsic</A></H4>
<P>
<A NAME="IDX1168"></A>
<A NAME="IDX1169"></A>

</P>
<P>

<PRE>
Mod(<VAR>A</VAR>, <VAR>P</VAR>)
</PRE>

<P>
Mod: <CODE>INTEGER</CODE> or <CODE>REAL</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>P</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns remainder calculated as:

</P>

<PRE>
<VAR>A</VAR> - (INT(<VAR>A</VAR> / <VAR>P</VAR>) * <VAR>P</VAR>)
</PRE>

<P>
<VAR>P</VAR> must not be zero.

</P>


<H4><A NAME="SEC270" HREF="g77_toc.html#TOC270">Modulo Intrinsic</A></H4>
<P>
<A NAME="IDX1170"></A>
<A NAME="IDX1171"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Modulo'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC271" HREF="g77_toc.html#TOC271">MvBits Intrinsic</A></H4>
<P>
<A NAME="IDX1172"></A>
<A NAME="IDX1173"></A>

</P>
<P>

<PRE>
CALL MvBits(<VAR>From</VAR>, <VAR>FromPos</VAR>, <VAR>Len</VAR>, <VAR>TO</VAR>, <VAR>ToPos</VAR>)
</PRE>

<P>
<VAR>From</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>FromPos</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Len</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>TO</VAR>: <CODE>INTEGER</CODE> with same <SAMP>`KIND='</SAMP> value as for <VAR>From</VAR>; scalar; INTENT(INOUT).

</P>
<P>
<VAR>ToPos</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
Moves <VAR>Len</VAR> bits from positions <VAR>FromPos</VAR> through
<SAMP>`<VAR>FromPos</VAR>+<VAR>Len</VAR>-1'</SAMP> of <VAR>From</VAR> to positions <VAR>ToPos</VAR> through
<SAMP>`<VAR>FromPos</VAR>+<VAR>Len</VAR>-1'</SAMP> of <VAR>TO</VAR>.  The portion of argument
<VAR>TO</VAR> not affected by the movement of bits is unchanged.  Arguments
<VAR>From</VAR> and <VAR>TO</VAR> are permitted to be the same numeric storage
unit.  The values of <SAMP>`<VAR>FromPos</VAR>+<VAR>Len</VAR>'</SAMP> and
<SAMP>`<VAR>ToPos</VAR>+<VAR>Len</VAR>'</SAMP> must be less than or equal to
<SAMP>`BIT_SIZE(<VAR>From</VAR>)'</SAMP>.

</P>


<H4><A NAME="SEC272" HREF="g77_toc.html#TOC272">Nearest Intrinsic</A></H4>
<P>
<A NAME="IDX1174"></A>
<A NAME="IDX1175"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Nearest'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC273" HREF="g77_toc.html#TOC273">NInt Intrinsic</A></H4>
<P>
<A NAME="IDX1176"></A>
<A NAME="IDX1177"></A>

</P>
<P>

<PRE>
NInt(<VAR>A</VAR>)
</PRE>

<P>
NInt: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <VAR>A</VAR> with the fractional portion of its
magnitude eliminated by rounding to the nearest whole
number and with its sign preserved, converted
to type <CODE>INTEGER(KIND=1)</CODE>.

</P>
<P>
If <VAR>A</VAR> is type <CODE>COMPLEX</CODE>, its real part is
rounded and converted.

</P>
<P>
A fractional portion exactly equal to
<SAMP>`.5'</SAMP> is rounded to the whole number that
is larger in magnitude.
(Also called "Fortran round".)

</P>
<P>
See section <A HREF="g77_12.html#SEC223">Int Intrinsic</A>, for how to convert, truncate to
whole number.

</P>
<P>
See section <A HREF="g77_12.html#SEC96">ANInt Intrinsic</A>, for how to round to nearest whole number
without converting.

</P>


<H4><A NAME="SEC274" HREF="g77_toc.html#TOC274">Not Intrinsic</A></H4>
<P>
<A NAME="IDX1178"></A>
<A NAME="IDX1179"></A>

</P>
<P>

<PRE>
Not(<VAR>I</VAR>)
</PRE>

<P>
Not: <CODE>INTEGER</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>I</VAR>.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>mil</CODE>, <CODE>f90</CODE>, <CODE>vxt</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns value resulting from boolean NOT of each bit
in <VAR>I</VAR>.

</P>


<H4><A NAME="SEC275" HREF="g77_toc.html#TOC275">Or Intrinsic</A></H4>
<P>
<A NAME="IDX1180"></A>
<A NAME="IDX1181"></A>

</P>
<P>

<PRE>
Or(<VAR>I</VAR>, <VAR>J</VAR>)
</PRE>

<P>
Or: <CODE>INTEGER</CODE> or <CODE>LOGICAL</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE> or <CODE>LOGICAL</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>J</VAR>: <CODE>INTEGER</CODE> or <CODE>LOGICAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns value resulting from boolean OR of
pair of bits in each of <VAR>I</VAR> and <VAR>J</VAR>.

</P>


<H4><A NAME="SEC276" HREF="g77_toc.html#TOC276">Pack Intrinsic</A></H4>
<P>
<A NAME="IDX1182"></A>
<A NAME="IDX1183"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Pack'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC277" HREF="g77_toc.html#TOC277">PError Intrinsic</A></H4>
<P>
<A NAME="IDX1184"></A>
<A NAME="IDX1185"></A>

</P>
<P>

<PRE>
CALL PError(<VAR>String</VAR>)
</PRE>

<P>
<VAR>String</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Prints (on the C <CODE>stderr</CODE> stream) a newline-terminated error
message corresponding to the last system error.
This is prefixed by <VAR>String</VAR>, a colon and a space.
See <CODE>perror(3)</CODE>.

</P>


<H4><A NAME="SEC278" HREF="g77_toc.html#TOC278">Precision Intrinsic</A></H4>
<P>
<A NAME="IDX1186"></A>
<A NAME="IDX1187"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Precision'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC279" HREF="g77_toc.html#TOC279">Present Intrinsic</A></H4>
<P>
<A NAME="IDX1188"></A>
<A NAME="IDX1189"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Present'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC280" HREF="g77_toc.html#TOC280">Product Intrinsic</A></H4>
<P>
<A NAME="IDX1190"></A>
<A NAME="IDX1191"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Product'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC281" HREF="g77_toc.html#TOC281">Radix Intrinsic</A></H4>
<P>
<A NAME="IDX1192"></A>
<A NAME="IDX1193"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Radix'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC282" HREF="g77_toc.html#TOC282">Rand Intrinsic</A></H4>
<P>
<A NAME="IDX1194"></A>
<A NAME="IDX1195"></A>

</P>
<P>

<PRE>
Rand(<VAR>Flag</VAR>)
</PRE>

<P>
Rand: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>Flag</VAR>: <CODE>INTEGER</CODE>; OPTIONAL; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns a uniform quasi-random number between 0 and 1.
If <VAR>Flag</VAR> is 0, the next number in sequence is returned; if
<VAR>Flag</VAR> is 1, the generator is restarted by calling <SAMP>`srand(0)'</SAMP>;
if <VAR>Flag</VAR> has any other value, it is used as a new seed with
<CODE>srand</CODE>.

</P>
<P>
See section <A HREF="g77_12.html#SEC311">SRand Intrinsic</A>.

</P>
<P>
<EM>Note:</EM> As typically implemented (by the routine of the same
name in the C library), this random number generator is a very poor
one, though the BSD and GNU libraries provide a much better
implementation than the `traditional' one.
On a different system you
almost certainly want to use something better.

</P>


<H4><A NAME="SEC283" HREF="g77_toc.html#TOC283">Random_Number Intrinsic</A></H4>
<P>
<A NAME="IDX1196"></A>
<A NAME="IDX1197"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Random_Number'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC284" HREF="g77_toc.html#TOC284">Random_Seed Intrinsic</A></H4>
<P>
<A NAME="IDX1198"></A>
<A NAME="IDX1199"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Random_Seed'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC285" HREF="g77_toc.html#TOC285">Range Intrinsic</A></H4>
<P>
<A NAME="IDX1200"></A>
<A NAME="IDX1201"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Range'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC286" HREF="g77_toc.html#TOC286">Real Intrinsic</A></H4>
<P>
<A NAME="IDX1202"></A>
<A NAME="IDX1203"></A>

</P>
<P>

<PRE>
Real(<VAR>A</VAR>)
</PRE>

<P>
Real: <CODE>REAL</CODE> function.
The exact type is <SAMP>`REAL(KIND=1)'</SAMP> when argument <VAR>A</VAR> is
any type other than <CODE>COMPLEX</CODE>, or when it is <CODE>COMPLEX(KIND=1)</CODE>.
When <VAR>A</VAR> is any <CODE>COMPLEX</CODE> type other than <CODE>COMPLEX(KIND=1)</CODE>,
this intrinsic is valid only when used as the argument to
<CODE>REAL()</CODE>, as explained below.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE>, <CODE>REAL</CODE>, or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Converts <VAR>A</VAR> to <CODE>REAL(KIND=1)</CODE>.

</P>
<P>
Use of <CODE>REAL()</CODE> with a <CODE>COMPLEX</CODE> argument
(other than <CODE>COMPLEX(KIND=1)</CODE>) is restricted to the following case:

</P>

<PRE>
REAL(REAL(A))
</PRE>

<P>
This expression converts the real part of A to
<CODE>REAL(KIND=1)</CODE>.

</P>
<P>
See section <A HREF="g77_12.html#SEC287">RealPart Intrinsic</A>, for information on a GNU Fortran
intrinsic that extracts the real part of an arbitrary
<CODE>COMPLEX</CODE> value.

</P>
<P>
See section <A HREF="g77_12.html#SEC71"><CODE>REAL()</CODE> and <CODE>AIMAG()</CODE> of Complex</A>, for more information.

</P>


<H4><A NAME="SEC287" HREF="g77_toc.html#TOC287">RealPart Intrinsic</A></H4>
<P>
<A NAME="IDX1204"></A>
<A NAME="IDX1205"></A>

</P>
<P>

<PRE>
RealPart(<VAR>Z</VAR>)
</PRE>

<P>
RealPart: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>Z</VAR>.

</P>
<P>
<VAR>Z</VAR>: <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>gnu</CODE>.

</P>
<P>
Description:

</P>
<P>
The real part of <VAR>Z</VAR> is returned, without conversion.

</P>
<P>
<EM>Note:</EM> The way to do this in standard Fortran 90
is <SAMP>`REAL(<VAR>Z</VAR>)'</SAMP>.
However, when, for example, <VAR>Z</VAR> is <CODE>COMPLEX(KIND=2)</CODE>,
<SAMP>`REAL(<VAR>Z</VAR>)'</SAMP> means something different for some compilers
that are not true Fortran 90 compilers but offer some
extensions standardized by Fortran 90 (such as the
<CODE>DOUBLE COMPLEX</CODE> type, also known as <CODE>COMPLEX(KIND=2)</CODE>).

</P>
<P>
The advantage of <CODE>REALPART()</CODE> is that, while not necessarily
more or less portable than <CODE>REAL()</CODE>, it is more likely to
cause a compiler that doesn't support it to produce a diagnostic
than generate incorrect code.

</P>
<P>
See section <A HREF="g77_12.html#SEC71"><CODE>REAL()</CODE> and <CODE>AIMAG()</CODE> of Complex</A>, for more information.

</P>


<H4><A NAME="SEC288" HREF="g77_toc.html#TOC288">Rename Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1206"></A>
<A NAME="IDX1207"></A>

</P>
<P>

<PRE>
CALL Rename(<VAR>Path1</VAR>, <VAR>Path2</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Path1</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Path2</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Renames the file <VAR>Path1</VAR> to <VAR>Path2</VAR>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the names in <VAR>Path1</VAR> and <VAR>Path2</VAR>---otherwise,
trailing blanks in <VAR>Path1</VAR> and <VAR>Path2</VAR> are ignored.
See <CODE>rename(2)</CODE>.
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC506">Rename Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC289" HREF="g77_toc.html#TOC289">Repeat Intrinsic</A></H4>
<P>
<A NAME="IDX1208"></A>
<A NAME="IDX1209"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Repeat'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC290" HREF="g77_toc.html#TOC290">Reshape Intrinsic</A></H4>
<P>
<A NAME="IDX1210"></A>
<A NAME="IDX1211"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Reshape'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC291" HREF="g77_toc.html#TOC291">RRSpacing Intrinsic</A></H4>
<P>
<A NAME="IDX1212"></A>
<A NAME="IDX1213"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL RRSpacing'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC292" HREF="g77_toc.html#TOC292">RShift Intrinsic</A></H4>
<P>
<A NAME="IDX1214"></A>
<A NAME="IDX1215"></A>

</P>
<P>

<PRE>
RShift(<VAR>I</VAR>, <VAR>Shift</VAR>)
</PRE>

<P>
RShift: <CODE>INTEGER</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>I</VAR>.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Shift</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns <VAR>I</VAR> shifted to the right
<VAR>Shift</VAR> bits.

</P>
<P>
Although similar to the expression
<SAMP>`<VAR>I</VAR>/(2**<VAR>Shift</VAR>)'</SAMP>, there
are important differences.
For example, the sign of the result is
undefined.

</P>
<P>
Currently this intrinsic is defined assuming
the underlying representation of <VAR>I</VAR>
is as a two's-complement integer.
It is unclear at this point whether that
definition will apply when a different
representation is involved.

</P>
<P>
See section <A HREF="g77_12.html#SEC292">RShift Intrinsic</A>, for the inverse of this function.

</P>
<P>
See section <A HREF="g77_12.html#SEC229">IShft Intrinsic</A>, for information
on a more widely available right-shifting
intrinsic that is also more precisely defined.

</P>


<H4><A NAME="SEC293" HREF="g77_toc.html#TOC293">Scale Intrinsic</A></H4>
<P>
<A NAME="IDX1216"></A>
<A NAME="IDX1217"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Scale'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC294" HREF="g77_toc.html#TOC294">Scan Intrinsic</A></H4>
<P>
<A NAME="IDX1218"></A>
<A NAME="IDX1219"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Scan'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC295" HREF="g77_toc.html#TOC295">Second Intrinsic (function)</A></H4>
<P>
<A NAME="IDX1220"></A>
<A NAME="IDX1221"></A>

</P>
<P>

<PRE>
Second()
</PRE>

<P>
Second: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the process's runtime in seconds--the same value as the
UNIX function <CODE>etime</CODE> returns.

</P>
<P>
<A NAME="IDX1222"></A>
<A NAME="IDX1223"></A>
On some systems, the underlying timings are represented
using types with sufficiently small limits that overflows
(wraparounds) are possible, such as 32-bit types.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC296">Second Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC296" HREF="g77_toc.html#TOC296">Second Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1224"></A>
<A NAME="IDX1225"></A>

</P>
<P>

<PRE>
CALL Second(<VAR>Seconds</VAR>)
</PRE>

<P>
<VAR>Seconds</VAR>: <CODE>REAL</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the process's runtime in seconds in <VAR>Seconds</VAR>---the same value
as the UNIX function <CODE>etime</CODE> returns.

</P>
<P>
<A NAME="IDX1226"></A>
<A NAME="IDX1227"></A>
On some systems, the underlying timings are represented
using types with sufficiently small limits that overflows
(wraparounds) are possible, such as 32-bit types.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>
<P>
This routine is known from Cray Fortran.  See section <A HREF="g77_12.html#SEC124">CPU_Time Intrinsic</A>,
for a standard equivalent.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC295">Second Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC297" HREF="g77_toc.html#TOC297">Selected_Int_Kind Intrinsic</A></H4>
<P>
<A NAME="IDX1228"></A>
<A NAME="IDX1229"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Selected_Int_Kind'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC298" HREF="g77_toc.html#TOC298">Selected_Real_Kind Intrinsic</A></H4>
<P>
<A NAME="IDX1230"></A>
<A NAME="IDX1231"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Selected_Real_Kind'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC299" HREF="g77_toc.html#TOC299">Set_Exponent Intrinsic</A></H4>
<P>
<A NAME="IDX1232"></A>
<A NAME="IDX1233"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Set_Exponent'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC300" HREF="g77_toc.html#TOC300">Shape Intrinsic</A></H4>
<P>
<A NAME="IDX1234"></A>
<A NAME="IDX1235"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Shape'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC301" HREF="g77_toc.html#TOC301">Short Intrinsic</A></H4>
<P>
<A NAME="IDX1236"></A>
<A NAME="IDX1237"></A>

</P>
<P>

<PRE>
Short(<VAR>A</VAR>)
</PRE>

<P>
Short: <CODE>INTEGER(KIND=6)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns <VAR>A</VAR> with the fractional portion of its
magnitude truncated and its sign preserved, converted
to type <CODE>INTEGER(KIND=6)</CODE>.

</P>
<P>
If <VAR>A</VAR> is type <CODE>COMPLEX</CODE>, its real part
is truncated and converted, and its imaginary part is disgregarded.

</P>
<P>
See section <A HREF="g77_12.html#SEC223">Int Intrinsic</A>.

</P>
<P>
The precise meaning of this intrinsic might change
in a future version of the GNU Fortran language,
as more is learned about how it is used.

</P>


<H4><A NAME="SEC302" HREF="g77_toc.html#TOC302">Sign Intrinsic</A></H4>
<P>
<A NAME="IDX1238"></A>
<A NAME="IDX1239"></A>

</P>
<P>

<PRE>
Sign(<VAR>A</VAR>, <VAR>B</VAR>)
</PRE>

<P>
Sign: <CODE>INTEGER</CODE> or <CODE>REAL</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>A</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>B</VAR>: <CODE>INTEGER</CODE> or <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns <SAMP>`ABS(<VAR>A</VAR>)*<VAR>s</VAR>'</SAMP>, where
<VAR>s</VAR> is +1 if <SAMP>`<VAR>B</VAR>.GE.0'</SAMP>,
-1 otherwise.

</P>
<P>
See section <A HREF="g77_12.html#SEC77">Abs Intrinsic</A>, for the function that returns
the magnitude of a value.

</P>


<H4><A NAME="SEC303" HREF="g77_toc.html#TOC303">Signal Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1240"></A>
<A NAME="IDX1241"></A>

</P>
<P>

<PRE>
CALL Signal(<VAR>Number</VAR>, <VAR>Handler</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Number</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Handler</VAR>: Signal handler (<CODE>INTEGER FUNCTION</CODE> or <CODE>SUBROUTINE</CODE>)
or dummy/global <CODE>INTEGER(KIND=1)</CODE> scalar.

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=7)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
If <VAR>Handler</VAR> is a an <CODE>EXTERNAL</CODE> routine, arranges for it to be
invoked with a single integer argument (of system-dependent length)
when signal <VAR>Number</VAR> occurs.
If <VAR>Handler</VAR> is an integer, it can be
used to turn off handling of signal <VAR>Number</VAR> or revert to its default
action.
See <CODE>signal(2)</CODE>.

</P>
<P>
Note that <VAR>Handler</VAR> will be called using C conventions,
so the value of its argument in Fortran terms
Fortran terms is obtained by applying <CODE>%LOC()</CODE> (or <VAR>LOC()</VAR>) to it.

</P>
<P>
The value returned by <CODE>signal(2)</CODE> is written to <VAR>Status</VAR>, if
that argument is supplied.
Otherwise the return value is ignored.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
<EM>Warning:</EM> Use of the <CODE>libf2c</CODE> run-time library function
<SAMP>`signal_'</SAMP> directly
(such as via <SAMP>`EXTERNAL SIGNAL'</SAMP>)
requires use of the <CODE>%VAL()</CODE> construct
to pass an <CODE>INTEGER</CODE> value
(such as <SAMP>`SIG_IGN'</SAMP> or <SAMP>`SIG_DFL'</SAMP>)
for the <VAR>Handler</VAR> argument.

</P>
<P>
However, while <SAMP>`CALL SIGNAL(<VAR>signum</VAR>, %VAL(SIG_IGN))'</SAMP>
works when <SAMP>`SIGNAL'</SAMP> is treated as an external procedure
(and resolves, at link time, to <CODE>libf2c</CODE>'s <SAMP>`signal_'</SAMP> routine),
this construct is not valid when <SAMP>`SIGNAL'</SAMP> is recognized
as the intrinsic of that name.

</P>
<P>
Therefore, for maximum portability and reliability,
code such references to the <SAMP>`SIGNAL'</SAMP> facility as follows:

</P>

<PRE>
INTRINSIC SIGNAL
...
CALL SIGNAL(<VAR>signum</VAR>, SIG_IGN)
</PRE>

<P>
<CODE>g77</CODE> will compile such a call correctly,
while other compilers will generally either do so as well
or reject the <SAMP>`INTRINSIC SIGNAL'</SAMP> statement via a diagnostic,
allowing you to take appropriate action.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC508">Signal Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC304" HREF="g77_toc.html#TOC304">Sin Intrinsic</A></H4>
<P>
<A NAME="IDX1242"></A>
<A NAME="IDX1243"></A>

</P>
<P>

<PRE>
Sin(<VAR>X</VAR>)
</PRE>

<P>
Sin: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE> function, the exact type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the sine of <VAR>X</VAR>, an angle measured
in radians.

</P>
<P>
See section <A HREF="g77_12.html#SEC98">ASin Intrinsic</A>, for the inverse of this function.

</P>


<H4><A NAME="SEC305" HREF="g77_toc.html#TOC305">SinH Intrinsic</A></H4>
<P>
<A NAME="IDX1244"></A>
<A NAME="IDX1245"></A>

</P>
<P>

<PRE>
SinH(<VAR>X</VAR>)
</PRE>

<P>
SinH: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the hyperbolic sine of <VAR>X</VAR>.

</P>


<H4><A NAME="SEC306" HREF="g77_toc.html#TOC306">Sleep Intrinsic</A></H4>
<P>
<A NAME="IDX1246"></A>
<A NAME="IDX1247"></A>

</P>
<P>

<PRE>
CALL Sleep(<VAR>Seconds</VAR>)
</PRE>

<P>
<VAR>Seconds</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Causes the process to pause for <VAR>Seconds</VAR> seconds.
See <CODE>sleep(2)</CODE>.

</P>


<H4><A NAME="SEC307" HREF="g77_toc.html#TOC307">Sngl Intrinsic</A></H4>
<P>
<A NAME="IDX1248"></A>
<A NAME="IDX1249"></A>

</P>
<P>

<PRE>
Sngl(<VAR>A</VAR>)
</PRE>

<P>
Sngl: <CODE>REAL(KIND=1)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>REAL(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>REAL()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC286">Real Intrinsic</A>.

</P>


<H4><A NAME="SEC308" HREF="g77_toc.html#TOC308">Spacing Intrinsic</A></H4>
<P>
<A NAME="IDX1250"></A>
<A NAME="IDX1251"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Spacing'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC309" HREF="g77_toc.html#TOC309">Spread Intrinsic</A></H4>
<P>
<A NAME="IDX1252"></A>
<A NAME="IDX1253"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Spread'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC310" HREF="g77_toc.html#TOC310">SqRt Intrinsic</A></H4>
<P>
<A NAME="IDX1254"></A>
<A NAME="IDX1255"></A>

</P>
<P>

<PRE>
SqRt(<VAR>X</VAR>)
</PRE>

<P>
SqRt: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE> function, the exact type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE> or <CODE>COMPLEX</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the square root of <VAR>X</VAR>, which must
not be negative.

</P>
<P>
To calculate and represent the square root of a negative
number, complex arithmetic must be used.
For example, <SAMP>`SQRT(COMPLEX(<VAR>X</VAR>))'</SAMP>.

</P>
<P>
The inverse of this function is <SAMP>`SQRT(<VAR>X</VAR>) * SQRT(<VAR>X</VAR>)'</SAMP>.

</P>


<H4><A NAME="SEC311" HREF="g77_toc.html#TOC311">SRand Intrinsic</A></H4>
<P>
<A NAME="IDX1256"></A>
<A NAME="IDX1257"></A>

</P>
<P>

<PRE>
CALL SRand(<VAR>Seed</VAR>)
</PRE>

<P>
<VAR>Seed</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Reinitialises the generator with the seed in <VAR>Seed</VAR>.
See section <A HREF="g77_12.html#SEC227">IRand Intrinsic</A>.
See section <A HREF="g77_12.html#SEC282">Rand Intrinsic</A>.

</P>


<H4><A NAME="SEC312" HREF="g77_toc.html#TOC312">Stat Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1258"></A>
<A NAME="IDX1259"></A>

</P>
<P>

<PRE>
CALL Stat(<VAR>File</VAR>, <VAR>SArray</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>File</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>SArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(13); INTENT(OUT).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Obtains data about the given file <VAR>File</VAR> and places them in the array
<VAR>SArray</VAR>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the name in <VAR>File</VAR>---otherwise,
trailing blanks in <VAR>File</VAR> are ignored.
The values in this array are extracted from the
<CODE>stat</CODE> structure as returned by <CODE>fstat(2)</CODE> q.v., as follows:

</P>

<OL>
<LI>

Device ID

<LI>

Inode number

<LI>

File mode

<LI>

Number of links

<LI>

Owner's uid

<LI>

Owner's gid

<LI>

ID of device containing directory entry for file
(0 if not available)

<LI>

File size (bytes)

<LI>

Last access time

<LI>

Last modification time

<LI>

Last file status change time

<LI>

Preferred I/O block size (-1 if not available)

<LI>

Number of blocks allocated (-1 if not available)
</OL>

<P>
Not all these elements are relevant on all systems.
If an element is not relevant, it is returned as 0.

</P>
<P>
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC313">Stat Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC313" HREF="g77_toc.html#TOC313">Stat Intrinsic (function)</A></H4>
<P>
<A NAME="IDX1260"></A>
<A NAME="IDX1261"></A>

</P>
<P>

<PRE>
Stat(<VAR>File</VAR>, <VAR>SArray</VAR>)
</PRE>

<P>
Stat: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
<VAR>File</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>SArray</VAR>: <CODE>INTEGER(KIND=1)</CODE>; DIMENSION(13); INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Obtains data about the given file <VAR>File</VAR> and places them in the array
<VAR>SArray</VAR>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the name in <VAR>File</VAR>---otherwise,
trailing blanks in <VAR>File</VAR> are ignored.
The values in this array are extracted from the
<CODE>stat</CODE> structure as returned by <CODE>fstat(2)</CODE> q.v., as follows:

</P>

<OL>
<LI>

Device ID

<LI>

Inode number

<LI>

File mode

<LI>

Number of links

<LI>

Owner's uid

<LI>

Owner's gid

<LI>

ID of device containing directory entry for file
(0 if not available)

<LI>

File size (bytes)

<LI>

Last access time

<LI>

Last modification time

<LI>

Last file status change time

<LI>

Preferred I/O block size (-1 if not available)

<LI>

Number of blocks allocated (-1 if not available)
</OL>

<P>
Not all these elements are relevant on all systems.
If an element is not relevant, it is returned as 0.

</P>
<P>
Returns 0 on success or a non-zero error code.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC312">Stat Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC314" HREF="g77_toc.html#TOC314">Sum Intrinsic</A></H4>
<P>
<A NAME="IDX1262"></A>
<A NAME="IDX1263"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Sum'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC315" HREF="g77_toc.html#TOC315">SymLnk Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1264"></A>
<A NAME="IDX1265"></A>

</P>
<P>

<PRE>
CALL SymLnk(<VAR>Path1</VAR>, <VAR>Path2</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Path1</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Path2</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Makes a symbolic link from file <VAR>Path1</VAR> to <VAR>Path2</VAR>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the names in <VAR>Path1</VAR> and <VAR>Path2</VAR>---otherwise,
trailing blanks in <VAR>Path1</VAR> and <VAR>Path2</VAR> are ignored.
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return
(<CODE>ENOSYS</CODE> if the system does not provide <CODE>symlink(2)</CODE>).

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC511">SymLnk Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC316" HREF="g77_toc.html#TOC316">System Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1266"></A>
<A NAME="IDX1267"></A>

</P>
<P>

<PRE>
CALL System(<VAR>Command</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>Command</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Passes the command <VAR>Command</VAR> to a shell (see <CODE>system(3)</CODE>).
If argument <VAR>Status</VAR> is present, it contains the value returned by
<CODE>system(3)</CODE>, presumably 0 if the shell command succeeded.
Note that which shell is used to invoke the command is system-dependent
and environment-dependent.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC512">System Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC317" HREF="g77_toc.html#TOC317">System_Clock Intrinsic</A></H4>
<P>
<A NAME="IDX1268"></A>
<A NAME="IDX1269"></A>

</P>
<P>

<PRE>
CALL System_Clock(<VAR>Count</VAR>, <VAR>Rate</VAR>, <VAR>Max</VAR>)
</PRE>

<P>
<VAR>Count</VAR>: <CODE>INTEGER(KIND=1)</CODE>; scalar; INTENT(OUT).

</P>
<P>
<VAR>Rate</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
<VAR>Max</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>f90</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns in <VAR>Count</VAR> the current value of the system clock; this is
the value returned by the UNIX function <CODE>times(2)</CODE>
in this implementation, but
isn't in general.
<VAR>Rate</VAR> is the number of clock ticks per second and
<VAR>Max</VAR> is the maximum value this can take, which isn't very useful
in this implementation since it's just the maximum C <CODE>unsigned
int</CODE> value.

</P>
<P>
<A NAME="IDX1270"></A>
<A NAME="IDX1271"></A>
On some systems, the underlying timings are represented
using types with sufficiently small limits that overflows
(wraparounds) are possible, such as 32-bit types.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>


<H4><A NAME="SEC318" HREF="g77_toc.html#TOC318">Tan Intrinsic</A></H4>
<P>
<A NAME="IDX1272"></A>
<A NAME="IDX1273"></A>

</P>
<P>

<PRE>
Tan(<VAR>X</VAR>)
</PRE>

<P>
Tan: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the tangent of <VAR>X</VAR>, an angle measured
in radians.

</P>
<P>
See section <A HREF="g77_12.html#SEC100">ATan Intrinsic</A>, for the inverse of this function.

</P>


<H4><A NAME="SEC319" HREF="g77_toc.html#TOC319">TanH Intrinsic</A></H4>
<P>
<A NAME="IDX1274"></A>
<A NAME="IDX1275"></A>

</P>
<P>

<PRE>
TanH(<VAR>X</VAR>)
</PRE>

<P>
TanH: <CODE>REAL</CODE> function, the <SAMP>`KIND='</SAMP> value of the type being that of argument <VAR>X</VAR>.

</P>
<P>
<VAR>X</VAR>: <CODE>REAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: (standard FORTRAN 77).

</P>
<P>
Description:

</P>
<P>
Returns the hyperbolic tangent of <VAR>X</VAR>.

</P>


<H4><A NAME="SEC320" HREF="g77_toc.html#TOC320">Time Intrinsic (UNIX)</A></H4>
<P>
<A NAME="IDX1276"></A>
<A NAME="IDX1277"></A>

</P>
<P>

<PRE>
Time()
</PRE>

<P>
Time: <CODE>INTEGER(KIND=1)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the current time encoded as an integer
(in the manner of the UNIX function <CODE>time(3)</CODE>).
This value is suitable for passing to <CODE>CTIME</CODE>,
<CODE>GMTIME</CODE>, and <CODE>LTIME</CODE>.

</P>
<P>
<A NAME="IDX1278"></A>
<A NAME="IDX1279"></A>
This intrinsic is not fully portable, such as to systems
with 32-bit <CODE>INTEGER</CODE> types but supporting times
wider than 32 bits.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>
<P>
See section <A HREF="g77_12.html#SEC321">Time8 Intrinsic</A>, for information on a
similar intrinsic that might be portable to more
GNU Fortran implementations, though to fewer
Fortran compilers.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC514">Time Intrinsic (VXT)</A>.

</P>


<H4><A NAME="SEC321" HREF="g77_toc.html#TOC321">Time8 Intrinsic</A></H4>
<P>
<A NAME="IDX1280"></A>
<A NAME="IDX1281"></A>

</P>
<P>

<PRE>
Time8()
</PRE>

<P>
Time8: <CODE>INTEGER(KIND=2)</CODE> function.

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the current time encoded as a long integer
(in the manner of the UNIX function <CODE>time(3)</CODE>).
This value is suitable for passing to <CODE>CTIME</CODE>,
<CODE>GMTIME</CODE>, and <CODE>LTIME</CODE>.

</P>
<P>
<A NAME="IDX1282"></A>
<A NAME="IDX1283"></A>
<EM>Warning:</EM> this intrinsic does not increase the range
of the timing values over that returned by <CODE>time(3)</CODE>.
On a system with a 32-bit <CODE>time(3)</CODE>,
<CODE>TIME8</CODE> will return a 32-bit value,
even though converted to an <SAMP>`INTEGER(KIND=2)'</SAMP> value.
That means overflows of the 32-bit value can still occur.
Therefore, the values returned by this intrinsic
might be, or become, negative,
or numerically less than previous values,
during a single run of the compiled program.

</P>
<P>
No Fortran implementations other than GNU Fortran are
known to support this intrinsic at the time of this
writing.
See section <A HREF="g77_12.html#SEC320">Time Intrinsic (UNIX)</A>, for information on a
similar intrinsic that might be portable to more Fortran
compilers, though to fewer GNU Fortran implementations.

</P>


<H4><A NAME="SEC322" HREF="g77_toc.html#TOC322">Tiny Intrinsic</A></H4>
<P>
<A NAME="IDX1284"></A>
<A NAME="IDX1285"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Tiny'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC323" HREF="g77_toc.html#TOC323">Transfer Intrinsic</A></H4>
<P>
<A NAME="IDX1286"></A>
<A NAME="IDX1287"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Transfer'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC324" HREF="g77_toc.html#TOC324">Transpose Intrinsic</A></H4>
<P>
<A NAME="IDX1288"></A>
<A NAME="IDX1289"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Transpose'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC325" HREF="g77_toc.html#TOC325">Trim Intrinsic</A></H4>
<P>
<A NAME="IDX1290"></A>
<A NAME="IDX1291"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Trim'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC326" HREF="g77_toc.html#TOC326">TtyNam Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1292"></A>
<A NAME="IDX1293"></A>

</P>
<P>

<PRE>
CALL TtyNam(<VAR>Unit</VAR>, <VAR>Name</VAR>)
</PRE>

<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Name</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Sets <VAR>Name</VAR> to the name of the terminal device open on logical unit
<VAR>Unit</VAR> or to a blank string if <VAR>Unit</VAR> is not connected to a
terminal.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC327">TtyNam Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC327" HREF="g77_toc.html#TOC327">TtyNam Intrinsic (function)</A></H4>
<P>
<A NAME="IDX1294"></A>
<A NAME="IDX1295"></A>

</P>
<P>

<PRE>
TtyNam(<VAR>Unit</VAR>)
</PRE>

<P>
TtyNam: <CODE>CHARACTER*(*)</CODE> function.

</P>
<P>
<VAR>Unit</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns the name of the terminal device open on logical unit
<VAR>Unit</VAR> or a blank string if <VAR>Unit</VAR> is not connected to a
terminal.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_12.html#SEC326">TtyNam Intrinsic (subroutine)</A>.

</P>


<H4><A NAME="SEC328" HREF="g77_toc.html#TOC328">UBound Intrinsic</A></H4>
<P>
<A NAME="IDX1296"></A>
<A NAME="IDX1297"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL UBound'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC329" HREF="g77_toc.html#TOC329">UMask Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1298"></A>
<A NAME="IDX1299"></A>

</P>
<P>

<PRE>
CALL UMask(<VAR>Mask</VAR>, <VAR>Old</VAR>)
</PRE>

<P>
<VAR>Mask</VAR>: <CODE>INTEGER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Old</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Sets the file creation mask to <VAR>Mask</VAR> and returns the old value in
argument <VAR>Old</VAR> if it is supplied.
See <CODE>umask(2)</CODE>.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC515">UMask Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC330" HREF="g77_toc.html#TOC330">Unlink Intrinsic (subroutine)</A></H4>
<P>
<A NAME="IDX1300"></A>
<A NAME="IDX1301"></A>

</P>
<P>

<PRE>
CALL Unlink(<VAR>File</VAR>, <VAR>Status</VAR>)
</PRE>

<P>
<VAR>File</VAR>: <CODE>CHARACTER</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>Status</VAR>: <CODE>INTEGER(KIND=1)</CODE>; OPTIONAL; scalar; INTENT(OUT).

</P>
<P>
Intrinsic groups: <CODE>unix</CODE>.

</P>
<P>
Description:

</P>
<P>
Unlink the file <VAR>File</VAR>.
A null character (<SAMP>`CHAR(0)'</SAMP>) marks the end of
the name in <VAR>File</VAR>---otherwise,
trailing blanks in <VAR>File</VAR> are ignored.
If the <VAR>Status</VAR> argument is supplied, it contains
0 on success or a non-zero error code upon return.
See <CODE>unlink(2)</CODE>.

</P>
<P>
Some non-GNU implementations of Fortran provide this intrinsic as
only a function, not as a subroutine, or do not support the
(optional) <VAR>Status</VAR> argument.

</P>
<P>
For information on other intrinsics with the same name:
See section <A HREF="g77_14.html#SEC516">Unlink Intrinsic (function)</A>.

</P>


<H4><A NAME="SEC331" HREF="g77_toc.html#TOC331">Unpack Intrinsic</A></H4>
<P>
<A NAME="IDX1302"></A>
<A NAME="IDX1303"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Unpack'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC332" HREF="g77_toc.html#TOC332">Verify Intrinsic</A></H4>
<P>
<A NAME="IDX1304"></A>
<A NAME="IDX1305"></A>

</P>
<P>
This intrinsic is not yet implemented.
The name is, however, reserved as an intrinsic.
Use <SAMP>`EXTERNAL Verify'</SAMP> to use this name for an
external procedure.

</P>


<H4><A NAME="SEC333" HREF="g77_toc.html#TOC333">XOr Intrinsic</A></H4>
<P>
<A NAME="IDX1306"></A>
<A NAME="IDX1307"></A>

</P>
<P>

<PRE>
XOr(<VAR>I</VAR>, <VAR>J</VAR>)
</PRE>

<P>
XOr: <CODE>INTEGER</CODE> or <CODE>LOGICAL</CODE> function, the exact type being the result of cross-promoting the
types of all the arguments.

</P>
<P>
<VAR>I</VAR>: <CODE>INTEGER</CODE> or <CODE>LOGICAL</CODE>; scalar; INTENT(IN).

</P>
<P>
<VAR>J</VAR>: <CODE>INTEGER</CODE> or <CODE>LOGICAL</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Returns value resulting from boolean exclusive-OR of
pair of bits in each of <VAR>I</VAR> and <VAR>J</VAR>.

</P>


<H4><A NAME="SEC334" HREF="g77_toc.html#TOC334">ZAbs Intrinsic</A></H4>
<P>
<A NAME="IDX1308"></A>
<A NAME="IDX1309"></A>

</P>
<P>

<PRE>
ZAbs(<VAR>A</VAR>)
</PRE>

<P>
ZAbs: <CODE>REAL(KIND=2)</CODE> function.

</P>
<P>
<VAR>A</VAR>: <CODE>COMPLEX(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>ABS()</CODE> that is specific
to one type for <VAR>A</VAR>.
See section <A HREF="g77_12.html#SEC77">Abs Intrinsic</A>.

</P>


<H4><A NAME="SEC335" HREF="g77_toc.html#TOC335">ZCos Intrinsic</A></H4>
<P>
<A NAME="IDX1310"></A>
<A NAME="IDX1311"></A>

</P>
<P>

<PRE>
ZCos(<VAR>X</VAR>)
</PRE>

<P>
ZCos: <CODE>COMPLEX(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>COS()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC121">Cos Intrinsic</A>.

</P>


<H4><A NAME="SEC336" HREF="g77_toc.html#TOC336">ZExp Intrinsic</A></H4>
<P>
<A NAME="IDX1312"></A>
<A NAME="IDX1313"></A>

</P>
<P>

<PRE>
ZExp(<VAR>X</VAR>)
</PRE>

<P>
ZExp: <CODE>COMPLEX(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>EXP()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC174">Exp Intrinsic</A>.

</P>


<H4><A NAME="SEC337" HREF="g77_toc.html#TOC337">ZLog Intrinsic</A></H4>
<P>
<A NAME="IDX1314"></A>
<A NAME="IDX1315"></A>

</P>
<P>

<PRE>
ZLog(<VAR>X</VAR>)
</PRE>

<P>
ZLog: <CODE>COMPLEX(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>LOG()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC245">Log Intrinsic</A>.

</P>


<H4><A NAME="SEC338" HREF="g77_toc.html#TOC338">ZSin Intrinsic</A></H4>
<P>
<A NAME="IDX1316"></A>
<A NAME="IDX1317"></A>

</P>
<P>

<PRE>
ZSin(<VAR>X</VAR>)
</PRE>

<P>
ZSin: <CODE>COMPLEX(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>SIN()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC304">Sin Intrinsic</A>.

</P>


<H4><A NAME="SEC339" HREF="g77_toc.html#TOC339">ZSqRt Intrinsic</A></H4>
<P>
<A NAME="IDX1318"></A>
<A NAME="IDX1319"></A>

</P>
<P>

<PRE>
ZSqRt(<VAR>X</VAR>)
</PRE>

<P>
ZSqRt: <CODE>COMPLEX(KIND=2)</CODE> function.

</P>
<P>
<VAR>X</VAR>: <CODE>COMPLEX(KIND=2)</CODE>; scalar; INTENT(IN).

</P>
<P>
Intrinsic groups: <CODE>f2c</CODE>.

</P>
<P>
Description:

</P>
<P>
Archaic form of <CODE>SQRT()</CODE> that is specific
to one type for <VAR>X</VAR>.
See section <A HREF="g77_12.html#SEC310">SqRt Intrinsic</A>.

</P>



<H2><A NAME="SEC340" HREF="g77_toc.html#TOC340">Scope and Classes of Symbolic Names</A></H2>
<P>
<A NAME="IDX1320"></A>
<A NAME="IDX1321"></A>

</P>
<P>
(The following information augments or overrides the information in
Chapter 18 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.
Chapter 18 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

</P>

<UL>
<LI><A HREF="g77_12.html#SEC341">Underscores in Symbol Names</A>
</UL>



<H3><A NAME="SEC341" HREF="g77_toc.html#TOC341">Underscores in Symbol Names</A></H3>
<P>
<A NAME="IDX1322"></A>

</P>
<P>
Underscores (<SAMP>`_'</SAMP>) are accepted in symbol names after the first
character (which must be a letter).

</P>


<H2><A NAME="SEC342" HREF="g77_toc.html#TOC342">I/O</A></H2>

<P>
<A NAME="IDX1323"></A>
A dollar sign at the end of an output format specification suppresses
the newline at the end of the output.

</P>
<P>
<A NAME="IDX1324"></A>
<A NAME="IDX1325"></A>
Edit descriptors in <CODE>FORMAT</CODE> statements may contain compile-time
<CODE>INTEGER</CODE> constant expressions in angle brackets, such as

<PRE>
10    FORMAT (I&#60;WIDTH&#62;)
</PRE>

<P>
The <CODE>OPEN</CODE> specifier <CODE>NAME=</CODE> is equivalent to <CODE>FILE=</CODE>.

</P>
<P>
These Fortran 90 features are supported:

<UL>
<LI>

<A NAME="IDX1326"></A>
<A NAME="IDX1327"></A>
<A NAME="IDX1328"></A>
<A NAME="IDX1329"></A>
<A NAME="IDX1330"></A>
The <CODE>O</CODE> and <CODE>Z</CODE> edit descriptors are supported for I/O of
integers in octal and hexadecimal formats, respectively.
<LI>

The <CODE>FILE=</CODE> specifier may be omitted in an <CODE>OPEN</CODE> statement if
<CODE>STATUS='SCRATCH'</CODE> is supplied.  The <CODE>STATUS='REPLACE'</CODE>
specifier is supported.
</UL>



<H2><A NAME="SEC343" HREF="g77_toc.html#TOC343">Fortran 90 Features</A></H2>
<P>
<A NAME="IDX1331"></A>
<A NAME="IDX1332"></A>

</P>
<P>
For convenience this section collects a list (probably incomplete) of
the Fortran 90 features supported by the GNU Fortran language, even if
they are documented elsewhere.
See section `Characters' in <CITE>and Execution Sequence</CITE>,
for information on additional fixed source form lexical issues.
<A NAME="IDX1333"></A>
Further, the free source form is supported through the
<SAMP>`-ffree-form'</SAMP> option.
<A NAME="IDX1334"></A>
Other Fortran 90 features can be turned on by the <SAMP>`-ff90'</SAMP> option;
see section <A HREF="g77_13.html#SEC358">Fortran 90</A>.
For information on the Fortran 90 intrinsics available,
see section <A HREF="g77_12.html#SEC75">Table of Intrinsic Functions</A>.

</P>
<DL COMPACT>

<DT>Automatic arrays in procedures
<DD>
<DT>Character assignments
<DD>
<A NAME="IDX1335"></A>
In character assignments, the variable being assigned may occur on the
right hand side of the assignment.
<DT>Character strings
<DD>
<A NAME="IDX1336"></A>
Strings may have zero length and substrings of character constants are
permitted.  Character constants may be enclosed in double quotes
(<CODE>"</CODE>) as well as single quotes.  See section <A HREF="g77_12.html#SEC55">Character Type</A>.
<DT>Construct names
<DD>
(Symbolic tags on blocks.)  See section <A HREF="g77_12.html#SEC64">Construct Names</A>.
<DT><CODE>CYCLE</CODE> and <CODE>EXIT</CODE>
<DD>
See section <A HREF="g77_12.html#SEC65">The <CODE>CYCLE</CODE> and <CODE>EXIT</CODE> Statements</A>.
<DT><CODE>DOUBLE COMPLEX</CODE>
<DD>
See section <A HREF="g77_12.html#SEC60"><CODE>DOUBLE COMPLEX</CODE> Statement</A>.
<DT><CODE>DO WHILE</CODE>
<DD>
See section <A HREF="g77_12.html#SEC62">DO WHILE</A>.
<DT><CODE>END</CODE> decoration
<DD>
See section <A HREF="g77_12.html#SEC43">Statements</A>.
<DT><CODE>END DO</CODE>
<DD>
See section <A HREF="g77_12.html#SEC63">END DO</A>.
<DT><CODE>KIND</CODE>
<DD>
<DT><CODE>IMPLICIT NONE</CODE>
<DD>
<DT><CODE>INCLUDE</CODE> statements
<DD>
See section <A HREF="g77_12.html#SEC46">Including Source Text</A>.
<DT>List-directed and namelist I/O on internal files
<DD>
<DT>Binary, octal and hexadecimal constants
<DD>
These are supported more generally than required by Fortran 90.
See section <A HREF="g77_12.html#SEC54">Integer Type</A>.
<DT><SAMP>`O'</SAMP> and <SAMP>`Z'</SAMP> edit descriptors
<DD>
<DT><CODE>NAMELIST</CODE>
<DD>
See section <A HREF="g77_12.html#SEC59"><CODE>NAMELIST</CODE> Statement</A>.
<DT><CODE>OPEN</CODE> specifiers
<DD>
<CODE>STATUS='REPLACE'</CODE> is supported.
The <CODE>FILE=</CODE> specifier may be omitted in an <CODE>OPEN</CODE> statement if
<CODE>STATUS='SCRATCH'</CODE> is supplied.
<DT><CODE>FORMAT</CODE> edit descriptors
<DD>
<A NAME="IDX1337"></A>
<A NAME="IDX1338"></A>
<A NAME="IDX1339"></A>
The <CODE>Z</CODE> edit descriptor is supported.
<DT>Relational operators
<DD>
The operators <CODE>&#60;</CODE>, <CODE>&#60;=</CODE>, <CODE>==</CODE>, <CODE>/=</CODE>, <CODE>&#62;</CODE> and
<CODE>&#62;=</CODE> may be used instead of <CODE>.LT.</CODE>, <CODE>.LE.</CODE>, <CODE>.EQ.</CODE>,
<CODE>.NE.</CODE>, <CODE>.GT.</CODE> and <CODE>.GE.</CODE> respectively.
<DT><CODE>SELECT CASE</CODE>
<DD>
Not fully implemented.
See section <A HREF="g77_20.html#SEC610"><CODE>SELECT CASE</CODE> on <CODE>CHARACTER</CODE> Type</A>.
<DT>Specification statements
<DD>
A limited subset of the Fortran 90 syntax and semantics for variable
declarations is supported, including <CODE>KIND</CODE>.  See section <A HREF="g77_12.html#SEC52">Kind Notation</A>.
(<CODE>KIND</CODE> is of limited usefulness in the absence of the
<CODE>KIND</CODE>-related intrinsics, since these intrinsics permit writing
more widely portable code.)  An example of supported <CODE>KIND</CODE> usage
is:

<PRE>
INTEGER (KIND=1) :: FOO=1, BAR=2
CHARACTER (LEN=3) FOO
</PRE>

<CODE>PARAMETER</CODE> and <CODE>DIMENSION</CODE> attributes aren't supported.
</DL>

<P><HR><P>
<p>Go to the <A HREF="g77_1.html">first</A>, <A HREF="g77_11.html">previous</A>, <A HREF="g77_13.html">next</A>, <A HREF="g77_28.html">last</A> section, <A HREF="g77_toc.html">table of contents</A>.
</BODY>
</HTML>
