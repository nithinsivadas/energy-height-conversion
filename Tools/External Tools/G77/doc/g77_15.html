<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.54
     from g77.texi on 30 July 1999 -->

<TITLE>Using and Porting GNU Fortran - Other Compilers</TITLE>
<link href="g77_16.html" rel=Next>
<link href="g77_14.html" rel=Previous>
<link href="g77_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="g77_1.html">first</A>, <A HREF="g77_14.html">previous</A>, <A HREF="g77_16.html">next</A>, <A HREF="g77_28.html">last</A> section, <A HREF="g77_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC518" HREF="g77_toc.html#TOC518">Other Compilers</A></H1>

<P>
An individual Fortran source file can be compiled to
an object (<TT>`*.o'</TT>) file instead of to the final
program executable.
This allows several portions of a program to be compiled
at different times and linked together whenever a new
version of the program is needed.
However, it introduces the issue of <STRONG>object compatibility</STRONG>
across the various object files (and libraries, or <TT>`*.a'</TT>
files) that are linked together to produce any particular
executable file.

</P>
<P>
Object compatibility is an issue when combining, in one
program, Fortran code compiled by more than one compiler
(or more than one configuration of a compiler).
If the compilers
disagree on how to transform the names of procedures, there
will normally be errors when linking such programs.
Worse, if the compilers agree on naming, but disagree on issues
like how to pass parameters, return arguments, and lay out
<CODE>COMMON</CODE> areas, the earliest detected errors might be the
incorrect results produced by the program (and that assumes
these errors are detected, which is not always the case).

</P>
<P>
Normally, <CODE>g77</CODE> generates code that is
object-compatible with code generated by a version of
<CODE>f2c</CODE> configured (with, for example, <TT>`f2c.h'</TT> definitions)
to be generally compatible with <CODE>g77</CODE> as built by <CODE>gcc</CODE>.
(Normally, <CODE>f2c</CODE> will, by default, conform to the appropriate
configuration, but it is possible that older or perhaps even newer
versions of <CODE>f2c</CODE>, or versions having certain configuration changes
to <CODE>f2c</CODE> internals, will produce object files that are
incompatible with <CODE>g77</CODE>.)

</P>
<P>
For example, a Fortran string subroutine
argument will become two arguments on the C side: a <CODE>char *</CODE>
and an <CODE>int</CODE> length.

</P>
<P>
Much of this compatibility results from the fact that
<CODE>g77</CODE> uses the same run-time library,
<CODE>libf2c</CODE>, used by <CODE>f2c</CODE>,
though <CODE>g77</CODE> gives its version the name <CODE>libg2c</CODE>
so as to avoid conflicts when linking,
installing them in the same directories,
and so on.

</P>
<P>
Other compilers might or might not generate code that
is object-compatible with <CODE>libg2c</CODE> and current <CODE>g77</CODE>,
and some might offer such compatibility only when explicitly
selected via a command-line option to the compiler.

</P>
<P>
<EM>Note: This portion of the documentation definitely needs a lot
of work!</EM>

</P>

<UL>
<LI><A HREF="g77_15.html#SEC519">Dropping f2c Compatibility</A>: When speed is more important.
<LI><A HREF="g77_15.html#SEC520">Compilers Other Than f2c</A>: Interoperation with code from other compilers.
</UL>



<H2><A NAME="SEC519" HREF="g77_toc.html#TOC519">Dropping <CODE>f2c</CODE> Compatibility</A></H2>

<P>
Specifying <SAMP>`-fno-f2c'</SAMP> allows <CODE>g77</CODE> to generate, in
some cases, faster code, by not needing to allow to the possibility
of linking with code compiled by <CODE>f2c</CODE>.

</P>
<P>
For example, this affects how <CODE>REAL(KIND=1)</CODE>,
<CODE>COMPLEX(KIND=1)</CODE>, and <CODE>COMPLEX(KIND=2)</CODE> functions are called.
With <SAMP>`-fno-f2c'</SAMP>, they are
compiled as returning the appropriate <CODE>gcc</CODE> type
(<CODE>float</CODE>, <CODE>__complex__ float</CODE>, <CODE>__complex__ double</CODE>,
in many configurations).

</P>
<P>
With <SAMP>`-ff2c'</SAMP> in force, they
are compiled differently (with perhaps slower run-time performance)
to accommodate the restrictions inherent in <CODE>f2c</CODE>'s use of K&#38;R
C as an intermediate language---<CODE>REAL(KIND=1)</CODE> functions
return C's <CODE>double</CODE> type, while <CODE>COMPLEX</CODE> functions return
<CODE>void</CODE> and use an extra argument pointing to a place for the functions to
return their values.

</P>
<P>
It is possible that, in some cases, leaving <SAMP>`-ff2c'</SAMP> in force
might produce faster code than using <SAMP>`-fno-f2c'</SAMP>.
Feel free to experiment, but remember to experiment with changing the way
<EM>entire programs and their Fortran libraries are compiled</EM> at
a time, since this sort of experimentation affects the interface
of code generated for a Fortran source file--that is, it affects
object compatibility.

</P>
<P>
Note that <CODE>f2c</CODE> compatibility is a fairly static target to achieve,
though not necessarily perfectly so, since, like <CODE>g77</CODE>, it is
still being improved.
However, specifying <SAMP>`-fno-f2c'</SAMP> causes <CODE>g77</CODE>
to generate code that will probably be incompatible with code
generated by future versions of <CODE>g77</CODE> when the same option
is in force.
You should make sure you are always able to recompile complete
programs from source code when upgrading to new versions of <CODE>g77</CODE>
or <CODE>f2c</CODE>, especially when using options such as <SAMP>`-fno-f2c'</SAMP>.

</P>
<P>
Therefore, if you are using <CODE>g77</CODE> to compile libraries and other
object files for possible future use and you don't want to require
recompilation for future use with subsequent versions of <CODE>g77</CODE>,
you might want to stick with <CODE>f2c</CODE> compatibility for now, and
carefully watch for any announcements about changes to the
<CODE>f2c</CODE>/<CODE>libf2c</CODE> interface that might affect existing programs
(thus requiring recompilation).

</P>
<P>
It is probable that a future version of <CODE>g77</CODE> will not,
by default, generate object files compatible with <CODE>f2c</CODE>,
and that version probably would no longer use <CODE>libf2c</CODE>.
If you expect to depend on this compatibility in the
long term, use the options <SAMP>`-ff2c -ff2c-library'</SAMP> when compiling
all of the applicable code.
This should cause future versions of <CODE>g77</CODE> either to produce
compatible code (at the expense of the availability of some features and
performance), or at the very least, to produce diagnostics.

</P>
<P>
(The library <CODE>g77</CODE> produces will no longer be named <TT>`libg2c'</TT>
when it is no longer generally compatible with <TT>`libf2c'</TT>.
It will likely be referred to, and, if installed as a distinct
library, named <CODE>libg77</CODE>, or some other as-yet-unused name.)

</P>


<H2><A NAME="SEC520" HREF="g77_toc.html#TOC520">Compilers Other Than <CODE>f2c</CODE></A></H2>

<P>
On systems with Fortran compilers other than <CODE>f2c</CODE> and <CODE>g77</CODE>,
code compiled by <CODE>g77</CODE> is not expected to work
well with code compiled by the native compiler.
(This is true for <CODE>f2c</CODE>-compiled objects as well.)
Libraries compiled with the native compiler probably will have
to be recompiled with <CODE>g77</CODE> to be used with <CODE>g77</CODE>-compiled code.

</P>
<P>
Reasons for such incompatibilities include:

</P>

<UL>
<LI>

There might be differences in the way names of Fortran procedures
are translated for use in the system's object-file format.
For example, the statement <SAMP>`CALL FOO'</SAMP> might be compiled
by <CODE>g77</CODE> to call a procedure the linker <CODE>ld</CODE> sees
given the name <SAMP>`_foo_'</SAMP>, while the apparently corresponding
statement <SAMP>`SUBROUTINE FOO'</SAMP> might be compiled by the
native compiler to define the linker-visible name <SAMP>`_foo'</SAMP>,
or <SAMP>`_FOO_'</SAMP>, and so on.

<LI>

There might be subtle type mismatches which cause subroutine arguments
and function return values to get corrupted.

This is why simply getting <CODE>g77</CODE> to
transform procedure names the same way a native
compiler does is not usually a good idea--unless
some effort has been made to ensure that, aside
from the way the two compilers transform procedure
names, everything else about the way they generate
code for procedure interfaces is identical.

<LI>

Native compilers
use libraries of private I/O routines which will not be available
at link time unless you have the native compiler--and you would
have to explicitly ask for them.

For example, on the Sun you
would have to add <SAMP>`-L/usr/lang/SCx.x -lF77 -lV77'</SAMP> to the link
command.
</UL>

<P><HR><P>
<p>Go to the <A HREF="g77_1.html">first</A>, <A HREF="g77_14.html">previous</A>, <A HREF="g77_16.html">next</A>, <A HREF="g77_28.html">last</A> section, <A HREF="g77_toc.html">table of contents</A>.
</BODY>
</HTML>
