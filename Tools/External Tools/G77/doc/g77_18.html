<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.54
     from g77.texi on 30 July 1999 -->

<TITLE>Using and Porting GNU Fortran - Debugging and Interfacing</TITLE>
<link href="g77_19.html" rel=Next>
<link href="g77_17.html" rel=Previous>
<link href="g77_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="g77_1.html">first</A>, <A HREF="g77_17.html">previous</A>, <A HREF="g77_19.html">next</A>, <A HREF="g77_28.html">last</A> section, <A HREF="g77_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC550" HREF="g77_toc.html#TOC550">Debugging and Interfacing</A></H1>
<P>
<A NAME="IDX1873"></A>
<A NAME="IDX1874"></A>
<A NAME="IDX1875"></A>
<A NAME="IDX1876"></A>
<A NAME="IDX1877"></A>

</P>
<P>
GNU Fortran currently generates code that is object-compatible with
the <CODE>f2c</CODE> converter.
Also, it avoids limitations in the current GBE, such as the
inability to generate a procedure with
multiple entry points, by generating code that is structured
differently (in terms of procedure names, scopes, arguments, and
so on) than might be expected.

</P>
<P>
As a result, writing code in other languages that calls on, is
called by, or shares in-memory data with <CODE>g77</CODE>-compiled code generally
requires some understanding of the way <CODE>g77</CODE> compiles code for
various constructs.

</P>
<P>
Similarly, using a debugger to debug <CODE>g77</CODE>-compiled
code, even if that debugger supports native Fortran debugging, generally
requires this sort of information.

</P>
<P>
This section describes some of the basic information on how
<CODE>g77</CODE> compiles code for constructs involving interfaces to other
languages and to debuggers.

</P>
<P>
<EM>Caution:</EM> Much or all of this information pertains to only the current
release of <CODE>g77</CODE>, sometimes even to using certain compiler options
with <CODE>g77</CODE> (such as <SAMP>`-fno-f2c'</SAMP>).
Do not write code that depends on this
information without clearly marking said code as nonportable and
subject to review for every new release of <CODE>g77</CODE>.
This information
is provided primarily to make debugging of code generated by this
particular release of <CODE>g77</CODE> easier for the user, and partly to make
writing (generally nonportable) interface code easier.
Both of these
activities require tracking changes in new version of <CODE>g77</CODE> as they
are installed, because new versions can change the behaviors
described in this section.

</P>

<UL>
<LI><A HREF="g77_18.html#SEC551">Main Program Unit</A>: How <CODE>g77</CODE> compiles a main program unit.
<LI><A HREF="g77_18.html#SEC552">Procedures</A>: How <CODE>g77</CODE> constructs parameter lists
                       for procedures.
<LI><A HREF="g77_18.html#SEC553">Functions</A>: Functions returning floating-point or character data.
<LI><A HREF="g77_18.html#SEC554">Names</A>: Naming of user-defined variables, procedures, etc.
<LI><A HREF="g77_18.html#SEC555">Common Blocks</A>: Accessing common variables while debugging.
<LI><A HREF="g77_18.html#SEC556">Local Equivalence Areas</A>: Accessing <CODE>EQUIVALENCE</CODE> while debugging.
<LI><A HREF="g77_18.html#SEC557">Complex Variables</A>: How <CODE>g77</CODE> performs complex arithmetic.
<LI><A HREF="g77_18.html#SEC558">Arrays</A>: Dealing with (possibly multi-dimensional) arrays.
<LI><A HREF="g77_18.html#SEC559">Adjustable Arrays</A>: Special consideration for adjustable arrays.
<LI><A HREF="g77_18.html#SEC560">Alternate Entry Points</A>: How <CODE>g77</CODE> implements alternate <CODE>ENTRY</CODE>.
<LI><A HREF="g77_18.html#SEC561">Alternate Returns</A>: How <CODE>g77</CODE> handles alternate returns.
<LI><A HREF="g77_18.html#SEC562">Assigned Statement Labels</A>: How <CODE>g77</CODE> handles <CODE>ASSIGN</CODE>.
<LI><A HREF="g77_18.html#SEC563">Run-time Library Errors</A>: Meanings of some <CODE>IOSTAT=</CODE> values.
</UL>



<H2><A NAME="SEC551" HREF="g77_toc.html#TOC551">Main Program Unit (PROGRAM)</A></H2>
<P>
<A NAME="IDX1878"></A>
<A NAME="IDX1879"></A>

</P>
<P>
When <CODE>g77</CODE> compiles a main program unit, it gives it the public
procedure name <CODE>MAIN__</CODE>.
The <CODE>libg2c</CODE> library has the actual <CODE>main()</CODE> procedure
as is typical of C-based environments, and
it is this procedure that performs some initial start-up
activity and then calls <CODE>MAIN__</CODE>.

</P>
<P>
Generally, <CODE>g77</CODE> and <CODE>libg2c</CODE> are designed so that you need not
include a main program unit written in Fortran in your program--it
can be written in C or some other language.
Especially for I/O handling, this is the case, although <CODE>g77</CODE> version 0.5.16
includes a bug fix for <CODE>libg2c</CODE> that solved a problem with using the
<CODE>OPEN</CODE> statement as the first Fortran I/O activity in a program
without a Fortran main program unit.

</P>
<P>
However, if you don't intend to use <CODE>g77</CODE> (or <CODE>f2c</CODE>) to compile
your main program unit--that is, if you intend to compile a <CODE>main()</CODE>
procedure using some other language--you should carefully
examine the code for <CODE>main()</CODE> in <CODE>libg2c</CODE>, found in the source
file <TT>`egcs/libf2c/libF77/main.c'</TT>, to see what kinds of things
might need to be done by your <CODE>main()</CODE> in order to provide the
Fortran environment your Fortran code is expecting.

</P>
<P>
<A NAME="IDX1880"></A>
<A NAME="IDX1881"></A>
<A NAME="IDX1882"></A>
<A NAME="IDX1883"></A>
For example, <CODE>libg2c</CODE>'s <CODE>main()</CODE> sets up the information used by
the <CODE>IARGC</CODE> and <CODE>GETARG</CODE> intrinsics.
Bypassing <CODE>libg2c</CODE>'s <CODE>main()</CODE>
without providing a substitute for this activity would mean
that invoking <CODE>IARGC</CODE> and <CODE>GETARG</CODE> would produce undefined
results.

</P>
<P>
<A NAME="IDX1884"></A>
<A NAME="IDX1885"></A>
<A NAME="IDX1886"></A>
<A NAME="IDX1887"></A>
<A NAME="IDX1888"></A>
When debugging, one implication of the fact that <CODE>main()</CODE>, which
is the place where the debugged program "starts" from the
debugger's point of view, is in <CODE>libg2c</CODE> is that you won't be
starting your Fortran program at a point you recognize as your
Fortran code.

</P>
<P>
The standard way to get around this problem is to set a break
point (a one-time, or temporary, break point will do) at
the entrance to <CODE>MAIN__</CODE>, and then run the program.
A convenient way to do so is to add the <CODE>gdb</CODE> command

</P>

<PRE>
tbreak MAIN__
</PRE>

<P>
to the file <TT>`.gdbinit'</TT> in the directory in which you're debugging
(using <CODE>gdb</CODE>).

</P>
<P>
After doing this, the debugger will see the current execution
point of the program as at the beginning of the main program
unit of your program.

</P>
<P>
Of course, if you really want to set a break point at some
other place in your program and just start the program
running, without first breaking at <CODE>MAIN__</CODE>,
that should work fine.

</P>


<H2><A NAME="SEC552" HREF="g77_toc.html#TOC552">Procedures (SUBROUTINE and FUNCTION)</A></H2>
<P>
<A NAME="IDX1889"></A>
<A NAME="IDX1890"></A>
<A NAME="IDX1891"></A>
<A NAME="IDX1892"></A>
<A NAME="IDX1893"></A>
<A NAME="IDX1894"></A>

</P>
<P>
Currently, <CODE>g77</CODE> passes arguments via reference--specifically,
by passing a pointer to the location in memory of a variable, array,
array element, a temporary location that holds the result of evaluating an
expression, or a temporary or permanent location that holds the value
of a constant.

</P>
<P>
Procedures that accept <CODE>CHARACTER</CODE> arguments are implemented by
<CODE>g77</CODE> so that each <CODE>CHARACTER</CODE> argument has two actual arguments.

</P>
<P>
The first argument occupies the expected position in the
argument list and has the user-specified name.
This argument
is a pointer to an array of characters, passed by the caller.

</P>
<P>
The second argument is appended to the end of the user-specified
calling sequence and is named <SAMP>`__g77_length_<VAR>x</VAR>'</SAMP>, where <VAR>x</VAR>
is the user-specified name.
This argument is of the C type <CODE>ftnlen</CODE>
(see <TT>`egcs/libf2c/g2c.h.in'</TT> for information on that type) and
is the number of characters the caller has allocated in the
array pointed to by the first argument.

</P>
<P>
A procedure will ignore the length argument if <SAMP>`X'</SAMP> is not declared
<CODE>CHARACTER*(*)</CODE>, because for other declarations, it knows the
length.
Not all callers necessarily "know" this, however, which
is why they all pass the extra argument.

</P>
<P>
The contents of the <CODE>CHARACTER</CODE> argument are specified by the
address passed in the first argument (named after it).
The procedure can read or write these contents as appropriate.

</P>
<P>
When more than one <CODE>CHARACTER</CODE> argument is present in the argument
list, the length arguments are appended in the order
the original arguments appear.
So <SAMP>`CALL FOO('HI','THERE')'</SAMP> is implemented in
C as <SAMP>`foo("hi","there",2,5);'</SAMP>, ignoring the fact that <CODE>g77</CODE>
does not provide the trailing null bytes on the constant
strings (<CODE>f2c</CODE> does provide them, but they are unnecessary in
a Fortran environment, and you should not expect them to be
there).

</P>
<P>
Note that the above information applies to <CODE>CHARACTER</CODE> variables and
arrays <STRONG>only</STRONG>.
It does <STRONG>not</STRONG> apply to external <CODE>CHARACTER</CODE>
functions or to intrinsic <CODE>CHARACTER</CODE> functions.
That is, no second length argument is passed to <SAMP>`FOO'</SAMP> in this case:

</P>

<PRE>
CHARACTER X
EXTERNAL X
CALL FOO(X)
</PRE>

<P>
Nor does <SAMP>`FOO'</SAMP> expect such an argument in this case:

</P>

<PRE>
SUBROUTINE FOO(X)
CHARACTER X
EXTERNAL X
</PRE>

<P>
Because of this implementation detail, if a program has a bug
such that there is disagreement as to whether an argument is
a procedure, and the type of the argument is <CODE>CHARACTER</CODE>, subtle
symptoms might appear.

</P>


<H2><A NAME="SEC553" HREF="g77_toc.html#TOC553">Functions (FUNCTION and RETURN)</A></H2>
<P>
<A NAME="IDX1895"></A>
<A NAME="IDX1896"></A>
<A NAME="IDX1897"></A>
<A NAME="IDX1898"></A>
<A NAME="IDX1899"></A>
<A NAME="IDX1900"></A>

</P>
<P>
<CODE>g77</CODE> handles in a special way functions that return the following
types:

</P>

<UL>
<LI>

<CODE>CHARACTER</CODE>
<LI>

<CODE>COMPLEX</CODE>
<LI>

<CODE>REAL(KIND=1)</CODE>
</UL>

<P>
For <CODE>CHARACTER</CODE>, <CODE>g77</CODE> implements a subroutine (a C function
returning <CODE>void</CODE>)
with two arguments prepended: <SAMP>`__g77_result'</SAMP>, which the caller passes
as a pointer to a <CODE>char</CODE> array expected to hold the return value,
and <SAMP>`__g77_length'</SAMP>, which the caller passes as an <CODE>ftnlen</CODE> value
specifying the length of the return value as declared in the calling
program.
For <CODE>CHARACTER*(*)</CODE>, the called function uses <SAMP>`__g77_length'</SAMP>
to determine the size of the array that <SAMP>`__g77_result'</SAMP> points to;
otherwise, it ignores that argument.

</P>
<P>
For <CODE>COMPLEX</CODE>, when <SAMP>`-ff2c'</SAMP> is in
force, <CODE>g77</CODE> implements
a subroutine with one argument prepended: <SAMP>`__g77_result'</SAMP>, which the
caller passes as a pointer to a variable of the type of the function.
The called function writes the return value into this variable instead
of returning it as a function value.
When <SAMP>`-fno-f2c'</SAMP> is in force,
<CODE>g77</CODE> implements a <CODE>COMPLEX</CODE> function as <CODE>gcc</CODE>'s
<SAMP>`__complex__ float'</SAMP> or <SAMP>`__complex__ double'</SAMP> function
(or an emulation thereof, when <SAMP>`-femulate-complex'</SAMP> is in effect),
returning the result of the function in the same way as <CODE>gcc</CODE> would.

</P>
<P>
For <CODE>REAL(KIND=1)</CODE>, when <SAMP>`-ff2c'</SAMP> is in force, <CODE>g77</CODE> implements
a function that actually returns <CODE>REAL(KIND=2)</CODE> (typically
C's <CODE>double</CODE> type).
When <SAMP>`-fno-f2c'</SAMP> is in force, <CODE>REAL(KIND=1)</CODE>
functions return <CODE>float</CODE>.

</P>


<H2><A NAME="SEC554" HREF="g77_toc.html#TOC554">Names</A></H2>
<P>
<A NAME="IDX1901"></A>
<A NAME="IDX1902"></A>

</P>
<P>
Fortran permits each implementation to decide how to represent
names as far as how they're seen in other contexts, such as debuggers
and when interfacing to other languages, and especially as far
as how casing is handled.

</P>
<P>
External names--names of entities that are public, or "accessible",
to all modules in a program--normally have an underscore (<SAMP>`_'</SAMP>)
appended by <CODE>g77</CODE>,
to generate code that is compatible with <CODE>f2c</CODE>.
External names include names of Fortran things like common blocks,
external procedures (subroutines and functions, but not including
statement functions, which are internal procedures), and entry point
names.

</P>
<P>
However, use of the <SAMP>`-fno-underscoring'</SAMP> option
disables this kind of transformation of external names (though inhibiting
the transformation certainly improves the chances of colliding with
incompatible externals written in other languages--but that
might be intentional.

</P>
<P>
<A NAME="IDX1903"></A>
<A NAME="IDX1904"></A>
<A NAME="IDX1905"></A>
<A NAME="IDX1906"></A>
When <SAMP>`-funderscoring'</SAMP> is in force, any name (external or local)
that already has at least one underscore in it is
implemented by <CODE>g77</CODE> by appending two underscores.
(This second underscore can be disabled via the
<SAMP>`-fno-second-underscore'</SAMP> option.)
External names are changed this way for <CODE>f2c</CODE> compatibility.
Local names are changed this way to avoid collisions with external names
that are different in the source code---<CODE>f2c</CODE> does the same thing, but
there's no compatibility issue there except for user expectations while
debugging.

</P>
<P>
For example:

</P>

<PRE>
Max_Cost = 0
</PRE>

<P>
<A NAME="IDX1907"></A>
Here, a user would, in the debugger, refer to this variable using the
name <SAMP>`max_cost__'</SAMP> (or <SAMP>`MAX_COST__'</SAMP> or <SAMP>`Max_Cost__'</SAMP>,
as described below).
(We hope to improve <CODE>g77</CODE> in this regard in the future--don't
write scripts depending on this behavior!
Also, consider experimenting with the <SAMP>`-fno-underscoring'</SAMP>
option to try out debugging without having to massage names by
hand like this.)

</P>
<P>
<CODE>g77</CODE> provides a number of command-line options that allow the user
to control how case mapping is handled for source files.
The default is the traditional UNIX model for Fortran compilers--names
are mapped to lower case.
Other command-line options can be specified to map names to upper
case, or to leave them exactly as written in the source file.

</P>
<P>
For example:

</P>

<PRE>
Foo = 9.436
</PRE>

<P>
Here, it is normally the case that the variable assigned will be named
<SAMP>`foo'</SAMP>.
This would be the name to enter when using a debugger to
access the variable.

</P>
<P>
However, depending on the command-line options specified, the
name implemented by <CODE>g77</CODE> might instead be <SAMP>`FOO'</SAMP> or even
<SAMP>`Foo'</SAMP>, thus affecting how debugging is done.

</P>
<P>
Also:

</P>

<PRE>
Call Foo
</PRE>

<P>
This would normally call a procedure that, if it were in a separate C program,
be defined starting with the line:

</P>

<PRE>
void foo_()
</PRE>

<P>
However, <CODE>g77</CODE> command-line options could be used to change the casing
of names, resulting in the name <SAMP>`FOO_'</SAMP> or <SAMP>`Foo_'</SAMP> being given to the
procedure instead of <SAMP>`foo_'</SAMP>, and the <SAMP>`-fno-underscoring'</SAMP> option
could be used to inhibit the appending of the underscore to the name.

</P>


<H2><A NAME="SEC555" HREF="g77_toc.html#TOC555">Common Blocks (COMMON)</A></H2>
<P>
<A NAME="IDX1908"></A>
<A NAME="IDX1909"></A>
<A NAME="IDX1910"></A>

</P>
<P>
<CODE>g77</CODE> names and lays out <CODE>COMMON</CODE> areas
the same way <CODE>f2c</CODE> does,
for compatibility with <CODE>f2c</CODE>.

</P>
<P>
Currently, <CODE>g77</CODE> does not emit "true" debugging information for
members of a <CODE>COMMON</CODE> area, due to an apparent bug in the GBE.

</P>
<P>
(As of Version 0.5.19, <CODE>g77</CODE> emits debugging information for such
members in the form of a constant string specifying the base name of
the aggregate area and the offset of the member in bytes from the start
of the area.
Use the <SAMP>`-fdebug-kludge'</SAMP> option to enable this behavior.
In <CODE>gdb</CODE>, use <SAMP>`set language c'</SAMP> before printing the value
of the member, then <SAMP>`set language fortran'</SAMP> to restore the default
language, since <CODE>gdb</CODE> doesn't provide a way to print a readable
version of a character string in Fortran language mode.

</P>
<P>
This kludge will be removed in a future version of <CODE>g77</CODE> that,
in conjunction with a contemporary version of <CODE>gdb</CODE>,
properly supports Fortran-language debugging, including access
to members of <CODE>COMMON</CODE> areas.)

</P>
<P>
See section <A HREF="g77_9.html#SEC22">Options for Code Generation Conventions</A>,
for information on the <SAMP>`-fdebug-kludge'</SAMP> option.

</P>
<P>
Moreover, <CODE>g77</CODE> currently implements a <CODE>COMMON</CODE> area such that its
type is an array of the C <CODE>char</CODE> data type.

</P>
<P>
So, when debugging, you must know the offset into a <CODE>COMMON</CODE> area
for a particular item in that area, and you have to take into
account the appropriate multiplier for the respective sizes
of the types (as declared in your code) for the items preceding
the item in question as compared to the size of the <CODE>char</CODE> type.

</P>
<P>
For example, using default implicit typing, the statement

</P>

<PRE>
COMMON I(15), R(20), T
</PRE>

<P>
results in a public 144-byte <CODE>char</CODE> array named <SAMP>`_BLNK__'</SAMP>
with <SAMP>`I'</SAMP> placed at <SAMP>`_BLNK__[0]'</SAMP>, <SAMP>`R'</SAMP> at <SAMP>`_BLNK__[60]'</SAMP>,
and <SAMP>`T'</SAMP> at <SAMP>`_BLNK__[140]'</SAMP>.
(This is assuming that the target machine for
the compilation has 4-byte <CODE>INTEGER(KIND=1)</CODE> and <CODE>REAL(KIND=1)</CODE>
types.)

</P>


<H2><A NAME="SEC556" HREF="g77_toc.html#TOC556">Local Equivalence Areas (EQUIVALENCE)</A></H2>
<P>
<A NAME="IDX1911"></A>
<A NAME="IDX1912"></A>
<A NAME="IDX1913"></A>
<A NAME="IDX1914"></A>

</P>
<P>
<CODE>g77</CODE> treats storage-associated areas involving a <CODE>COMMON</CODE>
block as explained in the section on common blocks.

</P>
<P>
A local <CODE>EQUIVALENCE</CODE> area is a collection of variables and arrays
connected to each other in any way via <CODE>EQUIVALENCE</CODE>, none of which are
listed in a <CODE>COMMON</CODE> statement.

</P>
<P>
Currently, <CODE>g77</CODE> does not emit "true" debugging information for
members in a local <CODE>EQUIVALENCE</CODE> area, due to an apparent bug in the GBE.

</P>
<P>
(As of Version 0.5.19, <CODE>g77</CODE> does emit debugging information for such
members in the form of a constant string specifying the base name of
the aggregate area and the offset of the member in bytes from the start
of the area.
Use the <SAMP>`-fdebug-kludge'</SAMP> option to enable this behavior.
In <CODE>gdb</CODE>, use <SAMP>`set language c'</SAMP> before printing the value
of the member, then <SAMP>`set language fortran'</SAMP> to restore the default
language, since <CODE>gdb</CODE> doesn't provide a way to print a readable
version of a character string in Fortran language mode.

</P>
<P>
This kludge will be removed in a future version of <CODE>g77</CODE> that,
in conjunction with a contemporary version of <CODE>gdb</CODE>,
properly supports Fortran-language debugging, including access
to members of <CODE>EQUIVALENCE</CODE> areas.)

</P>
<P>
See section <A HREF="g77_9.html#SEC22">Options for Code Generation Conventions</A>,
for information on the <SAMP>`-fdebug-kludge'</SAMP> option.

</P>
<P>
Moreover, <CODE>g77</CODE> implements a local <CODE>EQUIVALENCE</CODE> area such that its
type is an array of the C <CODE>char</CODE> data type.

</P>
<P>
The name <CODE>g77</CODE> gives this array of <CODE>char</CODE> type is <SAMP>`__g77_equiv_<VAR>x</VAR>'</SAMP>,
where <VAR>x</VAR> is the name of the item that is placed at the beginning (offset 0)
of this array.
If more than one such item is placed at the beginning, <VAR>x</VAR> is
the name that sorts to the top in an alphabetical sort of the list of
such items.

</P>
<P>
When debugging, you must therefore access members of <CODE>EQUIVALENCE</CODE>
areas by specifying the appropriate <SAMP>`__g77_equiv_<VAR>x</VAR>'</SAMP>
array section with the appropriate offset.
See the explanation of debugging <CODE>COMMON</CODE> blocks
for info applicable to debugging local <CODE>EQUIVALENCE</CODE> areas.

</P>
<P>
(<EM>Note:</EM> <CODE>g77</CODE> version 0.5.18 and earlier chose the name
for <VAR>x</VAR> using a different method when more than one name was
in the list of names of entities placed at the beginning of the
array.
Though the documentation specified that the first name listed in
the <CODE>EQUIVALENCE</CODE> statements was chosen for <VAR>x</VAR>, <CODE>g77</CODE>
in fact chose the name using a method that was so complicated,
it seemed easier to change it to an alphabetical sort than to describe the
previous method in the documentation.)

</P>


<H2><A NAME="SEC557" HREF="g77_toc.html#TOC557">Complex Variables (COMPLEX)</A></H2>
<P>
<A NAME="IDX1915"></A>
<A NAME="IDX1916"></A>
<A NAME="IDX1917"></A>
<A NAME="IDX1918"></A>

</P>
<P>
As of 0.5.20, <CODE>g77</CODE> defaults to handling <CODE>COMPLEX</CODE> types
(and related intrinsics, constants, functions, and so on)
in a manner that
makes direct debugging involving these types in Fortran
language mode difficult.

</P>
<P>
Essentially, <CODE>g77</CODE> implements these types using an
internal construct similar to C's <CODE>struct</CODE>, at least
as seen by the <CODE>gcc</CODE> back end.

</P>
<P>
Currently, the back end, when outputting debugging info with
the compiled code for the assembler to digest, does not detect
these <CODE>struct</CODE> types as being substitutes for Fortran
complex.
As a result, the Fortran language modes of debuggers such as
<CODE>gdb</CODE> see these types as C <CODE>struct</CODE> types, which
they might or might not support.

</P>
<P>
Until this is fixed, switch to C language mode to work with
entities of <CODE>COMPLEX</CODE> type and then switch back to Fortran language
mode afterward.
(In <CODE>gdb</CODE>, this is accomplished via <SAMP>`set lang c'</SAMP> and
either <SAMP>`set lang fortran'</SAMP> or <SAMP>`set lang auto'</SAMP>.)

</P>


<H2><A NAME="SEC558" HREF="g77_toc.html#TOC558">Arrays (DIMENSION)</A></H2>
<P>
<A NAME="IDX1919"></A>
<A NAME="IDX1920"></A>
<A NAME="IDX1921"></A>
<A NAME="IDX1922"></A>
<A NAME="IDX1923"></A>
<A NAME="IDX1924"></A>
<A NAME="IDX1925"></A>

</P>
<P>
Fortran uses "column-major ordering" in its arrays.
This differs from other languages, such as C, which use "row-major ordering".
The difference is that, with Fortran, array elements adjacent to
each other in memory differ in the <EM>first</EM> subscript instead of
the last; <SAMP>`A(5,10,20)'</SAMP> immediately follows <SAMP>`A(4,10,20)'</SAMP>,
whereas with row-major ordering it would follow <SAMP>`A(5,10,19)'</SAMP>.

</P>
<P>
This consideration
affects not only interfacing with and debugging Fortran code,
it can greatly affect how code is designed and written, especially
when code speed and size is a concern.

</P>
<P>
Fortran also differs from C, a popular language for interfacing and
to support directly in debuggers, in the way arrays are treated.
In C, arrays are single-dimensional and have interesting relationships
to pointers, neither of which is true for Fortran.
As a result, dealing with Fortran arrays from within
an environment limited to C concepts can be challenging.

</P>
<P>
For example, accessing the array element <SAMP>`A(5,10,20)'</SAMP> is easy enough
in Fortran (use <SAMP>`A(5,10,20)'</SAMP>), but in C some difficult machinations
are needed.
First, C would treat the A array as a single-dimension array.
Second, C does not understand low bounds for arrays as does Fortran.
Third, C assumes a low bound of zero (0), while Fortran defaults to a
low bound of one (1) and can supports an arbitrary low bound.
Therefore, calculations must be done
to determine what the C equivalent of <SAMP>`A(5,10,20)'</SAMP> would be, and these
calculations require knowing the dimensions of <SAMP>`A'</SAMP>.

</P>
<P>
For <SAMP>`DIMENSION A(2:11,21,0:29)'</SAMP>, the calculation of the offset of
<SAMP>`A(5,10,20)'</SAMP> would be:

</P>

<PRE>
  (5-2)
+ (10-1)*(11-2+1)
+ (20-0)*(11-2+1)*(21-1+1)
= 4293
</PRE>

<P>
So the C equivalent in this case would be <SAMP>`a[4293]'</SAMP>.

</P>
<P>
When using a debugger directly on Fortran code, the C equivalent
might not work, because some debuggers cannot understand the notion
of low bounds other than zero.  However, unlike <CODE>f2c</CODE>, <CODE>g77</CODE>
does inform the GBE that a multi-dimensional array (like <SAMP>`A'</SAMP>
in the above example) is really multi-dimensional, rather than a
single-dimensional array, so at least the dimensionality of the array
is preserved.

</P>
<P>
Debuggers that understand Fortran should have no trouble with
non-zero low bounds, but for non-Fortran debuggers, especially
C debuggers, the above example might have a C equivalent of
<SAMP>`a[4305]'</SAMP>.
This calculation is arrived at by eliminating the subtraction
of the lower bound in the first parenthesized expression on each
line--that is, for <SAMP>`(5-2)'</SAMP> substitute <SAMP>`(5)'</SAMP>, for <SAMP>`(10-1)'</SAMP>
substitute <SAMP>`(10)'</SAMP>, and for <SAMP>`(20-0)'</SAMP> substitute <SAMP>`(20)'</SAMP>.
Actually, the implication of
this can be that the expression <SAMP>`*(&#38;a[2][1][0] + 4293)'</SAMP> works fine,
but that <SAMP>`a[20][10][5]'</SAMP> produces the equivalent of
<SAMP>`*(&#38;a[0][0][0] + 4305)'</SAMP> because of the missing lower bounds.

</P>
<P>
Come to think of it, perhaps
the behavior is due to the debugger internally compensating for
the lower bounds by offsetting the base address of <SAMP>`a'</SAMP>, leaving
<SAMP>`&#38;a'</SAMP> set lower, in this case, than <SAMP>`&#38;a[2][1][0]'</SAMP> (the address of
its first element as identified by subscripts equal to the
corresponding lower bounds).

</P>
<P>
You know, maybe nobody really needs to use arrays.

</P>


<H2><A NAME="SEC559" HREF="g77_toc.html#TOC559">Adjustable Arrays (DIMENSION)</A></H2>
<P>
<A NAME="IDX1926"></A>
<A NAME="IDX1927"></A>
<A NAME="IDX1928"></A>
<A NAME="IDX1929"></A>
<A NAME="IDX1930"></A>
<A NAME="IDX1931"></A>
<A NAME="IDX1932"></A>
<A NAME="IDX1933"></A>

</P>
<P>
Adjustable and automatic arrays in Fortran require the implementation
(in this
case, the <CODE>g77</CODE> compiler) to "memorize" the expressions that
dimension the arrays each time the procedure is invoked.
This is so that subsequent changes to variables used in those
expressions, made during execution of the procedure, do not
have any effect on the dimensions of those arrays.

</P>
<P>
For example:

</P>

<PRE>
REAL ARRAY(5)
DATA ARRAY/5*2/
CALL X(ARRAY, 5)
END
SUBROUTINE X(A, N)
DIMENSION A(N)
N = 20
PRINT *, N, A
END
</PRE>

<P>
Here, the implementation should, when running the program, print something
like:

</P>

<PRE>
20   2.  2.  2.  2.  2.
</PRE>

<P>
Note that this shows that while the value of <SAMP>`N'</SAMP> was successfully
changed, the size of the <SAMP>`A'</SAMP> array remained at 5 elements.

</P>
<P>
To support this, <CODE>g77</CODE> generates code that executes before any user
code (and before the internally generated computed <CODE>GOTO</CODE> to handle
alternate entry points, as described below) that evaluates each
(nonconstant) expression in the list of subscripts for an
array, and saves the result of each such evaluation to be used when
determining the size of the array (instead of re-evaluating the
expressions).

</P>
<P>
So, in the above example, when <SAMP>`X'</SAMP> is first invoked, code is
executed that copies the value of <SAMP>`N'</SAMP> to a temporary.
And that same temporary serves as the actual high bound for the single
dimension of the <SAMP>`A'</SAMP> array (the low bound being the constant 1).
Since the user program cannot (legitimately) change the value
of the temporary during execution of the procedure, the size
of the array remains constant during each invocation.

</P>
<P>
For alternate entry points, the code <CODE>g77</CODE> generates takes into
account the possibility that a dummy adjustable array is not actually
passed to the actual entry point being invoked at that time.
In that case, the public procedure implementing the entry point
passes to the master private procedure implementing all the
code for the entry points a <CODE>NULL</CODE> pointer where a pointer to that
adjustable array would be expected.
The <CODE>g77</CODE>-generated code
doesn't attempt to evaluate any of the expressions in the subscripts
for an array if the pointer to that array is <CODE>NULL</CODE> at run time in
such cases.
(Don't depend on this particular implementation
by writing code that purposely passes <CODE>NULL</CODE> pointers where the
callee expects adjustable arrays, even if you know the callee
won't reference the arrays--nor should you pass <CODE>NULL</CODE> pointers
for any dummy arguments used in calculating the bounds of such
arrays or leave undefined any values used for that purpose in
COMMON--because the way <CODE>g77</CODE> implements these things might
change in the future!)

</P>


<H2><A NAME="SEC560" HREF="g77_toc.html#TOC560">Alternate Entry Points (ENTRY)</A></H2>
<P>
<A NAME="IDX1934"></A>
<A NAME="IDX1935"></A>
<A NAME="IDX1936"></A>
<A NAME="IDX1937"></A>

</P>
<P>
The GBE does not understand the general concept of
alternate entry points as Fortran provides via the ENTRY statement.
<CODE>g77</CODE> gets around this by using an approach to compiling procedures
having at least one <CODE>ENTRY</CODE> statement that is almost identical to the
approach used by <CODE>f2c</CODE>.
(An alternate approach could be used that
would probably generate faster, but larger, code that would also
be a bit easier to debug.)

</P>
<P>
Information on how <CODE>g77</CODE> implements <CODE>ENTRY</CODE> is provided for those
trying to debug such code.
The choice of implementation seems
unlikely to affect code (compiled in other languages) that interfaces
to such code.

</P>
<P>
<CODE>g77</CODE> compiles exactly one public procedure for the primary entry
point of a procedure plus each <CODE>ENTRY</CODE> point it specifies, as usual.
That is, in terms of the public interface, there is no difference
between

</P>

<PRE>
SUBROUTINE X
END
SUBROUTINE Y
END
</PRE>

<P>
and:

</P>

<PRE>
SUBROUTINE X
ENTRY Y
END
</PRE>

<P>
The difference between the above two cases lies in the code compiled
for the <SAMP>`X'</SAMP> and <SAMP>`Y'</SAMP> procedures themselves, plus the fact that,
for the second case, an extra internal procedure is compiled.

</P>
<P>
For every Fortran procedure with at least one <CODE>ENTRY</CODE>
statement, <CODE>g77</CODE> compiles an extra procedure
named <SAMP>`__g77_masterfun_<VAR>x</VAR>'</SAMP>, where <VAR>x</VAR> is
the name of the primary entry point (which, in the above case,
using the standard compiler options, would be <SAMP>`x_'</SAMP> in C).

</P>
<P>
This extra procedure is compiled as a private procedure--that is,
a procedure not accessible by name to separately compiled modules.
It contains all the code in the program unit, including the code
for the primary entry point plus for every entry point.
(The code for each public procedure is quite short, and explained later.)

</P>
<P>
The extra procedure has some other interesting characteristics.

</P>
<P>
The argument list for this procedure is invented by <CODE>g77</CODE>.
It contains
a single integer argument named <SAMP>`__g77_which_entrypoint'</SAMP>,
passed by value (as in Fortran's <SAMP>`%VAL()'</SAMP> intrinsic), specifying the
entry point index--0 for the primary entry point, 1 for the
first entry point (the first <CODE>ENTRY</CODE> statement encountered), 2 for
the second entry point, and so on.

</P>
<P>
It also contains, for functions returning <CODE>CHARACTER</CODE> and
(when <SAMP>`-ff2c'</SAMP> is in effect) <CODE>COMPLEX</CODE> functions,
and for functions returning different types among the
<CODE>ENTRY</CODE> statements (e.g. <SAMP>`REAL FUNCTION R()'</SAMP>
containing <SAMP>`ENTRY I()'</SAMP>), an argument named <SAMP>`__g77_result'</SAMP> that
is expected at run time to contain a pointer to where to store
the result of the entry point.
For <CODE>CHARACTER</CODE> functions, this
storage area is an array of the appropriate number of characters;
for <CODE>COMPLEX</CODE> functions, it is the appropriate area for the return
type; for multiple-return-type functions, it is a union of all the supported return
types (which cannot include <CODE>CHARACTER</CODE>, since combining <CODE>CHARACTER</CODE>
and non-<CODE>CHARACTER</CODE> return types via <CODE>ENTRY</CODE> in a single function
is not supported by <CODE>g77</CODE>).

</P>
<P>
For <CODE>CHARACTER</CODE> functions, the <SAMP>`__g77_result'</SAMP> argument is followed
by yet another argument named <SAMP>`__g77_length'</SAMP> that, at run time,
specifies the caller's expected length of the returned value.
Note that only <CODE>CHARACTER*(*)</CODE> functions and entry points actually
make use of this argument, even though it is always passed by
all callers of public <CODE>CHARACTER</CODE> functions (since the caller does not
generally know whether such a function is <CODE>CHARACTER*(*)</CODE> or whether
there are any other callers that don't have that information).

</P>
<P>
The rest of the argument list is the union of all the arguments
specified for all the entry points (in their usual forms, e.g.
<CODE>CHARACTER</CODE> arguments have extra length arguments, all appended at
the end of this list).
This is considered the "master list" of
arguments.

</P>
<P>
The code for this procedure has, before the code for the first
executable statement, code much like that for the following Fortran
statement:

</P>

<PRE>
       GOTO (100000,100001,100002), __g77_which_entrypoint
100000 ...code for primary entry point...
100001 ...code immediately following first ENTRY statement...
100002 ...code immediately following second ENTRY statement...
</PRE>

<P>
(Note that invalid Fortran statement labels and variable names
are used in the above example to highlight the fact that it
represents code generated by the <CODE>g77</CODE> internals, not code to be
written by the user.)

</P>
<P>
It is this code that, when the procedure is called, picks which
entry point to start executing.

</P>
<P>
Getting back to the public procedures (<SAMP>`x'</SAMP> and <SAMP>`Y'</SAMP> in the original
example), those procedures are fairly simple.
Their interfaces
are just like they would be if they were self-contained procedures
(without <CODE>ENTRY</CODE>), of course, since that is what the callers
expect.
Their code consists of simply calling the private
procedure, described above, with the appropriate extra arguments
(the entry point index, and perhaps a pointer to a multiple-type-
return variable, local to the public procedure, that contains
all the supported returnable non-character types).
For arguments
that are not listed for a given entry point that are listed for
other entry points, and therefore that are in the "master list"
for the private procedure, null pointers (in C, the <CODE>NULL</CODE> macro)
are passed.
Also, for entry points that are part of a multiple-type-
returning function, code is compiled after the call of the private
procedure to extract from the multi-type union the appropriate result,
depending on the type of the entry point in question, returning
that result to the original caller.

</P>
<P>
When debugging a procedure containing alternate entry points, you
can either set a break point on the public procedure itself (e.g.
a break point on <SAMP>`X'</SAMP> or <SAMP>`Y'</SAMP>) or on the private procedure that
contains most of the pertinent code (e.g. <SAMP>`__g77_masterfun_<VAR>x</VAR>'</SAMP>).
If you do the former, you should use the debugger's command to
"step into" the called procedure to get to the actual code; with
the latter approach, the break point leaves you right at the
actual code, skipping over the public entry point and its call
to the private procedure (unless you have set a break point there
as well, of course).

</P>
<P>
Further, the list of dummy arguments that is visible when the
private procedure is active is going to be the expanded version
of the list for whichever particular entry point is active,
as explained above, and the way in which return values are
handled might well be different from how they would be handled
for an equivalent single-entry function.

</P>


<H2><A NAME="SEC561" HREF="g77_toc.html#TOC561">Alternate Returns (SUBROUTINE and RETURN)</A></H2>
<P>
<A NAME="IDX1938"></A>
<A NAME="IDX1939"></A>
<A NAME="IDX1940"></A>
<A NAME="IDX1941"></A>
<A NAME="IDX1942"></A>
<A NAME="IDX1943"></A>

</P>
<P>
Subroutines with alternate returns (e.g. <SAMP>`SUBROUTINE X(*)'</SAMP> and
<SAMP>`CALL X(*50)'</SAMP>) are implemented by <CODE>g77</CODE> as functions returning
the C <CODE>int</CODE> type.
The actual alternate-return arguments are omitted from the calling sequence.
Instead, the caller uses
the return value to do a rough equivalent of the Fortran
computed-<CODE>GOTO</CODE> statement, as in <SAMP>`GOTO (50), X()'</SAMP> in the
example above (where <SAMP>`X'</SAMP> is quietly declared as an <CODE>INTEGER(KIND=1)</CODE>
function), and the callee just returns whatever integer
is specified in the <CODE>RETURN</CODE> statement for the subroutine
For example, <SAMP>`RETURN 1'</SAMP> is implemented as <SAMP>`X = 1'</SAMP> followed
by <SAMP>`RETURN'</SAMP>
in C, and <SAMP>`RETURN'</SAMP> by itself is <SAMP>`X = 0'</SAMP> and <SAMP>`RETURN'</SAMP>).

</P>


<H2><A NAME="SEC562" HREF="g77_toc.html#TOC562">Assigned Statement Labels (ASSIGN and GOTO)</A></H2>
<P>
<A NAME="IDX1944"></A>
<A NAME="IDX1945"></A>
<A NAME="IDX1946"></A>
<A NAME="IDX1947"></A>
<A NAME="IDX1948"></A>
<A NAME="IDX1949"></A>

</P>
<P>
For portability to machines where a pointer (such as to a label,
which is how <CODE>g77</CODE> implements <CODE>ASSIGN</CODE> and its relatives,
the assigned-<CODE>GOTO</CODE> and assigned-<CODE>FORMAT</CODE>-I/O statements)
is wider (bitwise) than an <CODE>INTEGER(KIND=1)</CODE>, <CODE>g77</CODE>
uses a different memory location to hold the <CODE>ASSIGN</CODE>ed value of a variable
than it does the numerical value in that variable, unless the
variable is wide enough (can hold enough bits).

</P>
<P>
In particular, while <CODE>g77</CODE> implements

</P>

<PRE>
I = 10
</PRE>

<P>
as, in C notation, <SAMP>`i = 10;'</SAMP>, it implements

</P>

<PRE>
ASSIGN 10 TO I
</PRE>

<P>
as, in GNU's extended C notation (for the label syntax),
<SAMP>`__g77_ASSIGN_I = &#38;&#38;L10;'</SAMP> (where <SAMP>`L10'</SAMP> is just a massaging
of the Fortran label <SAMP>`10'</SAMP> to make the syntax C-like; <CODE>g77</CODE> doesn't
actually generate the name <SAMP>`L10'</SAMP> or any other name like that,
since debuggers cannot access labels anyway).

</P>
<P>
While this currently means that an <CODE>ASSIGN</CODE> statement does not
overwrite the numeric contents of its target variable, <EM>do not</EM>
write any code depending on this feature.
<CODE>g77</CODE> has already changed this implementation across
versions and might do so in the future.
This information is provided only to make debugging Fortran programs
compiled with the current version of <CODE>g77</CODE> somewhat easier.
If there's no debugger-visible variable named <SAMP>`__g77_ASSIGN_I'</SAMP>
in a program unit that does <SAMP>`ASSIGN 10 TO I'</SAMP>, that probably
means <CODE>g77</CODE> has decided it can store the pointer to the label directly
into <SAMP>`I'</SAMP> itself.

</P>
<P>
See section <A HREF="g77_13.html#SEC367">Ugly Assigned Labels</A>, for information on a command-line option
to force <CODE>g77</CODE> to use the same storage for both normal and
assigned-label uses of a variable.

</P>


<H2><A NAME="SEC563" HREF="g77_toc.html#TOC563">Run-time Library Errors</A></H2>
<P>
<A NAME="IDX1950"></A>
<A NAME="IDX1951"></A>
<A NAME="IDX1952"></A>
<A NAME="IDX1953"></A>
<A NAME="IDX1954"></A>

</P>
<P>
The <CODE>libg2c</CODE> library currently has the following table to relate
error code numbers, returned in <CODE>IOSTAT=</CODE> variables, to messages.
This information should, in future versions of this document, be
expanded upon to include detailed descriptions of each message.

</P>
<P>
In line with good coding practices, any of the numbers in the
list below should <EM>not</EM> be directly written into Fortran
code you write.
Instead, make a separate <CODE>INCLUDE</CODE> file that defines
<CODE>PARAMETER</CODE> names for them, and use those in your code,
so you can more easily change the actual numbers in the future.

</P>
<P>
The information below is culled from the definition
of <CODE>F_err</CODE> in <TT>`f/runtime/libI77/err.c'</TT> in the
<CODE>g77</CODE> source tree.

</P>

<PRE>
100: "error in format"
101: "illegal unit number"
102: "formatted io not allowed"
103: "unformatted io not allowed"
104: "direct io not allowed"
105: "sequential io not allowed"
106: "can't backspace file"
107: "null file name"
108: "can't stat file"
109: "unit not connected"
110: "off end of record"
111: "truncation failed in endfile"
112: "incomprehensible list input"
113: "out of free space"
114: "unit not connected"
115: "read unexpected character"
116: "bad logical input field"
117: "bad variable type"
118: "bad namelist name"
119: "variable not in namelist"
120: "no end record"
121: "variable count incorrect"
122: "subscript for scalar variable"
123: "invalid array section"
124: "substring out of bounds"
125: "subscript out of bounds"
126: "can't read file"
127: "can't write file"
128: "'new' file exists"
129: "can't append to file"
130: "non-positive record number"
131: "I/O started while already doing I/O"
</PRE>

<P><HR><P>
<p>Go to the <A HREF="g77_1.html">first</A>, <A HREF="g77_17.html">previous</A>, <A HREF="g77_19.html">next</A>, <A HREF="g77_28.html">last</A> section, <A HREF="g77_toc.html">table of contents</A>.
</BODY>
</HTML>
